# SPDX-License-Identifier: MIT

from .common import BasicJinjaRender
from .lang import language, TEMPLATE_DIR
from ..model import Property

import os
import sys
import subprocess
import re
import inspect

DATATYPES = {
    "http://www.w3.org/2001/XMLSchema#string": "string",
    "http://www.w3.org/2001/XMLSchema#anyURI": "string",
    "http://www.w3.org/2001/XMLSchema#integer": "int",
    "http://www.w3.org/2001/XMLSchema#positiveInteger": "uint", # "PInt",
    "http://www.w3.org/2001/XMLSchema#nonNegativeInteger": "uint",
    "http://www.w3.org/2001/XMLSchema#boolean": "bool",
    "http://www.w3.org/2001/XMLSchema#decimal": "float64",
    "http://www.w3.org/2001/XMLSchema#dateTime": "string", # "DateTime",
    "http://www.w3.org/2001/XMLSchema#dateTimeStamp": "string", # "DateTimeStamp",
}

RESERVED_WORDS = {
    "package"
}


@language("golang")
class GolangRender(BasicJinjaRender):
    HELP = "Go Language Bindings"
    # conform to go:generate format: https://pkg.go.dev/cmd/go#hdr-Generate_Go_files_by_processing_source
    disclaimer = f"Code generated by {os.path.basename(sys.argv[0])}. DO NOT EDIT."

    # set during render, for convenience
    render_args = None

    # arg defaults:
    package_name = "model"
    license_id = False
    use_embedding = False
    getter_prefix = "Get"
    setter_prefix = "Set"
    export_structs = "true"
    interface_prefix = "I"
    interface_suffix = ""
    struct_prefix = ""
    struct_suffix = ""
    embedded_prefix = "super_"
    pluralize = False
    pluralize_length = 3
    include_runtime = "true"
    include_view_pointers = False
    as_concrete_prefix = "As"
    uppercase_constants = True
    constant_separator = "_"
    remap_props = ""
    remap_props_map = {}

    @classmethod
    def get_arguments(cls, parser):
        super().get_arguments(parser)
        parser.add_argument("--package-name", help="Go package name to generate", default=cls.package_name)
        parser.add_argument("--license-id", help="SPDX License identifier to include in the generated code", default=cls.license_id)
        parser.add_argument("--use-embedding", type=bool, help="use embedded structs", default=cls.use_embedding)
        parser.add_argument("--export-structs", help="export structs", default=cls.export_structs)
        parser.add_argument("--struct-suffix", help="struct stuffix", default=cls.struct_suffix)
        parser.add_argument("--interface-prefix", help="interface prefix", default=cls.interface_prefix)
        parser.add_argument("--include-runtime", help="include runtime functions inline", default=cls.include_runtime)
        parser.add_argument("--include-view-pointers", type=bool, help="include runtime functions inline", default=cls.include_view_pointers)
        parser.add_argument("--disclaimer", help="file header", default=cls.disclaimer)
        parser.add_argument("--remap-props", help="property name mapping", default=cls.remap_props)
        parser.add_argument("--pluralize", default=cls.pluralize)

    def __init__(self, args):
        super().__init__(args, TEMPLATE_DIR / "golang.j2")
        for k, v in inspect.getmembers(args):
            if k in GolangRender.__dict__ and not k in BasicJinjaRender.__dict__:
                setattr(self, k, v)

    def render(self, template, output, *, extra_env={}, render_args={}):
        if self.remap_props:
            self.remap_props_map = dict(item.split("=") for item in self.remap_props.split(","))

        class FW:
            d = ""

            def write(self, d):
                self.d += d

        w = FW()
        self.render_args = render_args
        super().render(template, w, extra_env=extra_env, render_args=render_args)
        formatted = gofmt(w.d)
        output.write(formatted)

    def get_extra_env(self):
        return {
            "trim_iri": trim_iri,
            "indent": indent,
            "upper_first": upper_first,
            "lower_first": lower_first,
            "is_array": is_array,
            "comment": comment,
        }

    def get_additional_render_args(self):
        render_args = {}
        # add all directly defined functions and variables
        for k, v in inspect.getmembers(self):
            if k.startswith("_") or k in BasicJinjaRender.__dict__:
                continue
            render_args[k] = v
        return render_args

    def parents(self,cls):
        return [self.all_classes().get(parent_id) for parent_id in cls.parent_ids]

    def properties(self,cls):
        props = cls.properties
        if cls.id_property and not cls.parent_ids:
            return [
                Property(
                    path="@id",
                    datatype="http://www.w3.org/2001/XMLSchema#string",
                    min_count=1, # is this accurate?
                    max_count=1,
                    varname=cls.id_property,
                    comment="identifier property",
                ),
            ] + props
        return props

    def all_classes(self):
        return self.render_args["classes"]

    def pluralize_name(self,str):
        if not self.pluralize:
            return str
        if len(str) < self.pluralize_length:
            return str
        if not str.endswith('s'):
            return str + "s"
        return str

    def struct_prop_name(self,prop):
        # prop:
        #  class_id, comment, datatype, enum_values, max_count, min_count, path, pattern, varname
        name = prop.varname
        if is_array(prop):
            name = self.pluralize_name(name)

        if name in self.remap_props_map:
            name = self.remap_props_map[name]

        name = type_name(name)

        if self.export_structs.lower() != "false":
            return upper_first(name)

        return lower_first(name)

    def prop_type(self,prop):
        # prop:
        #  class_id, comment, datatype, enum_values, max_count, min_count, path, pattern, varname
        if prop.datatype in DATATYPES:
            typ = DATATYPES[prop.datatype]
        else:
            cls = self.all_classes().get(prop.class_id)
            if self.requires_interface(cls):
                typ = self.interface_name(cls)
            else:
                typ = self.struct_name(cls)

        return typ

    def parent_has_prop(self, cls, prop):
        for parent in self.parents(cls):
            for p in self.properties(parent):
                if p.varname == prop.varname:
                    return True
            if self.parent_has_prop(parent, prop):
                return True

        return False

    def requires_interface(self,cls):
        if cls.properties:
            return True
        if cls.derived_ids:
            return True
        # if cls.named_individuals:
        #     return False
        # if cls.node_kind == rdflib.term.URIRef('http://www.w3.org/ns/shacl#BlankNodeOrIRI'):
        #     return True
        if cls.parent_ids:
            return True
        return False

    def include_prop(self, cls, prop):
        return not self.parent_has_prop(cls, prop)

    def interface_name(self,cls):
        return upper_first(self.interface_prefix + type_name(cls.clsname) + self.interface_suffix)

    def struct_name(self,cls):
        name = self.struct_prefix + type_name(cls.clsname) + self.struct_suffix
        if self.export_structs:
            name = upper_first(name)
        else:
            name = lower_first(name)

        if name in RESERVED_WORDS:
            return name + "_"

        return name

    def pretty_name(self,cls):
        return upper_first(type_name(cls.clsname))

    def constant_var_name(self,named):
        if self.uppercase_constants:
            return upper_first(named.varname)
        return named.varname

    def getter_name(self,prop):
        return self.getter_prefix + upper_first(self.struct_prop_name(prop))

    def setter_name(self,prop):
        return self.setter_prefix + upper_first(self.struct_prop_name(prop))

    def concrete_name(self,cls):
        if self.export_structs.lower() != "false":
            return self.struct_name(cls)
        if self.use_embedding:
            return self.embedded_prefix + upper_first(self.struct_name(cls))
        if cls.is_abstract:
            return self.struct_name(cls)
        return upper_first(self.struct_name(cls))

    def include_runtime_code(self):
        if self.include_runtime.lower() == "false":
            return ""

        package_replacer = "package[^\n]+"
        import_replacer = "import[^)]+\\)"
        code = ""
        dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "go_runtime")
        with open(os.path.join(dir, "ld_context.go")) as f:
            code += re.sub(package_replacer, "", f.read())
        with open(os.path.join(dir, "graph_builder.go")) as f:
            code += re.sub(package_replacer, "", re.sub(import_replacer, "", f.read()))
        if self.include_view_pointers:
            with open(os.path.join(dir, "superclass_view.go")) as f:
                code += re.sub(package_replacer, "", re.sub(import_replacer, "", f.read()))
        return code


# common utility functions


def upper_first(str):
    return str[0].upper() + str[1:]


def lower_first(str):
    return str[0].lower() + str[1:]


def indent(indent_with, str):
    parts = re.split("\n", str)
    return indent_with + ("\n"+indent_with).join(parts)


def dedent(str, amount):
    prefix = ' ' * amount
    parts = re.split("\n", str)
    for i in range(len(parts)):
        if parts[i].startswith(prefix):
            parts[i] = parts[i][len(prefix):]
    return '\n'.join(parts)


def type_name(name):
    if isinstance(name, list):
        name = "".join(name)
    parts = re.split(r'[^a-zA-Z0-9]', name)
    part = parts[len(parts)-1]
    return upper_first(part)


def gofmt(code):
    try:
        proc = subprocess.Popen(["gofmt"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, text=True)
        result = proc.communicate(input=code)
        if result[0] != "":
            return result[0]
        return code
    except:
        return code


def is_array(prop):
    return prop.max_count is None or prop.max_count > 1


def comment(indent_with, identifier, text):
    if text.lower().startswith(identifier.lower()):
        text = text[len(identifier):]
    text = identifier + " " + lower_first(text)
    return indent(indent_with, text)


def trim_iri(base,iri):
    if not base.endswith("/"):
        base += "/"
    if False and iri.startswith(base):
        return iri[len(base):]
    return iri

