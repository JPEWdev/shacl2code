#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# {{ disclaimer }}
#
# SPDX-License-Identifier: MIT

import functools
import hashlib
import json
import re
import time
from contextlib import contextmanager
from datetime import datetime, timezone, timedelta
from enum import Enum
from abc import ABC, abstractmethod


def check_type(obj, types):
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj)}"
            )
        raise TypeError(f"Value must be of type {types.__name__}. Got {type(obj)}")


class Property(ABC):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    def __init__(self, *, pattern=None):
        self.pattern = pattern

    def init(self):
        return None

    def validate(self, value):
        check_type(value, self.VALID_TYPES)
        if self.pattern is not None and not re.search(
            self.pattern, self.to_string(value)
        ):
            raise ValueError(f"Value is not correctly formatted. Got '{value}'")

    def set(self, value):
        return value

    def check_min_count(self, value, min_count):
        return min_count == 1

    def check_max_count(self, value, max_count):
        return max_count == 1

    def elide(self, value):
        return value is None

    def walk(self, value, callback, path):
        callback(value, path)

    def link_prop(self, value, link_cache, missing, visited):
        return value

    @classmethod
    def to_string(cls, value):
        return str(value)

    @abstractmethod
    def encode(self, encoder, value, state):
        pass

    @abstractmethod
    def decode(self, decoder, *, object_ids=None):
        pass


class StringProp(Property):
    """
    A scalar string property for an SHACL object
    """

    VALID_TYPES = str

    def set(self, value):
        return str(value)

    def encode(self, encoder, value, state):
        encoder.write_string(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_string()


class AnyURIProp(StringProp):
    def encode(self, encoder, value, state):
        encoder.write_iri(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_iri()


class DateTimeProp(Property):
    """
    A Date/Time Object
    """

    VALID_TYPES = datetime
    UTC_FORMAT_STR = "%Y-%m-%dT%H:%M:%SZ"
    REGEX = r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$"

    def set(self, value):
        return self._normalize(value)

    def encode(self, encoder, value, state):
        encoder.write_datetime(value)

    def decode(self, decoder, *, object_ids=None):
        return self._normalize(decoder.read_datetime())

    @classmethod
    def _normalize(cls, value):
        if value.utcoffset() is None:
            value = value.astimezone()
        offset = value.utcoffset()
        if offset % timedelta(minutes=1):
            offset = offset - (offset % timedelta(minutes=1))
            value = value.replace(tzinfo=timezone(offset))
        value = value.replace(microsecond=0)
        return value

    @classmethod
    def to_string(cls, value):
        value = cls._normalize(value)
        if value.tzinfo == timezone.utc:
            return value.strftime(cls.UTC_FORMAT_STR)
        return value.isoformat()

    @classmethod
    def from_string(cls, value):
        if not re.match(cls.REGEX, value):
            raise ValueError(f"'{value}' is not a correctly formatted datetime")
        if "Z" in value:
            d = datetime(
                *(time.strptime(value, cls.UTC_FORMAT_STR)[0:6]),
                tzinfo=timezone.utc,
            )
        else:
            d = datetime.fromisoformat(value)

        return cls._normalize(d)


class IntegerProp(Property):
    VALID_TYPES = int

    def set(self, value):
        return int(value)

    def encode(self, encoder, value, state):
        encoder.write_integer(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_integer()


class PositiveIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property):
    VALID_TYPES = bool

    def set(self, value):
        return bool(value)

    def encode(self, encoder, value, state):
        encoder.write_bool(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_bool()


class FloatProp(Property):
    VALID_TYPES = (float, int)

    def set(self, value):
        return float(value)

    def encode(self, encoder, value, state):
        encoder.write_float(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_float()


class ObjectProp(Property):
    """
    A scalar SHACL object property of a SHACL object
    """

    def __init__(self, cls, required):
        super().__init__()
        self.cls = cls
        self.required = required

    def init(self):
        if self.required:
            return self.cls()
        return None

    def validate(self, value):
        check_type(value, (self.cls, str))

    def walk(self, value, callback, path):
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def encode(self, encoder, value, state):
        if value is None:
            raise ValueError("Object cannot be None")

        if isinstance(value, str):
            encoder.write_iri(value)
            return

        return value.encode(encoder, state, is_reference=True)

    def decode(self, decoder, *, object_ids=None):
        iri = decoder.read_iri()
        if iri is not None:
            if object_ids and iri in object_ids:
                return object_ids[iri]
            return iri

        return SHACLObject.decode(decoder, object_ids=object_ids)

    def link_prop(self, value, link_cache, missing, visited):
        if value is None:
            return value

        if isinstance(value, str):
            if value in link_cache:
                return link_cache[value]

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id and value._id is not link_cache[value._id]:
            value = link_cache[value._id]

        value.link_helper(link_cache, missing, visited)
        return value


class ListProxy(object):
    def __init__(self, prop, data=None):
        if data is None:
            self.__data = []
        else:
            self.__data = data
        self.__prop = prop

    def append(self, value):
        self.__prop.validate(value)
        self.__data.append(self.__prop.set(value))

    def insert(self, idx, value):
        self.__prop.validate(value)
        self.__data.insert(idx, self.__prop.set(value))

    def extend(self, items):
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs):
        self.__data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        if isinstance(key, slice):
            for v in value:
                self.__prop.validate(v)
            self.__data[key] = [self.__prop.set(v) for v in value]
        else:
            self.__prop.validate(value)
            self.__data[key] = self.__prop.set(value)

    def __delitem__(self, key):
        del self.__data[key]

    def __contains__(self, item):
        return item in self.__data

    def __iter__(self):
        return iter(self.__data)

    def __len__(self):
        return len(self.__data)

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)

    def __eq__(self, other):
        if isinstance(other, ListProxy):
            return self.__data == other.__data

        return self.__data == other


class ListProp(Property):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    def __init__(self, prop):
        super().__init__()
        self.prop = prop

    def init(self):
        return ListProxy(self.prop)

    def validate(self, value):
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(self, value):
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, [self.prop.set(d) for d in value])

    def check_min_count(self, value, min_count):
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value, max_count):
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value):
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(self, value, callback, path):
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def link_prop(self, value, link_cache, missing, visited):
        if isinstance(value, ListProxy):
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]
        else:
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]

        return ListProxy(self.prop, data=data)

    def encode(self, encoder, value, state):
        check_type(value, ListProxy)

        with encoder.write_list() as list_s:
            for v in value:
                with list_s.write_list_item() as item_s:
                    self.prop.encode(item_s, v, state)

    def decode(self, decoder, *, object_ids=None):
        data = []
        for val_d in decoder.read_list():
            v = self.prop.decode(val_d, object_ids=object_ids)
            self.prop.validate(v)
            data.append(v)

        return ListProxy(self.prop, data=data)


class EnumProp(Property):
    VALID_TYPES = str

    def validate(self, value):
        super().validate(value)

        if value not in (v for _, v in self.valid_values):
            raise ValueError(
                f"'{value}' is not a valid value for '{self.__class__.__name__}'"
            )

    def encode(self, encoder, value, state):
        encoder.write_enum(value, self)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_enum(self)


class Refable(Enum):
    no = 1
    local = 2
    optional = 3
    yes = 4
    always = 5


@functools.total_ordering
class SHACLObject(object):
    DESERIALIZERS = {}
    REFABLE = Refable.optional
    ID_ALIAS = None

    def __init__(self):
        self._obj_data = {}
        self._obj_properties = {}
        self._obj_iris = {}
        self._obj_metadata = {}

        self._add_property("_id", StringProp(), iri="@id")

    def _set_init_props(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def _add_property(
        self,
        pyname,
        prop,
        iri,
        min_count=None,
        max_count=None,
    ):
        if pyname in self._obj_iris:
            raise KeyError(
                f"'{pyname}' is already defined for '{self.__class__.__name__}'"
            )
        if iri in self._obj_properties:
            raise KeyError(
                f"'{iri}' is already defined for '{self.__class__.__name__}'"
            )

        while hasattr(self, pyname):
            pyname = pyname + "_"

        self._obj_iris[pyname] = iri
        self._obj_properties[iri] = (prop, min_count, max_count, pyname)
        self._obj_data[iri] = prop.init()

    def __setattr__(self, name, value):
        if name.startswith("_obj_"):
            return super().__setattr__(name, value)

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            self[iri] = value
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __getattr__(self, name):
        if name.startswith("_obj_"):
            return self.__dict__[name]

        if name == "_metadata":
            return self._obj_metadata

        if name == "_IRI":
            return self._obj_iris

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            return self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __delattr__(self, name):
        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            del self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __get_prop(self, iri):
        if iri not in self._obj_properties:
            raise KeyError(
                f"'{iri}' is not a valid property of {self.__class__.__name__}"
            )

        return self._obj_properties[iri]

    def __iter_props(self):
        for iri, v in self._obj_properties.items():
            prop, min_count, max_count, pyname = v
            yield iri, prop, min_count, max_count, pyname

    def __getitem__(self, iri):
        return self._obj_data[iri]

    def __setitem__(self, iri, value):
        if iri == "@id":
            if self.REFABLE == Refable.no:
                raise ValueError(
                    f"{self.__class__.__name__} ({id(self)}) is not referenceable. Property '{iri}' cannot be set to '{value}'"
                )
            elif self.REFABLE == Refable.local:
                if not value.startswith("_:"):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can only have local reference. Property '{iri}' cannot be set to '{value}' and must start with '_:'"
                    )
            elif self.REFABLE in [Refable.yes, Refable.always]:
                if value.startswith("_:"):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can has mandatory reference. Property '{iri}' cannot be set to '{value}'"
                    )

        prop, _, _, _ = self.__get_prop(iri)
        prop.validate(value)
        self._obj_data[iri] = prop.set(value)

    def __delitem__(self, iri):
        prop, _, _, _ = self.__get_prop(iri)
        self._obj_data[iri] = prop.init()

    def __iter__(self):
        return self._obj_properties.keys()

    def walk(self, callback, path=None):
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(object, path):
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for iri, prop, _, _, _ in self.__iter_props():
                prop.walk(self._obj_data[iri], callback, path + [f".{iri}"])

    def child_objects(self):
        """
        Iterate over each object that is a child of this one
        """
        seen = set()

        def _walk_callback(value, path):
            nonlocal seen

            if not isinstance(value, SHACLObject):
                return False

            if value in seen:
                return False

            seen.add(value)
            return True

        self.walk(_walk_callback)

        for obj in seen:
            yield obj

    def encode(self, encoder, state, *, is_reference=False):
        idname = self.ID_ALIAS or self._obj_iris["_id"]
        if not self._id and self.REFABLE in [Refable.yes, Refable.always]:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must have a '{idname}' property to be referenceable"
            )

        if state.is_written(self):
            if self.REFABLE == Refable.no:
                raise ValueError(
                    f"{self.__class__.__name__} ({id(self)}) is not referenceable"
                )
            encoder.write_iri(state.get_object_id(self))
            return

        if is_reference and self.REFABLE == Refable.always:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must always be referenced by name, and cannot be inlined"
            )

        state.add_written(self)

        with encoder.write_object(
            self,
            state.get_object_id(self),
            bool(self._id) or state.is_refed(self),
        ) as obj_s:
            for iri, prop, min_count, max_count, pyname in self.__iter_props():
                value = self._obj_data[iri]
                if prop.elide(value):
                    if min_count:
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) is required (currently {value!r})"
                        )
                    continue

                if min_count is not None:
                    if not prop.check_min_count(value, min_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a minimum of {min_count} elements"
                        )

                if max_count is not None:
                    if not prop.check_max_count(value, max_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a maximum of {max_count} elements"
                        )

                if iri == self._obj_iris["_id"]:
                    continue

                with obj_s.write_property(iri) as prop_s:
                    prop.encode(prop_s, value, state)

    @classmethod
    def decode(cls, decoder, *, object_ids=None):
        typ, obj_d = decoder.read_object()
        if typ is None:
            raise TypeError("Unable to determine type for object")

        if typ not in cls.DESERIALIZERS:
            raise TypeError(f"Unknown type {typ}")

        obj = cls.DESERIALIZERS[typ]()
        _id = obj_d.read_object_id(obj.ID_ALIAS)
        if _id is not None:
            if object_ids is not None:
                if _id in object_ids:
                    return object_ids[_id]
                object_ids[_id] = obj
            obj._id = _id

        for iri, prop, _, _, _ in obj.__iter_props():
            if iri == obj._obj_iris["_id"]:
                continue

            with obj_d.read_property(iri) as prop_d:
                if prop_d is None:
                    continue

                v = prop.decode(prop_d, object_ids=object_ids)
                prop.validate(v)
                obj._obj_data[iri] = v

        return obj

    def link_helper(self, link_cache, missing, visited):
        if self in visited:
            return

        visited.add(self)

        for iri, prop, _, _, _ in self.__iter_props():
            self._obj_data[iri] = prop.link_prop(
                self._obj_data[iri],
                link_cache,
                missing,
                visited,
            )

    def link(self, link_cache=None):
        if not link_cache:
            link_cache = {obj._id: obj for obj in self.child_objects() if obj._id}

        missing = set()
        visited = set()

        self.link_helper(link_cache, missing, visited)

        return missing

    def __str__(self):
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self):
        return super().__hash__()

    def __eq__(self, other):
        return super().__eq__(other)

    def __lt__(self, other):
        def sort_key(obj):
            if isinstance(obj, str):
                return (obj, "", "", "")
            return (
                obj._id or "",
                obj.TYPE,
                getattr(obj, "name", None) or "",
                id(obj),
            )

        return sort_key(self) < sort_key(other)


def make_context():
    global CONTEXTS
    return Context(CONTEXTS)


class EncodeState(object):
    def __init__(self):
        self.ref_objects = set()
        self.written_objects = set()
        self.blank_objects = {}

    def get_object_id(self, o):
        if o._id:
            return o._id

        if o not in self.blank_objects:
            _id = f"_:{o.__class__.__name__}{len(self.blank_objects)}"
            self.blank_objects[o] = _id

        return self.blank_objects[o]

    def is_refed(self, o):
        return o in self.ref_objects

    def add_refed(self, o):
        self.ref_objects.add(o)

    def is_written(self, o):
        return o in self.written_objects

    def add_written(self, o):
        self.written_objects.add(o)


def encode_objects(encoder, objects, force_list=False):
    """
    Serialize a list of objects to a serialization encoder

    If force_list is true, a list will always be written using the encoder.
    """
    ref_counts = {}
    state = EncodeState()

    def walk_callback(value, path):
        nonlocal state
        nonlocal ref_counts

        if not isinstance(value, SHACLObject):
            return True

        # Remove blank node ID for re-assignment
        if value._id and value._id.startswith("_:"):
            del value._id

        if value._id or value.REFABLE == Refable.always:
            state.add_refed(value)

        # If the object is referenced more than once, add it to the set of
        # referenced objects
        ref_counts.setdefault(value, 0)
        ref_counts[value] += 1
        if ref_counts[value] > 1:
            state.add_refed(value)
            return False

        return True

    for o in objects:
        o.walk(walk_callback)

    use_list = force_list or len(objects) > 1

    objects = set(objects)

    if use_list:
        # If we are making a list add all the objects referred to by reference
        # to the list
        objects |= state.ref_objects

    objects = list(objects)
    objects.sort()

    if use_list:
        # Ensure top level objects are only written in the top level graph
        # node, and referenced by ID everywhere else. This is done by setting
        # the flag that indicates this object has been written for all the top
        # level objects, then clearing it right before serializing the object.
        #
        # In this way, if an object is referenced before it is supposed to be
        # serialized into the @graph, it will serialize as a string instead of
        # the actual object
        for o in objects:
            state.written_objects.add(o)

        with encoder.write_list() as list_s:
            for o in objects:
                # Allow this specific object to be written now
                state.written_objects.remove(o)
                with list_s.write_list_item() as item_s:
                    o.encode(item_s, state)

    else:
        objects[0].encode(encoder, state)


def decode_objects(decoder):
    object_ids = {}
    objects = [
        SHACLObject.decode(obj_d, object_ids=object_ids)
        for obj_d in decoder.read_list()
    ]

    for o in objects:
        o.link(object_ids)

    # Remove blank node IDs
    for o in objects:
        for c in o.child_objects():
            if c._id and c._id.startswith("_:"):
                del c._id

    object_ids = {k: v for k, v in object_ids.items() if not k.startswith("_:")}

    return objects, object_ids


class Decoder(ABC):
    @abstractmethod
    def read_string(self):
        pass

    @abstractmethod
    def read_integer(self):
        pass

    @abstractmethod
    def read_iri(self):
        pass

    @abstractmethod
    def read_enum(self, e):
        pass

    @abstractmethod
    def read_bool(self):
        pass

    @abstractmethod
    def read_float(self):
        pass

    @abstractmethod
    def read_list(self):
        pass

    @abstractmethod
    @contextmanager
    def read_property(self, iri):
        pass

    @abstractmethod
    def read_object(self):
        pass

    @abstractmethod
    def read_object_id(self, alias=None):
        pass


class JSONLDDecoder(Decoder):
    def __init__(self, data, context):
        self.data = data
        self.context = context

    def read_string(self):
        if isinstance(self.data, str):
            return self.data
        return None

    def read_datetime(self):
        if isinstance(self.data, str):
            return DateTimeProp.from_string(self.data)
        return None

    def read_integer(self):
        if isinstance(self.data, int):
            return self.data
        return None

    def read_bool(self):
        if isinstance(self.data, bool):
            return self.data
        return None

    def read_float(self):
        if isinstance(self.data, (int, float, str)):
            return float(self.data)
        return None

    def read_iri(self):
        if isinstance(self.data, str):
            return self.context.expand(self.data)
        return None

    def read_enum(self, e):
        if isinstance(self.data, str):
            return self.context.expand_vocab(self.data)
        return None

    def read_list(self):
        if isinstance(self.data, (list, tuple, set)):
            for v in self.data:
                yield self.__class__(v, self.context)
        else:
            yield self

    @contextmanager
    def read_property(self, iri):
        for k in (iri, self.context.compact_vocab(iri)):
            if k in self.data:
                with self.context.vocab_push(iri):
                    yield self.__class__(self.data[k], self.context)
                return

        yield None

    def read_object(self):
        for k in ("@type", self.context.compact("@type")):
            if k not in self.data:
                continue

            typ = self.context.expand(self.data[k])
            return typ, self

        return None, self

    def read_object_id(self, alias=None):
        if alias and alias in self.data:
            return self.data[alias]

        for k in ("@id", self.context.compact("@id")):
            if k in self.data:
                return self.data[k]

        return None


class JSONLDDeserializer(object):
    def read(self, f):
        context = make_context()
        data = json.load(f)
        if "@graph" in data:
            h = JSONLDDecoder(data["@graph"], context)
        else:
            h = JSONLDDecoder(data, context)

        return decode_objects(h)


class Encoder(ABC):
    @abstractmethod
    def write_string(self, v):
        pass

    @abstractmethod
    def write_datetime(self, v):
        pass

    @abstractmethod
    def write_integer(self, v):
        pass

    @abstractmethod
    def write_iri(self, v):
        pass

    @abstractmethod
    def write_enum(self, v, e):
        pass

    @abstractmethod
    def write_bool(self, v):
        pass

    @abstractmethod
    def write_float(self, v):
        pass

    @abstractmethod
    @contextmanager
    def write_property(self, iri):
        pass

    @abstractmethod
    @contextmanager
    def write_object(self, o, _id, needs_id):
        pass

    @abstractmethod
    @contextmanager
    def write_list(self):
        pass

    @abstractmethod
    @contextmanager
    def write_list_item(self):
        pass


class JSONLDEncoder(Encoder):
    def __init__(self, context, data=None):
        self.data = data
        self.context = context

    def write_string(self, v):
        self.data = v

    def write_datetime(self, v):
        self.data = DateTimeProp.to_string(v)

    def write_integer(self, v):
        self.data = v

    def write_iri(self, v):
        self.write_string(self.context.compact(v))

    def write_enum(self, v, e):
        self.write_string(self.context.compact_vocab(v))

    def write_bool(self, v):
        self.data = v

    def write_float(self, v):
        self.data = str(v)

    @contextmanager
    def write_property(self, iri):
        s = self.__class__(self.context, None)
        with self.context.vocab_push(iri):
            yield s
        if s.data is not None:
            self.data[self.context.compact_vocab(iri)] = s.data

    @contextmanager
    def write_object(self, o, _id, needs_id):
        self.data = {
            self.context.compact("@type"): self.context.compact_vocab(o.TYPE),
        }
        if needs_id:
            self.data[o.ID_ALIAS or self.context.compact("@id")] = self.context.compact(
                _id
            )
        yield self

    @contextmanager
    def write_list(self):
        self.data = []
        yield self
        if not self.data:
            self.data = None

    @contextmanager
    def write_list_item(self):
        s = self.__class__(self.context, None)
        yield s
        if s.data is not None:
            self.data.append(s.data)


class JSONLDSerializer(object):
    def serialize_data(self, objects, force_graph=False):
        context = make_context()
        h = JSONLDEncoder(context)
        encode_objects(h, objects, force_graph)
        if isinstance(h.data, list):
            data = {
                "@graph": h.data,
            }
        else:
            data = h.data

        if len(CONTEXT_URLS) == 1:
            data["@context"] = CONTEXT_URLS[0]
        elif CONTEXT_URLS:
            data["@context"] = CONTEXT_URLS

        return data

    def write(self, objects, f, force_graph=False, **kwargs):
        """
        Write a list of objects to a JSON LD file

        If force_graph is True, a @graph node will always be written
        """
        data = self.serialize_data(objects, force_graph)

        sha1 = hashlib.sha1()
        for chunk in json.JSONEncoder(**kwargs).iterencode(data):
            chunk = chunk.encode("utf-8")
            f.write(chunk)
            sha1.update(chunk)

        return sha1.hexdigest()


class JSONLDInlineEncoder(Encoder):
    def __init__(self, f, context, sha1):
        self.f = f
        self.context = context
        self.comma = False
        self.sha1 = sha1

    def write(self, s):
        s = s.encode("utf-8")
        self.f.write(s)
        self.sha1.update(s)

    def _write_comma(self):
        if self.comma:
            self.write(",")
            self.comma = False

    def _need_comma(self):
        self.comma = True

    def write_string(self, v):
        self.write(f'"{v}"')

    def write_datetime(self, v):
        self.write('"' + DateTimeProp.to_string(v) + '"')

    def write_integer(self, v):
        self.write(f"{v}")

    def write_iri(self, v):
        self.write_string(self.context.compact(v))

    def write_enum(self, v, e):
        self.write_iri(v)

    def write_bool(self, v):
        if v:
            self.write("true")
        else:
            self.write("false")

    def write_float(self, v):
        self.write(f'"{v}"')

    @contextmanager
    def write_property(self, iri):
        self._write_comma()
        p = self.context.compact(iri)
        self.write(f'"{p}":')
        with self.context.vocab_push(iri):
            yield self
        self.comma = True

    @contextmanager
    def write_object(self, o, _id, needs_id):
        self._write_comma()

        typname = self.context.compact("@type")
        typval = self.context.compact_vocab(o.TYPE)
        self.write("{")
        if needs_id:
            idname = o.ID_ALIAS or self.context.compact("@id")
            idval = self.context.compact(_id)
            self.write(f'"{idname}": "{idval}",')
        self.write(f'"{typname}":"{typval}"')

        self.comma = True
        yield self

        self.write("}")
        self.comma = True

    @contextmanager
    def write_list(self):
        self._write_comma()
        self.write("[")
        yield self.__class__(self.f, self.context, self.sha1)
        self.write("]")
        self.comma = True

    @contextmanager
    def write_list_item(self):
        self._write_comma()
        yield self.__class__(self.f, self.context, self.sha1)
        self.comma = True


class JSONLDInlineSerializer(object):
    def write(self, objects, f):
        """
        Write a list of objects to a JSON LD file
        """
        sha1 = hashlib.sha1()
        h = JSONLDInlineEncoder(f, make_context(), sha1)
        h.write('{"@context":')
        if len(CONTEXT_URLS) == 1:
            h.write(f'"{CONTEXT_URLS[0]}"')
        elif CONTEXT_URLS:
            h.write('["')
            h.write('","'.join(CONTEXT_URLS))
            h.write('"]')
        h.write(",")

        h.write('"@graph":')

        encode_objects(h, objects, True)
        h.write("}")
        return sha1.hexdigest()


def print_tree(objects, all_fields=False):
    """
    Print object tree
    """
    seen = set()

    def callback(value, path):
        nonlocal seen

        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard{{ '"' }}{{ '"' }}{{ '"' }}
{% set
DATATYPE_CLASSES = {
    "http://www.w3.org/2001/XMLSchema#string": "StringProp",
    "http://www.w3.org/2001/XMLSchema#anyURI": "AnyURIProp",
    "http://www.w3.org/2001/XMLSchema#integer": "IntegerProp",
    "http://www.w3.org/2001/XMLSchema#positiveInteger": "PositiveIntegerProp",
    "http://www.w3.org/2001/XMLSchema#nonNegativeInteger": "NonNegativeIntegerProp",
    "http://www.w3.org/2001/XMLSchema#boolean": "BooleanProp",
    "http://www.w3.org/2001/XMLSchema#decimal": "FloatProp",
    "http://www.w3.org/2001/XMLSchema#dateTime": "DateTimeProp",
}
%}

{%- macro dump_dictionary(d, indent) %}
{%- for k, v in d.items() %}
{%- if v is mapping %}
{{ "    " * indent }}"{{ k }}" : {
{{- dump_dictionary(v, indent+1) }}
{{ "    " * indent }}},
{%- else %}
{{ "    " * indent }}"{{ k }}": "{{ v }}",
{%- endif %}
{%- endfor %}
{%- endmacro %}
CONTEXTS = [
    {%- for ctx in context.contexts %}
    {
    {{- dump_dictionary(ctx, 2) }}
    },
    {%- endfor %}
]

CONTEXT_URLS = [
{%- for url in context.urls %}
    "{{ url }}",
{%- endfor %}
]


# ENUMERATIONS
{%- for enum in enums %}
{%- if enum.comment %}
{%- for l in enum.comment.split("\n") %}
#{% if l %} {% endif %}{{ l.rstrip() }}
{%- endfor %}
{%- endif %}
class {{ varname(enum.clsname) }}(EnumProp):
    TYPE = "{{ enum._id }}"
    valid_values = [
        {%- for value in enum.values %}
        ("{{ varname(value.varname) }}", "{{ value._id }}"),
        {%- endfor %}
    ]
    {%- for value in enum.values %}
    {%- if value.comment %}
    {%- for l in value.comment.split("\n") %}
    #{% if l %} {% endif %}{{ l.rstrip() }}
    {%- endfor %}
    {%- endif %}
    {{ varname(value.varname) }} = "{{ value._id }}"
    {%- endfor %}

{% endfor %}
# CLASSES
{%- for class in classes %}
{%- if class.comment %}
{%- for l in class.comment.split("\n") %}
#{% if l %} {% endif %}{{ l.rstrip() }}
{%- endfor %}
{%- endif %}
class {{ varname(class.clsname) }}(
{%- if class.parent_ids %}
    {%- for id in class.parent_ids %}
        {{- varname(classes.get(id).clsname) }}{% if not loop.last %}, {% endif %}
    {%- endfor %}
{%- else -%}
    SHACLObject
{%- endif -%}):
    TYPE = "{{ class._id }}"
    REFABLE = Refable.{{ class.refable }}
    {%- if class.id_property %}
    ID_ALIAS = "{{ class.id_property }}"
    {%- endif %}

    def __init__(self, **kwargs):
        super().__init__()
        {%- if class.id_property %}
        {%- endif %}
        {%- for prop in class.properties %}
        {%- set is_list = prop.max_count is none or prop.max_count != 1 %}
        {%- if prop.comment %}
        {%- for l in prop.comment.split("\n") %}
        #{% if l %} {% endif %}{{ l.rstrip() }}
        {%- endfor %}
        {%- endif %}
        self._add_property(
            "{{ varname(prop.varname) }}",
            {% if is_list -%}ListProp({% endif %}
            {%- if prop.class_id -%}
                ObjectProp({{ varname(classes.get(prop.class_id).clsname) }}, {% if prop.min_count and not is_list %}True{% else %}False{% endif %})
            {%- elif prop.enum_id -%}
                {{ varname(enums.get(prop.enum_id).clsname) }}()
            {%- else -%}
                {% if not prop.datatype in DATATYPE_CLASSES -%}
                    {{ abort("Unknown data type " + prop.datatype) -}}
                {% endif -%}
                {{ DATATYPE_CLASSES[prop.datatype] }}({%- if prop.pattern %}pattern=r"{{ prop.pattern }}",{%- endif %})
            {%- endif %}{% if is_list %}){% endif %},
            iri="{{ prop.path }}",
            {%- if is_list and not prop.max_count is none %}
            max_count={{ prop.max_count }},
            {%- endif %}
            {%- if not prop.min_count is none %}
            min_count={{ prop.min_count }},
            {%- endif %}
        )
        {%- endfor %}
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["{{ class._id }}"] = {{ varname(class.clsname) }}

{% endfor %}
{% include "context.py" %}


{{ '"' }}{{ '"' }}{{ '"' }}Format Guard"""
# fmt: on


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    with args.infile.open("r") as f:
        d = JSONLDDeserializer()
        objects, _ = d.read(f)

    if args.print:
        print_tree(objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            s = JSONLDSerializer()
            s.write(objects, f)

    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
