#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# {{ disclaimer }}
#
# SPDX-License-Identifier: {{ spdx_license }}

from __future__ import annotations

import decimal
import functools
import hashlib
import json
import re
import sys
import threading
import time
import warnings
from abc import ABC, abstractmethod
from collections.abc import Collection
from contextlib import contextmanager
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import (
    Any,
    Callable,
    Collection,
    Dict,
    Generic,
    Iterable,
    Iterator,
    List,
    Optional,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
    overload,
)
from dataclasses import dataclass

# Allow Property subclasses to define their own value types,
# reduce the use of Any in the type hints.
T_PropValue = TypeVar("T_PropValue")


def check_type(obj: Any, types: Union[Type[Any], Tuple[Type[Any], ...]]) -> None:
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj).__name__}"
            )
        raise TypeError(
            f"Value must be of type {types.__name__}. Got {type(obj).__name__}"
        )


class Property(ABC, Generic[T_PropValue]):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    VALID_TYPES: Union[Type[Any], Tuple[Type[Any], ...]] = ()

    __slots__ = ("pattern",)

    def __init__(self, *, pattern: Optional[str] = None) -> None:
        self.pattern = pattern

    def init(self) -> Any:
        return None

    def validate(self, value: T_PropValue) -> None:
        check_type(value, self.VALID_TYPES)
        if self.pattern is not None and not re.search(
            self.pattern, self.to_string(value)
        ):
            raise ValueError(
                f"Value is not correctly formatted. Got '{self.to_string(value)}'"
            )

    def set(self, value: Any) -> T_PropValue:
        return cast(T_PropValue, value)

    def check_min_count(self, value: T_PropValue, min_count: int) -> bool:
        return min_count == 1

    def check_max_count(self, value: T_PropValue, max_count: int) -> bool:
        return max_count == 1

    def elide(self, value: T_PropValue) -> bool:
        return value is None

    def walk(
        self,
        value: T_PropValue,
        callback: Callable[[Any, List[str]], bool],
        path: List[str],
    ) -> None:
        callback(value, path)

    def iter_objects(
        self, value: T_PropValue, recursive: bool, visited: Set[SHACLObject]
    ) -> Iterable[Any]:
        return []

    def link_prop(
        self,
        value: T_PropValue,
        objectset: SHACLObjectSet,
        missing: Optional[Set[str]],
        visited: Set[SHACLObject],
    ) -> Any:
        return value

    def to_string(self, value: T_PropValue) -> str:
        return str(value)

    @abstractmethod
    def encode(self, encoder: Encoder, value: T_PropValue, state: EncodeState) -> None:
        raise NotImplementedError("Subclasses must implement encode method")

    @abstractmethod
    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[T_PropValue]:
        raise NotImplementedError("Subclasses must implement decode method")


class StringProp(Property[str]):
    """
    A scalar string property for an SHACL object
    """

    VALID_TYPES = str

    def set(self, value: Any) -> str:
        return str(value)

    def encode(self, encoder: Encoder, value: str, state: EncodeState) -> None:
        encoder.write_string(value)

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[str]:
        return decoder.read_string()


class AnyURIProp(StringProp):
    def encode(self, encoder: Encoder, value: str, state: EncodeState) -> None:
        encoder.write_iri(value)

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[str]:
        return decoder.read_iri()


class DateTimeProp(Property[datetime]):
    """
    A Date/Time Object with optional timezone
    """

    VALID_TYPES = datetime
    UTC_FORMAT_STR = "%Y-%m-%dT%H:%M:%SZ"
    REGEX = r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})?$"

    __slots__ = ()

    def set(self, value: Any) -> datetime:
        return self._normalize(value)

    def encode(self, encoder: Encoder, value: datetime, state: EncodeState) -> None:
        encoder.write_datetime(self.to_string(value))

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[datetime]:
        s = decoder.read_datetime()
        if s is None:
            return None
        if isinstance(s, datetime):
            return self._normalize(s)
        v = self.from_string(s)
        return self._normalize(v)

    def _normalize(self, value: datetime) -> datetime:
        if value.utcoffset() is None:
            value = value.astimezone()

        # Remove seconds from timezone offset
        offset = value.utcoffset()
        if offset is not None:
            seconds = offset % timedelta(
                minutes=-1 if offset.total_seconds() < 0 else 1
            )
            if seconds:
                offset = offset - seconds
                value = value.replace(tzinfo=timezone(offset))

        # Convert 00:00 timezone offset to UTC
        offset = value.utcoffset()
        if offset is not None and offset.seconds == 0:
            value = value.astimezone(timezone.utc)

        value = value.replace(microsecond=0)
        return value

    def to_string(self, value: datetime) -> str:
        value = self._normalize(value)
        if value.tzinfo == timezone.utc:
            return value.strftime(self.UTC_FORMAT_STR)
        return value.isoformat()

    def from_string(self, value: str) -> datetime:
        if not re.match(self.REGEX, value):
            raise ValueError(f"'{value}' is not a correctly formatted datetime")
        if "Z" in value:
            d = datetime(
                *(time.strptime(value, self.UTC_FORMAT_STR)[0:6]),
                tzinfo=timezone.utc,
            )
        else:
            d = datetime.fromisoformat(value)

        return self._normalize(d)


class DateTimeStampProp(DateTimeProp):
    """
    A Date/Time Object with required timestamp
    """

    REGEX = r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$"

    __slots__ = ()


class IntegerProp(Property[int]):
    VALID_TYPES = int

    __slots__ = ()

    def set(self, value: Any) -> int:
        return int(value)

    def encode(self, encoder: Encoder, value: int, state: EncodeState) -> None:
        encoder.write_integer(value)

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[int]:
        return decoder.read_integer()


class PositiveIntegerProp(IntegerProp):
    __slots__ = ()

    def validate(self, value: int) -> None:
        super().validate(value)
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    __slots__ = ()

    def validate(self, value: int) -> None:
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property[bool]):
    VALID_TYPES = bool

    __slots__ = ()

    def set(self, value: Any) -> bool:
        return bool(value)

    def encode(self, encoder: Encoder, value: bool, state: EncodeState) -> None:
        encoder.write_bool(value)

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[bool]:
        return decoder.read_bool()


class FloatProp(Property[float]):
    VALID_TYPES = (float, int)

    __slots__ = ()

    def set(self, value: Any) -> float:
        return float(value)

    def encode(self, encoder: Encoder, value: float, state: EncodeState) -> None:
        encoder.write_float(value)

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[float]:
        return decoder.read_float()


class IRIProp(Property[T_PropValue]):
    __slots__ = ("context",)

    def __init__(
        self,
        context: Optional[Tuple[Tuple[str, str], ...]] = None,
        *,
        pattern: Optional[str] = None,
    ):
        if context is None:
            context = ()
        super().__init__(pattern=pattern)
        self.context = context

    def compact(self, value: str, dflt: Any = None) -> Optional[str]:
        for iri, compact in self.context:
            if value == iri:
                return compact
        return cast(Optional[str], dflt)

    def expand(self, value: str, dflt: Any = None) -> Optional[str]:
        for iri, compact in self.context:
            if value == compact:
                return iri
        return cast(Optional[str], dflt)

    def iri_values(self) -> Iterator[str]:
        return (iri for iri, _ in self.context)

    def encode(self, encoder: Encoder, value: T_PropValue, state: EncodeState) -> None:
        encoder.write_iri(str(value))

    def decode(self, decoder: Decoder, state: DecodeState) -> Optional[T_PropValue]:
        return cast(Optional[T_PropValue], decoder.read_iri())


class ObjectProp(IRIProp[Union[str, "SHACLObject"]]):
    """
    A scalar SHACL object property of a SHACL object
    """

    __slots__ = ("cls", "required")

    def __init__(
        self,
        cls: Type[SHACLObject],
        required: bool,
        context: Optional[Tuple[Tuple[str, str], ...]] = None,
    ):
        super().__init__(context)
        self.cls = cls
        self.required = required

    def validate(self, value: Any) -> None:
        check_type(value, (self.cls, str))

    def set(self, value: Any) -> Union[str, "SHACLObject"]:
        if isinstance(value, SHACLObject):
            return value
        return str(value)

    def walk(
        self, value: Any, callback: Callable[[Any, List[str]], bool], path: List[str]
    ) -> None:
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def iter_objects(
        self, value: Any, recursive: bool, visited: Set["SHACLObject"]
    ) -> Iterable["SHACLObject"]:
        if value is None or isinstance(value, str):
            return

        if value not in visited:
            visited.add(value)
            yield value

            if recursive:
                for c in value.iter_objects(recursive=True, visited=visited):
                    yield c

    def encode(
        self, encoder: Encoder, value: Union[str, SHACLObject], state: EncodeState
    ) -> None:
        if value is None:
            raise ValueError("Object cannot be None")

        if isinstance(value, str):
            encoder.write_iri(value, self.compact(value) or state.compact_iri(value))
            return

        return value.encode(encoder, state)

    def decode(self, decoder: Decoder, state: DecodeState) -> Any:
        if decoder.is_object():
            return self.cls.decode(decoder, state)

        iri = decoder.read_iri()
        if iri is None:
            raise ValueError("IRI cannot be None")

        iri = self.expand(iri) or state.expand_iri(iri) or iri

        if state.objectset is None:
            return iri

        obj = state.objectset.find_by_id(iri)
        if obj is None:
            return iri

        self.validate(obj)
        return obj

    def link_prop(
        self,
        value: Any,
        objectset: SHACLObjectSet,
        missing: Optional[Set[str]],
        visited: Set[SHACLObject],
    ) -> Any:
        if value is None:
            return value

        if isinstance(value, str):
            o = objectset.find_by_id(value)
            if o is not None:
                self.validate(o)
                return o

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id:
            value = objectset.find_by_id(value._id, value)
            self.validate(value)

        value.link_helper(objectset, missing, visited)
        return value


class ListProxy(Generic[T_PropValue]):
    __slots__ = ("_data", "_prop")

    def __init__(
        self, prop: Property[T_PropValue], data: Optional[List[T_PropValue]] = None
    ) -> None:
        if data is None:
            self.__data: List[T_PropValue] = []
        else:
            self._data = data
        self._prop = prop

    def append(self, value: T_PropValue) -> None:
        self._prop.validate(value)
        self._data.append(self._prop.set(value))

    def insert(self, idx: int, value: T_PropValue) -> None:
        self._prop.validate(value)
        self._data.insert(idx, self._prop.set(value))

    def extend(self, items: Iterable[T_PropValue]) -> None:
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs) -> None:
        self._data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self._data[key]

    @overload
    def __setitem__(self, key: int, value: T_PropValue) -> None: ...

    @overload
    def __setitem__(self, key: slice, value: Iterable[T_PropValue]) -> None: ...

    def __setitem__(
        self, key: Union[int, slice], value: Union[T_PropValue, Iterable[T_PropValue]]
    ) -> None:
        if isinstance(key, slice):
            for v in value:
                self._prop.validate(v)
            self._data[key] = [self._prop.set(v) for v in value]
        elif isinstance(key, int):
            self._prop.validate(value)
            self._data[key] = self._prop.set(value)
        else:
            raise TypeError(
                f"ListProxy indices must be integers or slices. Got {type(key).__name__}"
            )

    def __delitem__(self, key) -> None:
        del self._data[key]

    def __contains__(self, item):
        return item in self._data

    def __iter__(self):
        return iter(self._data)

    def __len__(self) -> int:
        return len(self._data)

    def __str__(self) -> str:
        return str(self._data)

    def __repr__(self):
        return repr(self._data)

    def __eq__(self, other: Any) -> bool:
        if isinstance(other, ListProxy):
            return self._data == other._data

        return self._data == other

        return self.__data == [other]


class ListProp(Property[ListProxy[T_PropValue]]):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    __slots__ = ("prop",)

    def __init__(self, prop: Property[T_PropValue]) -> None:
        super().__init__()
        self.prop = prop

    def init(self) -> ListProxy[T_PropValue]:
        return ListProxy(self.prop)

    def validate(self, value: Any) -> None:
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(
        self, value: Union[ListProxy[T_PropValue], Iterable[T_PropValue]]
    ) -> ListProxy[T_PropValue]:
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, [self.prop.set(d) for d in value])

    def check_min_count(self, value: ListProxy[T_PropValue], min_count: int) -> bool:
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value: ListProxy[T_PropValue], max_count: int) -> bool:
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value: ListProxy[T_PropValue]) -> bool:
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(
        self,
        value: ListProxy[T_PropValue],
        callback: Callable[[Any, List[str]], bool],
        path: List[str],
    ) -> None:
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def iter_objects(
        self, value: ListProxy[T_PropValue], recursive: bool, visited: Set[SHACLObject]
    ) -> Iterable[Any]:
        for v in value:
            for c in self.prop.iter_objects(v, recursive, visited):
                yield c

    def link_prop(
        self,
        value: ListProxy[T_PropValue],
        objectset: SHACLObjectSet,
        missing: Optional[Set[str]],
        visited: Set[SHACLObject],
    ) -> ListProxy[T_PropValue]:
        if isinstance(value, ListProxy):
            data = [self.prop.link_prop(v, objectset, missing, visited) for v in value]
        else:
            data = [self.prop.link_prop(v, objectset, missing, visited) for v in value]

        return ListProxy(self.prop, data=data)

    def encode(
        self, encoder: Encoder, value: ListProxy[T_PropValue], state: EncodeState
    ) -> None:
        check_type(value, ListProxy)

        with encoder.write_list() as list_s:
            for v in value:
                with list_s.write_list_item() as item_s:
                    self.prop.encode(item_s, v, state)

    def decode(self, decoder: Decoder, state: DecodeState) -> ListProxy[T_PropValue]:
        data = []
        for val_d in decoder.read_list():
            v = self.prop.decode(val_d, state)
            if v is not None:
                self.prop.validate(v)
                data.append(v)

        return ListProxy(self.prop, data=data)


class EnumProp(IRIProp[str]):
    VALID_TYPES = str

    __slots__ = ()

    def __init__(self, values, *, pattern: Optional[str] = None):
        super().__init__(values, pattern=pattern)

    def validate(self, value: str) -> None:
        super().validate(value)

        if value not in self.iri_values():
            raise ValueError(
                f"'{value}' is not a valid value. Choose one of {' '.join(self.iri_values())}"
            )

    def encode(self, encoder: Encoder, value: str, state: EncodeState) -> None:
        encoder.write_enum(value, self, self.compact(value))

    def decode(self, decoder: Decoder, state: DecodeState) -> str:
        v = decoder.read_enum(self)
        return cast(str, self.expand(v or "") or v)


class NodeKind(Enum):
    BlankNode = 1
    IRI = 2
    BlankNodeOrIRI = 3


def is_IRI(s: Any) -> bool:
    if not isinstance(s, str):
        return False
    if s.startswith("_:"):
        return False
    if ":" not in s:
        return False
    return True


def is_blank_node(s: Any) -> bool:
    if not isinstance(s, str):
        return False
    if not s.startswith("_:"):
        return False
    return True


@dataclass()  # After Python 3.10, use slots=True to save a little space
class ClassProp:
    pyname: str
    reg: Callable
    iri: str
    min_count: Optional[int] = None
    max_count: Optional[int] = None
    compact: Optional[str] = None
    deprecated: bool = False
    # For efficiency reasons this should be of type Property (only) but
    # initialized to None
    prop: Property = None  # type: ignore


# fmt: off
"""Format Guard{{ '"' }}{{ '"' }}{{ '"' }}
_USE_SLOTS = {{ use_slots }}
{{ '"' }}{{ '"' }}{{ '"' }}Format Guard"""
# fmt: on


class SHACLObjectMeta(type):
    def __new__(cls, name, bases, attrs):
        def check_base_prop(name):
            return any(hasattr(b, name) or name in b._EXTRA_SLOTS for b in bases)

        is_base = name == "SHACLObject"

        attrs.setdefault("IS_ABSTRACT", False)
        attrs.setdefault("IS_DEPRECATED", False)
        attrs.setdefault("NAMED_INDIVIDUALS", {})
        attrs.setdefault("NODE_KIND", NodeKind.BlankNodeOrIRI)
        attrs.setdefault("_EXTRA_SLOTS", set())
        attrs["_EXTRA_SLOTS"] = set(attrs["_EXTRA_SLOTS"])

        py_properties = {}
        iri_properties = {}
        compact_properties = {}
        for p in attrs.get("PROPERTIES", []):
            if not is_base:
                for b in bases:
                    if p.pyname in b._OBJ_PY_PROPS or p.pyname in b._EXTRA_SLOTS:
                        raise KeyError(
                            f"'{p.pyname}' is already defined for '{b.__name__}'"
                        )
                    if p.iri in b._OBJ_IRI_PROPS:
                        raise KeyError(
                            f"'{p.iri}' is already defined for '{b.__name__}'"
                        )
                    if p.compact and p.compact in b._OBJ_COMPACT_PROPS:
                        raise KeyError(
                            f"'{p.compact}' is already defined for '{b.__name__}'"
                        )

            if p.pyname in py_properties:
                raise KeyError(f"'{p.pyname}' is already defined for '{name}'")

            if p.iri in iri_properties:
                raise KeyError(f"'{p.iri}' is already defined for '{name}'")

            if p.compact and p.compact in compact_properties:
                raise KeyError(f"'{p.compact}' is already defined for '{name}'")

            while (
                p.pyname in attrs
                or p.pyname in attrs["_EXTRA_SLOTS"]
                or check_base_prop(p.pyname)
            ):
                p.pyname = p.pyname + "_"

            if not isinstance(p.reg, Callable):
                raise ValueError(
                    f"Registration of {name}.{p.pyname} must be a callable to allow deferred class typing. Try: `lambda: ...`"
                )

            py_properties[p.pyname] = p
            iri_properties[p.iri] = p

            if p.compact:
                p.compact = p.compact
                compact_properties[p.compact] = p

        if _USE_SLOTS:
            # Assign slots. Note that __slots__ automatically inherits from the
            # parent, so there is no need to merge in from the parent
            attrs["__slots__"] = tuple(
                sorted(
                    set(py_properties.keys())
                    | attrs["_EXTRA_SLOTS"]
                    | set(attrs.get("__slots__", ()))
                )
            )

        # Merge in the parent slots so that __setattr__ works properly
        for b in bases:
            attrs["_EXTRA_SLOTS"] |= b._EXTRA_SLOTS

        if "PROPERTIES" in attrs:
            del attrs["PROPERTIES"]

        attrs["_OBJ_PY_PROPS"] = py_properties
        attrs["_OBJ_IRI_PROPS"] = iri_properties
        attrs["_OBJ_COMPACT_PROPS"] = compact_properties
        if not is_base:
            for b in bases:
                for k, v in b._OBJ_PY_PROPS.items():
                    attrs["_OBJ_PY_PROPS"][k] = v

                for k, v in b._OBJ_IRI_PROPS.items():
                    attrs["_OBJ_IRI_PROPS"][k] = v

                for k, v in b._OBJ_COMPACT_PROPS.items():
                    attrs["_OBJ_COMPACT_PROPS"][k] = v

        attrs["_IRI"] = {p.pyname: p.iri for p in attrs["_OBJ_PY_PROPS"].values()}

        global NAMED_INDIVIDUALS

        auto_ni = True
        if "AUTO_NAMED_INDIVIDUALS" in attrs:
            auto_ni = attrs["AUTO_NAMED_INDIVIDUALS"]
            del attrs["AUTO_NAMED_INDIVIDUALS"]

        for k, v in attrs["NAMED_INDIVIDUALS"].items():
            if auto_ni:
                if (
                    k in attrs
                    or k in attrs["_EXTRA_SLOTS"]
                    or check_base_prop(k)
                    or k in py_properties
                ):
                    raise KeyError(
                        f"Named Individual with name '{k}' conflicts with existing property"
                    )
                attrs[k] = v

            NAMED_INDIVIDUALS.add(v)

        attrs["_NEEDS_REG"] = True

        attrs["_TYPE"] = attrs.pop("TYPE", None)

        attrs["_COMPACT_TYPE"] = attrs.pop("COMPACT_TYPE", None)

        return super().__new__(cls, name, bases, attrs)

    @staticmethod
    def _add_class(key: str, c: Type[SHACLObject]) -> None:
        assert (
            key not in SHACLObject.CLASSES
        ), f"{key} already registered to {SHACLObject.CLASSES[key].__name__}"
        SHACLObject.CLASSES[key] = c


register_lock = threading.Lock()
NAMED_INDIVIDUALS: Set[str] = set()
T_SHACLObject = TypeVar("T_SHACLObject", bound="SHACLObject")


@functools.total_ordering
class SHACLObject(metaclass=SHACLObjectMeta):
    CLASSES: Dict[str, Type] = {}

    # Class properties that can be set in derived classes:

    # A dictionary of Named Individuals. The key is the python name of the
    # individual and the value is the IRI of the individual (not inherited)
    NAMED_INDIVIDUALS: Dict[str, str] = {}

    # If True, class member variables will be automatically created for the class
    # from the NAMED_INDIVIDUALS dictionary
    # NOTE: This variable is not present in the class
    AUTO_NAMED_INDIVIDUALS: bool = True

    # The type of ID the object is allowed to have (inherited from parent)
    NODE_KIND = NodeKind.BlankNodeOrIRI

    # An alternate IRI for the ID property, besides "@id" (inherited from
    # parent)
    ID_ALIAS: Optional[str] = None

    # If True, this class is abstract and cannot be implemented (not inherited
    # from parent)
    IS_ABSTRACT: bool = True

    # If True, this class is deprecated and will raise a warning when created
    # (not inherited from parent)
    IS_DEPRECATED: bool = False

    # The fully qualified Type IRI for the object. Required
    # NOTE: This variable is not present in the class. Use get_type() instead
    TYPE: str = ""

    # The compacted Type IRI of the object. Must match how the TYPE property
    # would be compacted by the context. Not inherited from parent
    # NOTE: This variable is not present in the class. Use get_compact_type()
    # instead
    COMPACT_TYPE: Optional[str] = None

    # A list of properties for this object. Each entry must be a ClassProp
    # object. Properties are automatically inherited from parent classes and do
    # not need to be re-listed here.
    # NOTE: The variable is not present in the class
    PROPERTIES = [
        ClassProp("_id", lambda: StringProp(), "@id"),
    ]

    # Internal variables
    _EXTRA_SLOTS: Union[Set[str], Tuple[str, ...]] = (
        "_extensible",
        "_metadata",
        "_birth_index",
    )
    _OBJ_PY_PROPS: Dict[str, ClassProp] = {}
    _OBJ_IRI_PROPS: Dict[str, ClassProp] = {}
    _OBJ_COMPACT_PROPS: Dict[str, ClassProp] = {}
    _NEEDS_REG: bool = True
    _next_birth_index: int = 0
    _TYPE: str
    _COMPACT_TYPE: Optional[str]
    _extensible: Dict[str, Any]

    # Instance variables
    _id: Optional[str]
    _metadata: Dict[str, Any]

    def __init_subclass__(cls, **kwargs):
        def add_class(key: str, c: Type[SHACLObject]) -> None:
            assert (
                key not in SHACLObject.CLASSES
            ), f"{key} already registered to {SHACLObject.CLASSES[key].__name__}"
            SHACLObject.CLASSES[key] = c

        super().__init_subclass__(**kwargs)
        if cls._TYPE:
            add_class(cls._TYPE, cls)

        if cls._COMPACT_TYPE:
            add_class(cls._COMPACT_TYPE, cls)

    def __init__(self, **kwargs: Any) -> None:
        if self._is_abstract():
            raise NotImplementedError(
                f"{self.__class__.__name__} is abstract and cannot be implemented"
            )

        if self.__class__.IS_DEPRECATED:
            warnings.warn(
                f"{self.__class__.__name__} is deprecated", DeprecationWarning
            )

        with register_lock:
            cls = self.__class__
            if cls._NEEDS_REG:
                for p in cls._OBJ_PY_PROPS.values():
                    # Note that since classes share their ClassProp objects
                    # with their parents, the property might have already been
                    # initialized.
                    if p.prop is None and p.reg is not None:
                        p.prop = p.reg()
                        p.reg = None
                cls._NEEDS_REG = False

        self._metadata = {}
        self._birth_index = SHACLObject._next_birth_index
        SHACLObject._next_birth_index += 1

        for p in self._OBJ_PY_PROPS.values():
            object.__setattr__(self, p.pyname, p.prop.init())

        for k, v in kwargs.items():
            setattr(self, k, v)

    def get_type(self) -> str:
        return self._TYPE

    def get_compact_type(self) -> Optional[str]:
        return self._COMPACT_TYPE

    def _is_abstract(self) -> bool:
        return self.__class__.IS_ABSTRACT

    def __set(self, p: ClassProp, value):
        if p.iri == "@id":
            if self.NODE_KIND == NodeKind.BlankNode:
                if not is_blank_node(value):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can only have local reference. Property '{p.iri}' cannot be set to {value!r} and must start with '_:'"
                    )
            elif self.NODE_KIND == NodeKind.IRI:
                if not is_IRI(value):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can only have an IRI value. Property '{p.iri}' cannot be set to {value!r}"
                    )
            else:
                if not is_blank_node(value) and not is_IRI(value):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) Has invalid Property '{p.iri}' {value!r}. Must be a blank node or IRI"
                    )

        p.prop.validate(value)
        if p.deprecated:
            warnings.warn(
                f"{self.__class__.__name__}.{p.pyname} is deprecated",
                DeprecationWarning,
            )
        object.__setattr__(self, p.pyname, p.prop.set(value))

    def __del(self, p: ClassProp):
        object.__setattr__(self, p.pyname, p.prop.init())

    def __get_attr(self, name):
        if name == self.ID_ALIAS:
            name = "_id"

        try:
            return self._OBJ_PY_PROPS[name]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __setattr__(self, name: str, value) -> None:
        if name in self._EXTRA_SLOTS:
            object.__setattr__(self, name, value)
            return

        self.__set(self.__get_attr(name), value)

    def __getattr__(self, name: str):
        if name == self.ID_ALIAS:
            return self._id

        raise AttributeError(
            f"'{name}' is not a valid property of {self.__class__.__name__}"
        )

    def __dir__(self) -> Iterable[str]:
        keys: Set[str] = set(super().__dir__())
        keys.update(self._OBJ_IRIS.keys())
        return sorted(list(keys))

    def __delattr__(self, name: str) -> None:
        if name in self._EXTRA_SLOTS:
            object.__delattr__(self, name)
            return

        self.__del(self.__get_attr(name))

    def __get_key(self, iri: str):
        return self._OBJ_IRI_PROPS[iri]

    def __getitem__(self, iri: str) -> Any:
        return getattr(self, self.__get_key(iri).pyname)

    def __setitem__(self, iri: str, value) -> None:
        self.__set(self.__get_key(iri), value)

    def __delitem__(self, iri: str) -> None:
        self.__del(self.__get_key(iri))

    def __iter__(self) -> Iterator[str]:
        return iter(self._OBJ_IRI_PROPS.keys())

    def walk(
        self,
        callback: Callable[[Any, List[str]], bool],
        path: Optional[List[str]] = None,
    ) -> None:
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(value: Any, path: List[str]) -> bool:
            ...

        Return False from the callback to prevent walking into the children
        of the current item.
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for p in self._OBJ_PY_PROPS.values():
                p.prop.walk(getattr(self, p.pyname), callback, path + [f".{p.iri}"])

    def property_keys(self) -> Iterator[Tuple[Optional[str], str, Optional[str]]]:
        for p in self._OBJ_PY_PROPS.values():
            if p.iri == "@id":
                compact = self.ID_ALIAS
            else:
                compact = p.compact
            yield p.pyname, p.iri, compact

    def iter_objects(
        self, *, recursive: bool = False, visited: Optional[Set["SHACLObject"]] = None
    ) -> Iterable[Any]:
        """
        Iterate over all objects that are a child of this one
        """
        if visited is None:
            visited = set()

        for p in self._OBJ_PY_PROPS.values():
            for c in p.prop.iter_objects(
                getattr(self, p.pyname), recursive=recursive, visited=visited
            ):
                yield c

    def encode(self, encoder, Encoder, state: EncodeState) -> None:
        idname = self.ID_ALIAS or "@id"
        if not self._id and self.NODE_KIND == NodeKind.IRI:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must have a IRI for property '{idname}'"
            )

        _id = state.get_object_id(self)

        if state.is_written(self):
            encoder.write_iri(_id, state.compact_iri(_id))
            return

        state.add_written(self)

        with encoder.write_object(
            self.get_type(),
            self.get_compact_type() or state.compact_iri(self.get_type()),
            self.ID_ALIAS,
            _id,
            state.compact_iri(_id),
            bool(self._id) or state.is_refed(self),
        ) as obj_s:
            self._encode_properties(obj_s, state)

    def _encode_properties(self, encoder: Encoder, state: EncodeState) -> None:
        for p in self._OBJ_PY_PROPS.values():
            value = getattr(self, p.pyname)
            if p.prop.elide(value):
                if p.min_count:
                    raise ValueError(
                        f"Property '{p.pyname}' in {self.__class__.__name__} ({id(self)}) is required (currently {value!r})"
                    )
                continue

            if p.min_count is not None:
                if not p.prop.check_min_count(value, p.min_count):
                    raise ValueError(
                        f"Property '{p.pyname}' in {self.__class__.__name__} ({id(self)}) requires a minimum of {p.min_count} elements"
                    )

            if p.max_count is not None:
                if not p.prop.check_max_count(value, p.max_count):
                    raise ValueError(
                        f"Property '{p.pyname}' in {self.__class__.__name__} ({id(self)}) requires a maximum of {p.max_count} elements"
                    )

            if p.iri == "@id":
                continue

            with encoder.write_property(
                p.iri, p.compact or state.compact_iri(p.iri)
            ) as prop_s:
                p.prop.encode(prop_s, value, state)

    @classmethod
    def _make_object(cls: Type["SHACLObject"], typ: str) -> "SHACLObject":
        if typ not in cls.CLASSES:
            raise TypeError(f"Unknown type {typ}")

        return cast("SHACLObject", cls.CLASSES[typ]())

    @classmethod
    def decode(
        cls: Type[T_SHACLObject], decoder: Decoder, state: DecodeState
    ) -> SHACLObject:
        typ, obj_d = decoder.read_object()
        if typ is None:
            raise TypeError("Unable to determine type for object")
        typ = state.objectset.expand_iri(typ) or typ

        obj = cls._make_object(typ)
        _id = obj_d.read_object_id(obj.ID_ALIAS)
        if _id is not None:
            obj._id = state.expand_iri(_id) or _id

        if obj.NODE_KIND == NodeKind.IRI and not obj._id:
            raise ValueError("Object is missing required IRI")

        if obj._id:
            if obj._id in state.read_objs:
                return state.read_objs[obj._id]
            state.read_objs[obj._id] = obj

        obj._decode_properties(obj_d, state)

        if state.objectset is not None:
            state.objectset.add_index(obj)

        return obj

    def _decode_properties(self, decoder: Decoder, state: DecodeState) -> None:
        for key in decoder.object_keys():
            if not self._decode_prop(decoder, key, state):
                raise KeyError(f"Unknown property '{key}'")

    def _decode_prop(self, decoder: Decoder, key: str, state: DecodeState) -> bool:
        if key in ("@id", self.ID_ALIAS):
            return True

        expanded_key = state.expand_iri(key)
        if expanded_key and expanded_key in self._OBJ_IRI_PROPS:
            p = self._OBJ_IRI_PROPS[expanded_key]
        elif key in self._OBJ_IRI_PROPS:
            p = self._OBJ_IRI_PROPS[key]
        elif key in self._OBJ_COMPACT_PROPS:
            p = self._OBJ_COMPACT_PROPS[key]
        else:
            return False

        with decoder.read_property(key) as prop_d:
            v = p.prop.decode(prop_d, state)
            self.__set(p, v)
        return True

    def link_helper(
        self,
        objectset: SHACLObjectSet,
        missing: Optional[Set[str]],
        visited: Set[SHACLObject],
    ) -> None:
        if self in visited:
            return

        visited.add(self)

        for p in self._OBJ_PY_PROPS.values():
            object.__setattr__(
                self,
                p.pyname,
                p.prop.link_prop(
                    getattr(self, p.pyname),
                    objectset,
                    missing,
                    visited,
                ),
            )

    def __str__(self) -> str:
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self) -> int:
        return super().__hash__()

    def __eq__(self, other: Any) -> bool:
        return super().__eq__(other)

    def __lt__(self, other: Any) -> bool:
        def sort_key(obj: Any) -> Any:
            if isinstance(obj, str):
                return (obj, "", "", "")
            return (
                obj._id or "",
                obj.get_type(),
                getattr(obj, "name", None) or "",
                self._birth_index,
            )

        return bool(sort_key(self) < sort_key(other))


class SHACLExtensibleObject(SHACLObject):
    CLOSED = False

    def __init__(self, typ=None, **kwargs):
        self._extensible = {
            "type": typ if typ else self._TYPE,
            "compact_type": None if typ else self._COMPACT_TYPE,
            "data": {},
        }

        super().__init__(**kwargs)

    def get_type(self) -> str:
        return self._extensible["type"]

    def get_compact_type(self) -> Optional[str]:
        return self._extensible["compact_type"]

    def _is_abstract(self) -> bool:
        # Unknown classes are assumed to not be abstract so that they can be
        # deserialized
        typ = self.get_type()
        if typ in SHACLObject.CLASSES:
            return SHACLObject.CLASSES[typ].IS_ABSTRACT

        return False

    @property
    def _ext_data(self) -> Dict[str, str]:
        return self._extensible["data"]

    @classmethod
    def _make_object(cls: Type["SHACLExtensibleObject"], typ: str) -> "SHACLObject":
        # Check for a known type, and if so, deserialize as that instead
        if typ in cls.CLASSES:
            return cast("SHACLObject", cls.CLASSES[typ]())

        obj = cls(typ)
        return obj

    def _decode_properties(self, decoder: Decoder, state: DecodeState) -> None:
        def decode_value(d: Decoder) -> Any:
            if not d.is_list():
                return d.read_value()

            return [decode_value(val_d) for val_d in d.read_list()]

        if self.CLOSED:
            super()._decode_properties(decoder, state)
            return

        for key in decoder.object_keys():
            if self._decode_prop(decoder, key, state):
                continue

            expanded_key = state.expand_iri(key) or key

            if not is_IRI(expanded_key):
                raise KeyError(
                    f"Extensible object properties must be IRIs. Got '{key}' (expanded to '{expanded_key}')"
                )

            with decoder.read_property(key) as prop_d:
                self._ext_data[expanded_key] = decode_value(prop_d)

    def _encode_properties(self, encoder: Encoder, state: EncodeState) -> None:
        super()._encode_properties(encoder, state)
        if self.CLOSED:
            return

        for iri, value in self._ext_data.items():
            if iri in self._OBJ_IRI_PROPS:
                continue

            with encoder.write_property(iri, state.compact_iri(iri)) as prop_s:
                if isinstance(value, list):
                    v = value
                else:
                    v = [value]
                with prop_s.write_list() as list_s:
                    for i in v:
                        with list_s.write_list_item() as item_s:
                            if isinstance(i, bool):
                                item_s.write_bool(i)
                            elif isinstance(i, str):
                                item_s.write_string(i)
                            elif isinstance(i, int):
                                item_s.write_integer(i)
                            elif isinstance(i, float):
                                item_s.write_float(i)
                            else:
                                raise TypeError(
                                    f"Unsupported serialized type {type(i)} with value {i!r}"
                                )

    def __getitem__(self, iri: str):
        try:
            return super().__getitem__(iri)
        except KeyError:
            if self.CLOSED:
                raise

        if not is_IRI(iri):
            raise KeyError(f"Key '{iri}' must be an IRI")
        return self._ext_data[iri]

    def __setitem__(self, iri: str, value) -> None:
        try:
            super().__setitem__(iri, value)
        except KeyError:
            if self.CLOSED:
                raise

        if not is_IRI(iri):
            raise KeyError(f"Key '{iri}' must be an IRI")
        self._ext_data[iri] = value

    def __delitem__(self, iri: str) -> None:
        try:
            super().__delitem__(iri)
        except KeyError:
            if self.CLOSED:
                raise

        if not is_IRI(iri):
            raise KeyError(f"Key '{iri}' must be an IRI")
        del self._ext_data[iri]

    def property_keys(self) -> Iterator[Tuple[Optional[str], str, Optional[str]]]:
        iris: Set[str] = set()
        for pyname, iri, compact in super().property_keys():
            iris.add(iri)
            yield pyname, iri, compact

        if self.CLOSED:
            return

        for iri in self._ext_data.keys():
            if iri not in iris:
                yield None, iri, None


class SHACLObjectSet(object):
    def __init__(
        self, objects: Collection[SHACLObject] = [], *, link: bool = False
    ) -> None:
        self.objects: Set[SHACLObject] = set(objects)
        self.missing_ids: Set[str] = set()
        self.obj_by_id: Dict[str, SHACLObject] = {}
        self.obj_by_type: Dict[str, Set[Tuple[bool, SHACLObject]]] = {}
        self.create_index()
        self.context: Dict[str, str] = {}
        if link:
            self._link()

    def create_index(self) -> None:
        """
        (re)Create object index

        Creates or recreates the indices for the object set to enable fast
        lookup. All objects and their children are walked and indexed
        """
        self.obj_by_id = {}
        self.obj_by_type = {}
        for o in self.foreach():
            self.add_index(o)

    def add_index(self, obj: SHACLObject) -> None:
        """
        Add object to index

        Adds the object to all appropriate indices
        """

        def reg_type(
            typ: str, compact: Optional[str], o: SHACLObject, exact: bool
        ) -> None:
            self.obj_by_type.setdefault(typ, set()).add((exact, o))
            if compact:
                self.obj_by_type.setdefault(compact, set()).add((exact, o))

        if not isinstance(obj, SHACLObject):
            raise TypeError("Object is not of type SHACLObject")

        for typ in SHACLObject.CLASSES.values():
            if isinstance(obj, typ):
                reg_type(typ._TYPE, typ._COMPACT_TYPE, obj, obj.__class__ is typ)

        # This covers custom extensions
        reg_type(obj.get_type(), obj.get_compact_type(), obj, True)

        if not obj._id:
            return

        self.missing_ids.discard(obj._id)

        if obj._id in self.obj_by_id:
            return

        self.obj_by_id[obj._id] = obj

    def add(self, obj: SHACLObject) -> SHACLObject:
        """
        Add object to object set

        Adds a SHACLObject to the object set and index it.

        NOTE: Child objects of the attached object are not indexes
        """
        if not isinstance(obj, SHACLObject):
            raise TypeError("Object is not of type SHACLObject")

        if obj not in self.objects:
            self.objects.add(obj)
            self.add_index(obj)
        return obj

    def update(self, *others: Iterable[SHACLObject]) -> None:
        """
        Update object set adding all objects in each other iterable
        """
        for o in others:
            for obj in o:
                self.add(obj)

    def __contains__(self, item: SHACLObject) -> bool:
        """
        Returns True if the item is in the object set
        """
        return item in self.objects

    def link(self) -> Set[str]:
        """
        Link object set

        Links the object in the object set by replacing string object
        references with references to the objects themselves. e.g.
        a property that references object "https://foo/bar" by a string
        reference will be replaced with an actual reference to the object in
        the object set with the same ID if it exists in the object set

        If multiple objects with the same ID are found, the duplicates are
        eliminated
        """
        self.create_index()
        return self._link()

    def _link(self) -> Set[str]:
        self.missing_ids = set()
        visited: Set[SHACLObject] = set()

        new_objects: Set[SHACLObject] = set()

        for o in self.objects:
            if o._id:
                o = cast(SHACLObject, self.find_by_id(o._id, o))
            o.link_helper(self, self.missing_ids, visited)
            new_objects.add(o)

        self.objects = new_objects

        # Remove blank nodes
        obj_by_id: Dict[str, SHACLObject] = {}
        for _id, obj in self.obj_by_id.items():
            if _id.startswith("_:"):
                del obj._id
            else:
                obj_by_id[_id] = obj
        self.obj_by_id = obj_by_id

        # Named individuals aren't considered missing
        self.missing_ids -= NAMED_INDIVIDUALS

        return self.missing_ids

    def find_by_id(
        self, _id: str, default: Optional[SHACLObject] = None
    ) -> Optional[SHACLObject]:
        """
        Find object by ID

        Returns objects that match the specified ID, or default if there is no
        object with the specified ID
        """
        if _id not in self.obj_by_id:
            return default
        return self.obj_by_id[_id]

    def foreach(self) -> Iterable[SHACLObject]:
        """
        Iterate over every object in the object set, and all child objects
        """
        visited = set()
        for o in self.objects:
            if o not in visited:
                yield o
                visited.add(o)

            for child in o.iter_objects(recursive=True, visited=visited):
                yield child

    @overload
    def foreach_type(
        self, typ: str, *, match_subclass: bool = True
    ) -> Iterator[SHACLObject]: ...

    @overload
    def foreach_type(
        self, typ: Type[T_SHACLObject], *, match_subclass: bool = True
    ) -> Iterator[T_SHACLObject]: ...

    def foreach_type(
        self, typ: Union[str, Type[T_SHACLObject]], *, match_subclass: bool = True
    ) -> Iterable[SHACLObject]:
        """
        Iterate over each object of a specified type (or subclass there of)

        If match_subclass is True, and class derived from typ will also match
        (similar to isinstance()). If False, only exact matches will be
        returned
        """
        if not isinstance(typ, str):
            if not isinstance(typ, type) or not issubclass(typ, SHACLObject):
                raise TypeError(f"Type must be derived from SHACLObject, got {typ}")
            # This intermediate step is necessary for pyrefly...
            typ_class: Type[SHACLObject] = typ
            typ = typ_class._TYPE

        if typ not in self.obj_by_type:
            return

        for exact, o in self.obj_by_type[typ]:
            if match_subclass or exact:
                yield cast(T_SHACLObject, o)

    def merge(self, *objectsets: "SHACLObjectSet") -> "SHACLObjectSet":
        """
        Merge object sets

        Returns a new object set that is the combination of this object set and
        all provided arguments
        """
        new_objects: Set[SHACLObject] = set()
        new_objects |= self.objects
        for d in objectsets:
            new_objects |= d.objects

        return SHACLObjectSet(new_objects, link=True)

    def inline_blank_nodes(self) -> None:
        """
        Removes (inlines) blank node objects from the root object set if they
        are referenced in only one other location besides the root.

        Deserializers that do not preserve the tree-like structure of the
        objects (e.g. RDF) should call this to ensure that blank nodes are
        inline correctly
        """
        ref_counts: Dict[SHACLObject, int] = {}

        def walk_callback(value: Any, path: List[str]) -> bool:
            if not isinstance(value, SHACLObject):
                return True

            ref_counts.setdefault(value, 0)
            ref_counts[value] += 1
            if ref_counts[value] > 1:
                return False

            return True

        for o in self.objects:
            # Note that every object in the root object set gets at least one
            # reference
            o.walk(walk_callback)

        new_objects: Set[SHACLObject] = set()
        for o in self.objects:
            if is_IRI(o._id):
                new_objects.add(o)
            # If the object is a blank node and is only referenced by this
            # root list and one other location, remove it from the root list
            #
            # A count of 1 means the object is only referenced by the root, and
            # therefore must be kept
            elif ref_counts[o] != 2:
                new_objects.add(o)

        self.objects = new_objects

    def encode(
        self,
        encoder: Encoder,
        state: EncodeState,
        force_list: bool = False,
        *,
        key: Optional[Callable[[SHACLObject], Any]] = None,
    ) -> None:
        """
        Serialize a list of objects to a serialization encoder

        If force_list is true, a list will always be written using the encoder.
        """
        ref_counts: Dict[SHACLObject, int] = {}

        def walk_callback(value: Any, path: List[str]) -> bool:
            if not isinstance(value, SHACLObject):
                return True

            # Remove blank node ID for re-assignment
            if is_blank_node(value._id):
                del value._id

            if value._id:
                state.add_refed(value)

            # If the object is referenced more than once, add it to the set of
            # referenced objects
            ref_counts.setdefault(value, 0)
            ref_counts[value] += 1
            if ref_counts[value] > 1:
                state.add_refed(value)
                return False

            return True

        for o in self.objects:
            if o._id:
                state.add_refed(o)
            o.walk(walk_callback)

        use_list = force_list or len(self.objects) > 1

        if use_list:
            # If we are making a list add all the objects referred to by reference
            # to the list
            objects = list(self.objects | state.ref_objects)
        else:
            objects = list(self.objects)

        objects.sort(key=key)

        if use_list:
            # Ensure top level objects are only written in the top level graph
            # node, and referenced by ID everywhere else. This is done by setting
            # the flag that indicates this object has been written for all the top
            # level objects, then clearing it right before serializing the object.
            #
            # In this way, if an object is referenced before it is supposed to be
            # serialized into the @graph, it will serialize as a string instead of
            # the actual object
            for o in objects:
                state.written_objects.add(o)

            with encoder.write_object_list() as list_s:
                for o in objects:
                    # Allow this specific object to be written now
                    state.written_objects.remove(o)
                    with list_s.write_list_item() as item_s:
                        o.encode(item_s, state)

        elif objects:
            objects[0].encode(encoder, state)

    def decode(self, decoder: Decoder, state: DecodeState) -> None:
        self.create_index()
        for obj_d in decoder.read_list():
            o = SHACLExtensibleObject.decode(obj_d, state)
            self.objects.add(o)

        self._link()

    def expand_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        for k, v in self.context.items():
            if iri == k:
                return self.expand_iri(v, v)
            if iri.startswith(k + ":"):
                new_iri = v + iri[len(k) + 1 :]
                return self.expand_iri(new_iri, new_iri)
        return default

    def compact_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        for k, v in self.context.items():
            if iri == v:
                return self.compact_iri(k, k)
            if iri.startswith(v):
                new_iri = k + ":" + iri[len(v) :]
                return self.compact_iri(new_iri, new_iri)
        return default


class EncodeState(object):
    def __init__(self, objectset: SHACLObjectSet):
        self.ref_objects: Set[SHACLObject] = set()
        self.written_objects: Set[SHACLObject] = set()
        self.blank_objects: Dict[SHACLObject, str] = {}
        self.objectset = objectset

    def get_object_id(self, o: SHACLObject) -> str:
        if o._id:
            return o._id

        if o not in self.blank_objects:
            _id = f"_:{o.__class__.__name__}{len(self.blank_objects)}"
            self.blank_objects[o] = _id

        return self.blank_objects[o]

    def is_refed(self, o: SHACLObject) -> bool:
        return o in self.ref_objects

    def add_refed(self, o: SHACLObject) -> None:
        self.ref_objects.add(o)

    def is_written(self, o: SHACLObject) -> bool:
        return o in self.written_objects

    def add_written(self, o: SHACLObject) -> None:
        self.written_objects.add(o)

    def expand_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        if self.objectset:
            return self.objectset.expand_iri(iri, default)
        return default

    def compact_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        if self.objectset:
            return self.objectset.compact_iri(iri, default)
        return default


class DecodeState(object):
    def __init__(self, objectset: SHACLObjectSet):
        self.objectset = objectset
        self.read_objs: Dict[str, SHACLObject] = {}

    def expand_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        if self.objectset:
            return self.objectset.expand_iri(iri, default)
        return default

    def compact_iri(self, iri: str, default: Optional[str] = None) -> Optional[str]:
        if self.objectset:
            return self.objectset.compact_iri(iri, default)
        return default


class Decoder(ABC):
    @abstractmethod
    def read_value(self) -> Optional[Any]:
        """
        Consume next item

        Consumes the next item of any type
        """
        raise NotImplementedError("Subclasses must implement read_value method")

    @abstractmethod
    def read_string(self) -> Optional[str]:
        """
        Consume the next item as a string.

        Returns the string value of the next item, or `None` if the next item
        is not a string
        """
        raise NotImplementedError("Subclasses must implement read_string method")

    @abstractmethod
    def read_datetime(self) -> Optional[str]:
        """
        Consumes the next item as a date & time string

        Returns the string value of the next item, if it is a ISO datetime, or
        `None` if the next item is not a ISO datetime string.

        Note that validation of the string is done by the caller, so a minimal
        implementation can just check if the next item is a string without
        worrying about the format
        """
        raise NotImplementedError("Subclasses must implement read_datetime method")

    @abstractmethod
    def read_integer(self) -> Optional[int]:
        """
        Consumes the next item as an integer

        Returns the integer value of the next item, or `None` if the next item
        is not an integer
        """
        raise NotImplementedError("Subclasses must implement read_integer method")

    @abstractmethod
    def read_iri(self) -> Optional[str]:
        """
        Consumes the next item as an IRI string

        Returns the string value of the next item an IRI, or `None` if the next
        item is not an IRI.

        The returned string should be either a fully-qualified IRI, or a blank
        node ID
        """
        raise NotImplementedError("Subclasses must implement read_iri method")

    @abstractmethod
    def read_enum(self, e: Property[Any]) -> Optional[str]:
        """
        Consumes the next item as an Enum value string

        Returns the fully qualified IRI of the next enum item, or `None` if the
        next item is not an enum value.

        The callee is responsible for validating that the returned IRI is
        actually a member of the specified Enum, so the `Decoder` does not need
        to check that, but can if it wishes
        """
        raise NotImplementedError("Subclasses must implement read_enum method")

    @abstractmethod
    def read_bool(self) -> Optional[bool]:
        """
        Consume the next item as a boolean value

        Returns the boolean value of the next item, or `None` if the next item
        is not a boolean
        """
        raise NotImplementedError("Subclasses must implement read_bool method")

    @abstractmethod
    def read_float(self) -> Optional[float]:
        """
        Consume the next item as a float value

        Returns the float value of the next item, or `None` if the next item is
        not a float
        """
        raise NotImplementedError("Subclasses must implement read_float method")

    @abstractmethod
    def read_list(self) -> Iterator["Decoder"]:
        """
        Consume the next item as a list generator

        This should generate a `Decoder` object for each item in the list. The
        generated `Decoder` can be used to read the corresponding item from the
        list
        """
        raise NotImplementedError("Subclasses must implement read_list method")

    @abstractmethod
    def is_list(self) -> bool:
        """
        Checks if the next item is a list

        Returns True if the next item is a list, or False if it is a scalar
        """
        raise NotImplementedError("Subclasses must implement is_list method")

    @abstractmethod
    def read_object(self) -> Tuple[Any, "Decoder"]:
        """
        Consume next item as an object

        A context manager that "enters" the next item as a object and yields a
        `Decoder` that can read properties from it. If the next item is not an
        object, yields `None`

        Properties will be read out of the object using `read_property` and
        `read_object_id`
        """
        raise NotImplementedError("Subclasses must implement read_object method")

    @abstractmethod
    @contextmanager
    def read_property(self, key: str) -> Iterator[Optional["Decoder"]]:
        """
        Read property from object

        A context manager that yields a `Decoder` that can be used to read the
        value of the property with the given key in current object, or `None`
        if the property does not exist in the current object.
        """
        raise NotImplementedError("Subclasses must implement read_property method")

    @abstractmethod
    def is_object(self) -> bool:
        """
        Checks if the item is an object

        Returns True if the item is an object, or False if is not
        """
        raise NotImplementedError("Subclasses must implement is_object method")

    @abstractmethod
    def object_keys(self) -> Iterator[str]:
        """
        Read property keys from an object

        Iterates over all the serialized keys for the current object
        """
        raise NotImplementedError("Subclasses must implement object_keys method")

    @abstractmethod
    def read_object_id(self, alias: Optional[str] = None) -> Optional[Any]:
        """
        Read current object ID property

        Returns the ID of the current object if one is defined, or `None` if
        the current object has no ID.

        The ID must be a fully qualified IRI or a blank node

        If `alias` is provided, is is a hint as to another name by which the ID
        might be found, if the `Decoder` supports aliases for an ID
        """
        raise NotImplementedError("Subclasses must implement read_object_id method")


class JSONLDDecoder(Decoder):
    def __init__(self, data: Any, root: bool = False) -> None:
        self.data = data
        self.root = root

    def read_value(self) -> Optional[Any]:
        if isinstance(self.data, str):
            try:
                return float(self.data)
            except ValueError:
                pass
        return self.data

    def read_string(self) -> Optional[str]:
        if isinstance(self.data, str):
            return self.data
        return None

    def read_datetime(self) -> Optional[str]:
        return self.read_string()

    def read_integer(self) -> Optional[int]:
        if isinstance(self.data, int):
            return self.data
        return None

    def read_bool(self) -> Optional[bool]:
        if isinstance(self.data, bool):
            return self.data
        return None

    def read_float(self) -> Optional[float]:
        if isinstance(self.data, (int, float, str)):
            return float(self.data)
        return None

    def read_iri(self) -> Optional[str]:
        if isinstance(self.data, str):
            return self.data
        return None

    def read_enum(self, e: Property[Any]) -> Optional[str]:
        if isinstance(self.data, str):
            return self.data
        return None

    def read_list(self) -> Iterator["JSONLDDecoder"]:
        if self.is_list():
            for v in self.data:
                yield self.__class__(v)
        else:
            yield self

    def is_list(self) -> bool:
        return isinstance(self.data, (list, tuple, set))

    def __get_value(self, *keys: Optional[str]) -> Optional[Any]:
        for k in keys:
            if k and k in self.data:
                return self.data[k]
        return None

    @contextmanager
    def read_property(self, key: str) -> Iterator[Optional["JSONLDDecoder"]]:
        v = self.__get_value(key)
        if v is not None:
            yield self.__class__(v)
        else:
            yield None

    def is_object(self) -> bool:
        return isinstance(self.data, dict)

    def object_keys(self) -> Iterator[str]:
        for key in self.data.keys():
            if key in ("@type", "{{ context.compact_iri('@type') }}"):
                continue
            if self.root and key == "@context":
                continue
            yield key

    def read_object(self) -> Tuple[Any, "JSONLDDecoder"]:
        typ = self.__get_value("@type", "{{ context.compact_iri('@type') }}")
        if typ is not None:
            return typ, self

        return None, self

    def read_object_id(self, alias: Optional[str] = None) -> Optional[Any]:
        return self.__get_value(alias, "@id")


class JSONLDDeserializer(object):
    def deserialize_data(self, data: Any, objectset: SHACLObjectSet) -> None:
        h = JSONLDDecoder(data, True)

        with h.read_property("@context") as context_prop:
            if context_prop:
                decode_context(context_prop, objectset)

        state = DecodeState(objectset)
        with h.read_property("@graph") as graph_prop:
            objectset.decode(graph_prop if graph_prop else h, state)

    def read(self, f: Any, objectset: SHACLObjectSet) -> None:
        data = json.load(f)
        self.deserialize_data(data, objectset)


class Encoder(ABC):
    @abstractmethod
    def write_string(self, v: str) -> None:
        """
        Write a string value

        Encodes the value as a string in the output
        """
        raise NotImplementedError("Subclasses must implement write_string method")

    @abstractmethod
    def write_datetime(self, v: str) -> None:
        """
        Write a date & time string

        Encodes the value as an ISO datetime string

        Note: The provided string is already correctly encoded as an ISO datetime
        """
        raise NotImplementedError("Subclasses must implement write_datetime method")

    @abstractmethod
    def write_integer(self, v: int) -> None:
        """
        Write an integer value

        Encodes the value as an integer in the output
        """
        raise NotImplementedError("Subclasses must implement write_integer method")

    @abstractmethod
    def write_iri(self, v: str, compact: Optional[str] = None) -> None:
        """
        Write IRI

        Encodes the string as an IRI. Note that the string will be either a
        fully qualified IRI or a blank node ID. If `compact` is provided and
        the serialization supports compacted IRIs, it should be preferred to
        the full IRI
        """
        raise NotImplementedError("Subclasses must implement write_iri method")

    @abstractmethod
    def write_enum(
        self, v: str, e: Property[Any], compact: Optional[str] = None
    ) -> None:
        """
        Write enum value IRI

        Encodes the string enum value IRI. Note that the string will be a fully
        qualified IRI. If `compact` is provided and the serialization supports
        compacted IRIs, it should be preferred to the full IRI.
        """
        raise NotImplementedError("Subclasses must implement write_enum method")

    @abstractmethod
    def write_bool(self, v: bool) -> None:
        """
        Write boolean

        Encodes the value as a boolean in the output
        """
        raise NotImplementedError("Subclasses must implement write_bool method")

    @abstractmethod
    def write_float(self, v: float) -> None:
        """
        Write float

        Encodes the value as a floating point number in the output
        """
        raise NotImplementedError("Subclasses must implement write_float method")

    @abstractmethod
    @contextmanager
    def write_object(
        self,
        typ: str,
        compact_type: Optional[str],
        id_alias: Optional[str],
        _id: str,
        compact_id: Optional[str],
        needs_id: bool,
    ):
        """
        Write object

        A context manager that yields an `Encoder` that can be used to encode
        the given object properties.

        The provided ID will always be a valid ID (even if o._id is `None`), in
        case the `Encoder` _must_ have an ID. `needs_id` is a hint to indicate
        to the `Encoder` if an ID must be written or not (if that is even an
        option). If it is `True`, the `Encoder` must encode an ID for the
        object. If `False`, the encoder is not required to encode an ID and may
        omit it.

        The ID will be either a fully qualified IRI, or a blank node IRI.

        Properties will be written the object using `write_property`
        """
        raise NotImplementedError("Subclasses must implement write_object method")

    @abstractmethod
    @contextmanager
    def write_property(
        self, iri: str, compact: Optional[str] = None
    ) -> Iterator["Encoder"]:
        """
        Write object property

        A context manager that yields an `Encoder` that can be used to encode
        the value for the property with the given IRI in the current object

        Note that the IRI will be fully qualified. If `compact` is provided and
        the serialization supports compacted IRIs, it should be preferred to
        the full IRI.
        """
        raise NotImplementedError("Subclasses must implement write_property method")

    @abstractmethod
    @contextmanager
    def write_list(self) -> Iterator["Encoder"]:
        """
        Write list

        A context manager that yields an `Encoder` that can be used to encode a
        list.

        Each item of the list will be added using `write_list_item`
        """
        raise NotImplementedError("Subclasses must implement write_list method")

    @abstractmethod
    @contextmanager
    def write_list_item(self) -> Iterator["Encoder"]:
        """
        Write list item

        A context manager that yields an `Encoder` that can be used to encode
        the value for a list item
        """
        raise NotImplementedError("Subclasses must implement write_list_item method")

    @abstractmethod
    @contextmanager
    def write_dict(self) -> Iterator["Encoder"]:
        """
        Write dict

        A context manager that yields an `Encoder` that can be used to encode a
        dictionary.
        """
        raise NotImplementedError("Subclasses must implement write_dict method")

    @abstractmethod
    @contextmanager
    def write_object_list(self) -> Iterator["Encoder"]:
        """
        Write top level object list

        A context manager that yields an `Encoder` that encodes the top level
        list of objects.

        Each object in the list will be added using `write_list_item`
        """
        raise NotImplementedError("Subclasses must implement write_object_list method")


class JSONLDEncoder(Encoder):
    def __init__(self, data: Any = None) -> None:
        self.data = data

    def write_string(self, v: str) -> None:
        self.data = v

    def write_datetime(self, v: str) -> None:
        self.data = v

    def write_integer(self, v: int) -> None:
        self.data = v

    def write_iri(self, v: str, compact: Optional[str] = None) -> None:
        self.write_string(compact or v)

    def write_enum(
        self, v: str, e: Property[Any], compact: Optional[str] = None
    ) -> None:
        self.write_string(compact or v)

    def write_bool(self, v: bool) -> None:
        self.data = v

    def write_float(self, v: float) -> None:
        self.data = str(v)

    @contextmanager
    def write_property(
        self, iri: str, compact: Optional[str] = None
    ) -> Iterator["JSONLDEncoder"]:
        s = self.__class__(None)
        yield s
        if s.data is not None:
            if isinstance(self.data, dict):
                self.data[compact or iri] = s.data

    @contextmanager
    def write_dict(self) -> Iterator["JSONLDEncoder"]:
        if not self.data:
            self.data = {}
        yield self

    @contextmanager
    def write_object(
        self,
        typ: str,
        compact_type: Optional[str],
        id_alias: Optional[str],
        _id: str,
        compact_id: Optional[str],
        needs_id: bool,
    ):
        with self.write_dict() as obj_dict:
            obj_dict.data["{{ context.compact_iri('@type') }}"] = compact_type or typ  # type: ignore
            if needs_id:
                obj_dict.data[id_alias or "@id"] = compact_id or _id  # type: ignore
            yield obj_dict

    @contextmanager
    def write_list(self) -> Iterator["JSONLDEncoder"]:
        self.data = []
        yield self
        if not self.data:
            self.data = None

    @contextmanager
    def write_list_item(self) -> Iterator["JSONLDEncoder"]:
        s = self.__class__(None)
        yield s
        if s.data is not None:
            if isinstance(self.data, list):
                self.data.append(s.data)

    @contextmanager
    def write_object_list(self) -> Iterator["JSONLDEncoder"]:
        with self.write_property("@graph") as graph_prop:
            with graph_prop.write_list() as graph_list:
                yield graph_list


class JSONLDSerializer(object):
    def __init__(self, **args: Any) -> None:
        self.args = args

    def serialize_data(
        self,
        objectset: SHACLObjectSet,
        force_at_graph: bool = False,
    ) -> Any:
        h = JSONLDEncoder()
        state = EncodeState(objectset)
        with h.write_dict() as doc_s:
            encode_context(doc_s, objectset)
            objectset.encode(doc_s, state, force_at_graph)
        return h.data

    def write(
        self,
        objectset: SHACLObjectSet,
        f: Any,
        force_at_graph: bool = False,
        **kwargs: Any,
    ) -> str:
        """
        Write a SHACLObjectSet to a JSON LD file

        If force_at_graph is True, a @graph node will always be written

        Note that f should be a file-like object that supports the `write`
        method, and that opens in binary mode (e.g. `open("file.json", "wb")`).
        """
        data = self.serialize_data(objectset, force_at_graph)

        args = {**self.args, **kwargs}

        sha1 = hashlib.sha1()
        for chunk in json.JSONEncoder(**args).iterencode(data):
            chunk_bytes = chunk.encode("utf-8")
            f.write(chunk_bytes)
            sha1.update(chunk_bytes)

        return sha1.hexdigest()


class JSONLDInlineEncoder(Encoder):
    def __init__(self, f: Any, sha1: Any, in_dict: bool = False) -> None:
        self.f = f
        self.comma = False
        self.sha1 = sha1
        self.in_dict = in_dict

    def write(self, s: str) -> None:
        s_bytes = s.encode("utf-8")
        self.f.write(s_bytes)
        self.sha1.update(s_bytes)

    def _write_comma(self) -> None:
        if self.comma:
            self.write(",")
            self.comma = False

    def write_string(self, v: str) -> None:
        self.write(json.dumps(v))

    def write_datetime(self, v: str) -> None:
        self.write_string(v)

    def write_integer(self, v: int) -> None:
        self.write(f"{v}")

    def write_iri(self, v: str, compact: Optional[str] = None) -> None:
        self.write_string(compact or v)

    def write_enum(
        self, v: str, e: Property[Any], compact: Optional[str] = None
    ) -> None:
        self.write_iri(v, compact)

    def write_bool(self, v: bool) -> None:
        if v:
            self.write("true")
        else:
            self.write("false")

    def write_float(self, v: float) -> None:
        self.write(json.dumps(str(v)))

    @contextmanager
    def write_property(
        self, iri: str, compact: Optional[str] = None
    ) -> Iterator["JSONLDInlineEncoder"]:
        self._write_comma()
        self.write_string(compact or iri)
        self.write(":")
        yield self.__class__(self.f, self.sha1)
        self.comma = True

    @contextmanager
    def write_dict(self) -> Iterator["JSONLDInlineEncoder"]:
        self._write_comma()
        if self.in_dict:
            yield self
            return

        self.write("{")
        yield self.__class__(self.f, self.sha1, True)
        self.write("}")
        self.comma = True

    @contextmanager
    def write_object(
        self,
        typ: str,
        compact_type: Optional[str],
        id_alias: Optional[str],
        _id: str,
        compact_id: Optional[str],
        needs_id: bool,
    ):
        with self.write_dict() as obj_dict:
            with obj_dict.write_property(
                "{{ context.compact_iri('@type') }}"
            ) as type_prop:
                type_prop.write_string(compact_type or typ)

            if needs_id:
                with obj_dict.write_property(id_alias or "@id") as id_prop:
                    id_prop.write_string(compact_id or _id)

            yield obj_dict

    @contextmanager
    def write_list(self) -> Iterator["JSONLDInlineEncoder"]:
        self._write_comma()
        self.write("[")
        yield self.__class__(self.f, self.sha1)
        self.write("]")
        self.comma = True

    @contextmanager
    def write_list_item(self) -> Iterator["JSONLDInlineEncoder"]:
        self._write_comma()
        yield self.__class__(self.f, self.sha1)
        self.comma = True

    @contextmanager
    def write_object_list(self) -> Iterator["JSONLDInlineEncoder"]:
        with self.write_property("@graph") as graph_prop:
            with graph_prop.write_list() as graph_list:
                yield graph_list


class JSONLDInlineSerializer(object):
    def write(
        self,
        objectset: SHACLObjectSet,
        f: Any,
        force_at_graph: bool = False,
    ) -> str:
        """
        Write a SHACLObjectSet to a JSON LD file

        Note: force_at_graph is included for compatibility, but ignored. This
        serializer always writes out a graph
        """
        sha1 = hashlib.sha1()
        h = JSONLDInlineEncoder(f, sha1)
        state = EncodeState(objectset)
        with h.write_dict() as doc_s:
            encode_context(doc_s, objectset)
            objectset.encode(doc_s, state, True)

        return sha1.hexdigest()


def encode_context(encoder: Encoder, objectset: SHACLObjectSet) -> None:
    context: List[Union[str, Dict[str, str]]] = list(CONTEXT_URLS)
    if objectset.context:
        context.append(objectset.context)

    if not context:
        return

    def write_context(e: Encoder, ctx: Union[str, Dict[str, str]]) -> None:
        if isinstance(ctx, str):
            e.write_string(ctx)
        else:
            with e.write_dict() as dict_s:
                for k, v in ctx.items():
                    with dict_s.write_property(k) as ctx_prop:
                        ctx_prop.write_string(v)

    with encoder.write_property("@context") as context_prop:
        if len(context) == 1:
            write_context(context_prop, context[0])
        else:
            with context_prop.write_list() as context_list:
                for ctx in context:
                    with context_list.write_list_item() as context_list_item:
                        write_context(context_list_item, ctx)


def decode_context(decoder: Decoder, objectset: SHACLObjectSet) -> None:
    def _decode_ctx(d: Decoder) -> None:
        if not d.is_object():
            return

        for k in d.object_keys():
            with d.read_property(k) as prop_d:
                if prop_d:
                    if s := prop_d.read_string():
                        objectset.context[k] = s

    if decoder.is_list():
        for ctx_d in decoder.read_list():
            _decode_ctx(ctx_d)
            pass
    else:
        _decode_ctx(decoder)


try:
    import rdflib
    import rdflib.term
    from rdflib.namespace import RDF

    class RDFDecoder(Decoder):
        def __init__(
            self,
            graph: rdflib.Graph,
            subject: Optional[rdflib.term.Node] = None,
            predicate: Optional[rdflib.term.Node] = None,
            value: Optional[rdflib.term.Node] = None,
        ):
            self.graph = graph
            self.subject = subject
            self.predicate = predicate
            self.value = value

        def __read_node(self) -> Optional[Any]:
            if self.value is not None:
                return self.value
            if self.predicate is None:
                return None
            return self.graph.value(self.subject, self.predicate)

        def read_value(self) -> Optional[Any]:
            v = self.__read_node()
            if isinstance(v, rdflib.term.Literal):
                return v.toPython()
            return None

        def read_string(self) -> Optional[str]:
            v = self.read_value()
            if isinstance(v, str):
                return v
            return None

        def read_datetime(self) -> Optional[str]:
            return self.read_value()

        def read_integer(self) -> Optional[int]:
            v = self.read_value()
            if isinstance(v, (int, decimal.Decimal)):
                return int(v)
            return None

        def read_bool(self) -> Optional[bool]:
            v = self.read_value()
            if isinstance(v, bool):
                return v
            return None

        def read_float(self) -> Optional[float]:
            v = self.read_value()
            if isinstance(v, (int, float, str, decimal.Decimal)):
                return float(v)
            return None

        def read_iri(self) -> Optional[str]:
            v = self.__read_node()
            if isinstance(v, rdflib.term.URIRef):
                return v.toPython()
            elif isinstance(v, rdflib.term.Literal):
                v = v.toPython()
                if isinstance(v, str):
                    return v
            elif isinstance(v, rdflib.term.BNode):
                return v.n3()
            return None

        def read_enum(self, e: Property[Any]) -> Optional[str]:
            v = self.__read_node()
            if isinstance(v, rdflib.term.URIRef):
                return v.toPython()
            return None

        def read_list(self) -> Iterator["RDFDecoder"]:
            if not self.subject:
                blank_nodes = set()
                for s in self.graph.subjects(unique=True):
                    if (s, RDF.type, None) not in self.graph:
                        continue

                    if isinstance(s, rdflib.term.BNode):
                        blank_nodes.add(s)
                        continue
                    yield self.__class__(self.graph, s)

                for s in blank_nodes:
                    yield self.__class__(self.graph, s)
            else:
                for o in self.graph.objects(self.subject, self.predicate):
                    if (o, RDF.type, None) in self.graph:
                        yield self.__class__(self.graph, o)
                    else:
                        yield self.__class__(
                            self.graph,
                            self.subject,
                            self.predicate,
                            o,
                        )

        def is_list(self) -> bool:
            if not self.subject:
                return True
            if self.value is not None:
                return False
            return len(list(self.graph.objects(self.subject, self.predicate))) > 1

        @contextmanager
        def read_property(self, key: str) -> Iterator[Optional["RDFDecoder"]]:
            if key == "@id":
                yield self.__class__(self.graph, value=self.subject)
            else:
                yield self.__class__(self.graph, self.subject, rdflib.term.URIRef(key))

        def is_object(self) -> bool:
            n = self.__read_node() or self.subject
            return (n, RDF.type, None) in self.graph

        def object_keys(self) -> Iterator[str]:
            for p in self.graph.predicates(self.subject, unique=True):
                if p == RDF.type:
                    continue

                if not isinstance(p, rdflib.term.IdentifiedNode):
                    raise TypeError(f"Predicate is of unknown type {type(p)}")

                yield p.toPython()

        def read_object(self) -> Tuple[Any, "RDFDecoder"]:
            s = self.__read_node()
            if s is None:
                s = self.subject

            typ = self.graph.value(s, RDF.type)
            if typ is None:
                return None, self

            if not isinstance(typ, rdflib.term.IdentifiedNode):
                raise TypeError(f"Type value is of unknown type {type(typ)}")

            return typ.toPython(), self.__class__(self.graph, s)

        def read_object_id(self, alias: Optional[str] = None) -> Optional[Any]:
            if isinstance(self.subject, rdflib.term.BNode):
                return self.subject.n3()
            if not isinstance(self.subject, rdflib.term.IdentifiedNode):
                raise TypeError(f"Subject is of unknown type {type(self.subject)}")
            return self.subject.toPython()

    class RDFDeserializer(object):
        def read(self, graph: rdflib.Graph, objset: SHACLObjectSet) -> None:
            d = RDFDecoder(graph)
            state = DecodeState(objset)
            objset.decode(d, state)
            objset.inline_blank_nodes()

    class RDFEncoder(Encoder):
        def __init__(
            self,
            graph: rdflib.Graph,
            subject: Optional[rdflib.term.Node] = None,
            predicate: Optional[rdflib.term.Node] = None,
        ):
            self.graph = graph
            self.subject = subject
            self.predicate = predicate

        def __add_literal(self, v: Any) -> None:
            if self.subject is None or self.predicate is None:
                raise TypeError()
            self.graph.add((self.subject, self.predicate, rdflib.Literal(v)))

        def __add_uriref(self, v: str) -> None:
            if self.subject is None or self.predicate is None:
                raise TypeError()
            self.graph.add((self.subject, self.predicate, rdflib.URIRef(v)))

        def write_string(self, v: str) -> None:
            self.__add_literal(v)

        def write_datetime(self, v: str) -> None:
            self.__add_literal(v)

        def write_integer(self, v: int) -> None:
            self.__add_literal(v)

        def write_iri(self, v: str, compact: Optional[str] = None) -> None:
            self.__add_uriref(v)

        def write_enum(
            self, v: str, e: Property[Any], compact: Optional[str] = None
        ) -> None:
            self.__add_uriref(v)

        def write_bool(self, v: bool) -> None:
            self.__add_literal(v)

        def write_float(self, v: float) -> None:
            self.__add_literal(v)

        @contextmanager
        def write_property(
            self, iri: str, compact: Optional[str] = None
        ) -> Iterator["RDFEncoder"]:
            yield self.__class__(self.graph, self.subject, rdflib.URIRef(iri))

        @contextmanager
        def write_object(
            self,
            typ: str,
            compact_type: Optional[str],
            id_alias: Optional[str],
            _id: str,
            compact_id: Optional[str],
            needs_id: bool,
        ):
            obj: rdflib.term.Node
            if _id.startswith("_:"):
                obj = rdflib.BNode(_id[2:])
            else:
                obj = rdflib.URIRef(_id)

            if self.subject is not None:
                if self.predicate is None:
                    raise TypeError()
                self.graph.add((self.subject, self.predicate, obj))
            self.graph.add((obj, RDF.type, rdflib.URIRef(typ)))  # type: ignore # RDF.type is dynamic
            yield self.__class__(self.graph, obj)

        @contextmanager
        def write_list(self) -> Iterator["RDFEncoder"]:
            yield self

        @contextmanager
        def write_list_item(self) -> Iterator["RDFEncoder"]:
            yield self

        @contextmanager
        def write_object_list(self) -> Iterator["RDFEncoder"]:
            yield self

    class RDFSerializer(object):
        def write(self, objset: SHACLObjectSet, g: rdflib.Graph) -> None:
            """
            Write a SHACLObjectSet to an RDF graph
            """
            e = RDFEncoder(g)
            state = EncodeState(objset)
            objset.encode(e, state)

except ImportError:
    pass


def print_tree(objects: Iterable[SHACLObject], all_fields: bool = False) -> None:
    """
    Print object tree
    """
    seen = set()

    def callback(value: Any, path: List[str]) -> bool:
        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard{{ '"' }}{{ '"' }}{{ '"' }}
{% set
DATATYPE_CLASSES = {
    "http://www.w3.org/2001/XMLSchema#string": "StringProp",
    "http://www.w3.org/2001/XMLSchema#anyURI": "AnyURIProp",
    "http://www.w3.org/2001/XMLSchema#integer": "IntegerProp",
    "http://www.w3.org/2001/XMLSchema#positiveInteger": "PositiveIntegerProp",
    "http://www.w3.org/2001/XMLSchema#nonNegativeInteger": "NonNegativeIntegerProp",
    "http://www.w3.org/2001/XMLSchema#boolean": "BooleanProp",
    "http://www.w3.org/2001/XMLSchema#decimal": "FloatProp",
    "http://www.w3.org/2001/XMLSchema#dateTime": "DateTimeProp",
    "http://www.w3.org/2001/XMLSchema#dateTimeStamp": "DateTimeStampProp",
}
-%}


__all__ = [
    "SHACLObject",
    "SHACLExtensibleObject",
    "SHACLObjectSet",
    "NodeKind",
    "ListProxy",
    "Decoder",
    "Encoder",
    "JSONLDDecoder",
    "JSONLDDeserializer",
    "JSONLDEncoder",
    "JSONLDSerializer",
    "JSONLDInlineEncoder",
    "JSONLDInlineSerializer",
{%- for class in classes %}
    "{{ varname(*class.clsname) }}",
{%- endfor %}
]

CONTEXT_URLS: List[str] = [
{%- for url in context.urls %}
    "{{ url }}",
{%- endfor %}
]


# CLASSES
{%- for class in classes %}
{%- if class.comment %}
{%- for l in class.comment.split("\n") %}
#{{ (" " + l).rstrip() }}
{%- endfor %}
{%- endif %}
class {{ varname(*class.clsname) }}(
{%- if class.parent_ids %}
    {%- for id in class.parent_ids -%}
        {{- varname(*classes.get(id).clsname) }}{%- if not loop.last or class.is_extensible -%}, {% endif -%}
    {%- endfor -%}
    {%- if class.is_extensible -%}
        SHACLExtensibleObject
    {%- endif -%}
{%- elif class.is_extensible -%}
    SHACLExtensibleObject
{%- else -%}
    SHACLObject
{%- endif -%}):
    TYPE = "{{ class._id }}"
    {%- if context.compact_iri(class._id) != class._id %}
    COMPACT_TYPE = "{{ context.compact_iri(class._id) }}"
    {%- endif %}
    NODE_KIND: NodeKind = NodeKind.{{ class.node_kind.split("#")[-1] }}
    {%- if class.id_property %}
    ID_ALIAS: Optional[str] = "{{ class.id_property }}"
    {%- endif %}
    {%- if class.is_abstract %}
    IS_ABSTRACT: bool = True
    {%- endif %}
    {%- if class.deprecated %}
    IS_DEPRECATED: bool = True
    {%- endif %}
    {%- if class.named_individuals %}
    NAMED_INDIVIDUALS: Dict[str, str] = {
        {%- for member in class.named_individuals %}
        {%- if member.comment %}
        {%- for l in member.comment.split("\n") %}
        #{{ (" " + l).rstrip() }}
        {%- endfor %}
        {%- endif %}
        "{{ varname(member.varname) }}": "{{ member._id }}",
        {%- endfor %}
    }
    {%- endif %}

    {%- if class.properties %}
    PROPERTIES = [
    {%- for prop in class.properties %}
        {%- set is_list = prop.max_count is none or prop.max_count != 1 %}
        {%- if prop.comment %}
        {%- for l in prop.comment.split("\n") %}
        #{{ (" " + l).rstrip() }}
        {%- endfor %}
        {%- endif %}
        ClassProp(
            "{{ varname(prop.varname) }}",
            lambda:
            {% if is_list -%}ListProp({% endif %}
            {%- if prop.enum_values -%}
                EnumProp([
                {%- for value in prop.enum_values %}
                    ("{{ value }}", "{{ context.compact_vocab(value, prop.path) }}"),
                {%- endfor %}
                ])
            {%- elif prop.class_id -%}
                {%- set ctx = [] %}
                {%- for value in get_all_named_individuals(classes.get(prop.class_id)) %}
                    {%- if context.compact_vocab(value, prop.path) != value %}
                        {{- ctx.append((value, context.compact_vocab(value, prop.path))) or "" }}
                    {%- endif %}
                {%- endfor -%}
                ObjectProp({{ varname(*classes.get(prop.class_id).clsname) }}, {% if prop.min_count and not is_list %}True{% else %}False{% endif %}{% if ctx %}, context=(
                {%- for value, compact in ctx %}
                    ("{{ value }}", "{{ compact }}"),
                {%- endfor %}
                ),
                {%- endif -%}
                )
            {%- else -%}
                {% if not prop.datatype in DATATYPE_CLASSES -%}
                    {{ abort("Unknown data type " + prop.datatype) -}}
                {% endif -%}
                {{ DATATYPE_CLASSES[prop.datatype] }}({%- if prop.pattern %}pattern=r"{{ prop.pattern }}"{%- endif %})
            {%- endif %}{% if is_list %}){% endif %},
            iri="{{ prop.path }}",
            {%- if is_list and not prop.max_count is none %}
            max_count={{ prop.max_count }},
            {%- endif %}
            {%- if not prop.min_count is none %}
            min_count={{ prop.min_count }},
            {%- endif %}
            {%- if context.compact_vocab(prop.path) != prop.path %}
            compact="{{ context.compact_vocab(prop.path) }}",
            {%- endif %}
            deprecated={{ prop.deprecated }},
        ),
    {%- endfor %}
    ]
    {%- endif %}

{% endfor %}
{{ '"' }}{{ '"' }}{{ '"' }}Format Guard"""
# fmt: on


def main() -> int:
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    objectset = SHACLObjectSet()
    with args.infile.open("r") as f:
        d = JSONLDDeserializer()
        d.read(f, objectset)

    if args.print:
        print_tree(objectset.objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            s = JSONLDSerializer()
            s.write(objectset, f)

    return 0


if __name__ == "__main__":
    sys.exit(main())
