/**
 * @file
 *
 * Generated C++ bindings from a SHACL model
 *
 * This file was automatically generated by shacl2code. DO NOT MANUALLY MODIFY IT
 *
 * SPDX-License-Identifier: MIT
 */

#include <exception>
#include <list>
#include <map>
#include <memory>
#include <optional>
#include <regex>
#include <set>
#include <stdexcept>
#include <string>
#include <unordered_set>
#include <variant>
#include <vector>

/* */
#include "test-context.hpp"
namespace test_context {
/* */

using std::string_literals::operator""s;

#ifndef DOXYGEN_SKIP
// clang-format off
// Auto-Generated Implementation

// abstract_class

const abstract_class::TypeClass abstract_class::Type(
    "http://example.org/abstract-class",
    "abstract-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

abstract_class::abstract_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

abstract_class::~abstract_class() {}


// abstract_sh_class

const abstract_sh_class::TypeClass abstract_sh_class::Type(
    "http://example.org/abstract-sh-class",
    "abstract-sh-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

abstract_sh_class::abstract_sh_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

abstract_sh_class::~abstract_sh_class() {}


// abstract_spdx_class

const abstract_spdx_class::TypeClass abstract_spdx_class::Type(
    "http://example.org/abstract-spdx-class",
    "abstract-spdx-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

abstract_spdx_class::abstract_spdx_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

abstract_spdx_class::~abstract_spdx_class() {}


// concrete_class

const concrete_class::TypeClass concrete_class::Type(
    "http://example.org/concrete-class",
    "concrete-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

concrete_class::concrete_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    abstract_class(type, typeIRIs)
{}

concrete_class::~concrete_class() {}


// concrete_sh_class

const concrete_sh_class::TypeClass concrete_sh_class::Type(
    "http://example.org/concrete-sh-class",
    "concrete-sh-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

concrete_sh_class::concrete_sh_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    abstract_sh_class(type, typeIRIs)
{}

concrete_sh_class::~concrete_sh_class() {}


// concrete_spdx_class

const concrete_spdx_class::TypeClass concrete_spdx_class::Type(
    "http://example.org/concrete-spdx-class",
    "concrete-spdx-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

concrete_spdx_class::concrete_spdx_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    abstract_spdx_class(type, typeIRIs)
{}

concrete_spdx_class::~concrete_spdx_class() {}


// enumType

const enumType::TypeClass enumType::Type(
    "http://example.org/enumType",
    "enumType",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

enumType::enumType(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

enumType::~enumType() {}
const NamedIndividual enumType::foo(
    &enumType::Type,
    "http://example.org/enumType/foo",
    "test:enumType/foo"
);
const NamedIndividual enumType::bar(
    &enumType::Type,
    "http://example.org/enumType/bar",
    "test:enumType/bar"
);
const NamedIndividual enumType::nolabel(
    &enumType::Type,
    "http://example.org/enumType/nolabel",
    "test:enumType/nolabel"
);


// extensible_abstract_class

const extensible_abstract_class::TypeClass extensible_abstract_class::Type(
    "http://example.org/extensible-abstract-class",
    "extensible-abstract-class",
    {},
    NodeKind::BlankNodeOrIRI,
    true
);

extensible_abstract_class::extensible_abstract_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLExtensibleObject<SHACLObject>(type, typeIRIs)
{}

extensible_abstract_class::~extensible_abstract_class() {}


// id_prop_class

const id_prop_class::TypeClass id_prop_class::Type(
    "http://example.org/id-prop-class",
    "id-prop-class",
    "testid",
    NodeKind::BlankNodeOrIRI,
    false
);

id_prop_class::id_prop_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

id_prop_class::~id_prop_class() {}


// inherited_id_prop_class

const inherited_id_prop_class::TypeClass inherited_id_prop_class::Type(
    "http://example.org/inherited-id-prop-class",
    "inherited-id-prop-class",
    "testid",
    NodeKind::BlankNodeOrIRI,
    false
);

inherited_id_prop_class::inherited_id_prop_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    id_prop_class(type, typeIRIs)
{}

inherited_id_prop_class::~inherited_id_prop_class() {}


// link_class

const link_class::TypeClass link_class::Type(
    "http://example.org/link-class",
    "link-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

link_class::link_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs),
    _link_class_extensible(
        this,
        "http://example.org/link-class-extensible",
        "link-class-extensible",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    ),
    _link_class_link_list_prop(
        this,
        "http://example.org/link-class-link-list-prop",
        "link-class-link-list-prop",
        {},
        {},
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    ),
    _link_class_link_prop(
        this,
        "http://example.org/link-class-link-prop",
        "link-class-link-prop",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    ),
    _link_class_link_prop_no_class(
        this,
        "http://example.org/link-class-link-prop-no-class",
        "link-class-link-prop-no-class",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    )
{}

link_class::~link_class() {}


// link_derived_class

const link_derived_class::TypeClass link_derived_class::Type(
    "http://example.org/link-derived-class",
    "link-derived-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

link_derived_class::link_derived_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    link_class(type, typeIRIs)
{}

link_derived_class::~link_derived_class() {}


// node_kind_blank

const node_kind_blank::TypeClass node_kind_blank::Type(
    "http://example.org/node-kind-blank",
    "node-kind-blank",
    {},
    NodeKind::BlankNode,
    false
);

node_kind_blank::node_kind_blank(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    link_class(type, typeIRIs)
{}

node_kind_blank::~node_kind_blank() {}


// node_kind_iri

const node_kind_iri::TypeClass node_kind_iri::Type(
    "http://example.org/node-kind-iri",
    "node-kind-iri",
    {},
    NodeKind::IRI,
    false
);

node_kind_iri::node_kind_iri(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    link_class(type, typeIRIs)
{}

node_kind_iri::~node_kind_iri() {}


// node_kind_iri_or_blank

const node_kind_iri_or_blank::TypeClass node_kind_iri_or_blank::Type(
    "http://example.org/node-kind-iri-or-blank",
    "node-kind-iri-or-blank",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

node_kind_iri_or_blank::node_kind_iri_or_blank(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    link_class(type, typeIRIs)
{}

node_kind_iri_or_blank::~node_kind_iri_or_blank() {}


// non_shape_class

const non_shape_class::TypeClass non_shape_class::Type(
    "http://example.org/non-shape-class",
    "non-shape-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

non_shape_class::non_shape_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

non_shape_class::~non_shape_class() {}


// parent_class

const parent_class::TypeClass parent_class::Type(
    "http://example.org/parent-class",
    "parent-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

parent_class::parent_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

parent_class::~parent_class() {}


// required_abstract

const required_abstract::TypeClass required_abstract::Type(
    "http://example.org/required-abstract",
    "required-abstract",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

required_abstract::required_abstract(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs),
    _required_abstract_abstract_class_prop(
        this,
        "http://example.org/required-abstract/abstract-class-prop",
        "required-abstract/abstract-class-prop",
        true,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    )
{}

required_abstract::~required_abstract() {}


// test_another_class

const test_another_class::TypeClass test_another_class::Type(
    "http://example.org/test-another-class",
    "test-another-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

test_another_class::test_another_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs)
{}

test_another_class::~test_another_class() {}


// test_class

const test_class::TypeClass test_class::Type(
    "http://example.org/test-class",
    "test-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

test_class::test_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    parent_class(type, typeIRIs),
    _encode(
        this,
        "http://example.org/encode",
        "encode",
        false,
        std::optional<std::regex>()
    ),
    _import(
        this,
        "http://example.org/import",
        "import",
        false,
        std::optional<std::regex>()
    ),
    _test_class_anyuri_prop(
        this,
        "http://example.org/test-class/anyuri-prop",
        "test-class/anyuri-prop",
        false,
        std::optional<std::regex>()
    ),
    _test_class_boolean_prop(
        this,
        "http://example.org/test-class/boolean-prop",
        "test-class/boolean-prop",
        false,
        std::optional<std::regex>()
    ),
    _test_class_class_list_prop(
        this,
        "http://example.org/test-class/class-list-prop",
        "test-class/class-list-prop",
        {},
        {},
        std::optional<std::regex>(),
        PropertyContext::Context({
            {"http://example.org/test-class/named", "named"},
        })
    ),
    _test_class_class_prop(
        this,
        "http://example.org/test-class/class-prop",
        "test-class/class-prop",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
            {"http://example.org/test-class/named", "named"},
        })
    ),
    _test_class_class_prop_no_class(
        this,
        "http://example.org/test-class/class-prop-no-class",
        "test-class/class-prop-no-class",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
            {"http://example.org/test-class/named", "named"},
        })
    ),
    _test_class_datetime_list_prop(
        this,
        "http://example.org/test-class/datetime-list-prop",
        "test-class/datetime-list-prop",
        {},
        {},
        std::optional<std::regex>()
    ),
    _test_class_datetime_scalar_prop(
        this,
        "http://example.org/test-class/datetime-scalar-prop",
        "test-class/datetime-scalar-prop",
        false,
        std::optional<std::regex>()
    ),
    _test_class_datetimestamp_scalar_prop(
        this,
        "http://example.org/test-class/datetimestamp-scalar-prop",
        "test-class/datetimestamp-scalar-prop",
        false,
        std::optional<std::regex>()
    ),
    _test_class_enum_list_prop(
        this,
        "http://example.org/test-class/enum-list-prop",
        "test-class/enum-list-prop",
        {},
        {},
        std::optional<std::regex>(),
        std::unordered_set<std::string>({
            "http://example.org/enumType/bar",
            "http://example.org/enumType/foo",
            "http://example.org/enumType/nolabel",
            "http://example.org/enumType/non-named-individual"
        }),
        PropertyContext::Context({
            {"http://example.org/enumType/bar", "bar"},
            {"http://example.org/enumType/foo", "foo"},
            {"http://example.org/enumType/nolabel", "nolabel"},
            {"http://example.org/enumType/non-named-individual", "non-named-individual"},
        })
    ),
    _test_class_enum_prop(
        this,
        "http://example.org/test-class/enum-prop",
        "test-class/enum-prop",
        false,
        std::optional<std::regex>(),
        std::unordered_set<std::string>({
            "http://example.org/enumType/bar",
            "http://example.org/enumType/foo",
            "http://example.org/enumType/nolabel",
            "http://example.org/enumType/non-named-individual"
        }),
        PropertyContext::Context({
            {"http://example.org/enumType/bar", "bar"},
            {"http://example.org/enumType/foo", "foo"},
            {"http://example.org/enumType/nolabel", "nolabel"},
            {"http://example.org/enumType/non-named-individual", "non-named-individual"},
        })
    ),
    _test_class_enum_prop_no_class(
        this,
        "http://example.org/test-class/enum-prop-no-class",
        "test-class/enum-prop-no-class",
        false,
        std::optional<std::regex>(),
        std::unordered_set<std::string>({
            "http://example.org/enumType/bar",
            "http://example.org/enumType/foo",
            "http://example.org/enumType/nolabel",
            "http://example.org/enumType/non-named-individual"
        }),
        PropertyContext::Context({
            {"http://example.org/enumType/bar", "bar"},
            {"http://example.org/enumType/foo", "foo"},
            {"http://example.org/enumType/nolabel", "nolabel"},
            {"http://example.org/enumType/non-named-individual", "non-named-individual"},
        })
    ),
    _test_class_float_prop(
        this,
        "http://example.org/test-class/float-prop",
        "test-class/float-prop",
        false,
        std::optional<std::regex>()
    ),
    _test_class_integer_prop(
        this,
        "http://example.org/test-class/integer-prop",
        "test-class/integer-prop",
        false,
        std::optional<std::regex>()
    ),
    _named_property(
        this,
        "http://example.org/test-class/named-property",
        "test-class/named-property",
        false,
        std::optional<std::regex>()
    ),
    _test_class_non_shape(
        this,
        "http://example.org/test-class/non-shape",
        "test-class/non-shape",
        false,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    ),
    _test_class_nonnegative_integer_prop(
        this,
        "http://example.org/test-class/nonnegative-integer-prop",
        "test-class/nonnegative-integer-prop",
        false,
        std::optional<std::regex>(),
        0
    ),
    _test_class_positive_integer_prop(
        this,
        "http://example.org/test-class/positive-integer-prop",
        "test-class/positive-integer-prop",
        false,
        std::optional<std::regex>(),
        1
    ),
    _test_class_regex(
        this,
        "http://example.org/test-class/regex",
        "test-class/regex",
        false,
        std::regex(R"REGEX(^foo\d)REGEX")
    ),
    _test_class_regex_datetime(
        this,
        "http://example.org/test-class/regex-datetime",
        "test-class/regex-datetime",
        false,
        std::regex(R"REGEX(^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d\+01:00$)REGEX")
    ),
    _test_class_regex_datetimestamp(
        this,
        "http://example.org/test-class/regex-datetimestamp",
        "test-class/regex-datetimestamp",
        false,
        std::regex(R"REGEX(^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$)REGEX")
    ),
    _test_class_regex_list(
        this,
        "http://example.org/test-class/regex-list",
        "test-class/regex-list",
        {},
        {},
        std::regex(R"REGEX(^foo\d)REGEX")
    ),
    _test_class_string_list_no_datatype(
        this,
        "http://example.org/test-class/string-list-no-datatype",
        "test-class/string-list-no-datatype",
        {},
        {},
        std::optional<std::regex>()
    ),
    _test_class_string_list_prop(
        this,
        "http://example.org/test-class/string-list-prop",
        "test-class/string-list-prop",
        {},
        {},
        std::optional<std::regex>()
    ),
    _test_class_string_scalar_prop(
        this,
        "http://example.org/test-class/string-scalar-prop",
        "test-class/string-scalar-prop",
        false,
        std::optional<std::regex>()
    )
{}

test_class::~test_class() {}
const NamedIndividual test_class::named(
    &test_class::Type,
    "http://example.org/test-class/named",
    "named"
);


// test_class_required

const test_class_required::TypeClass test_class_required::Type(
    "http://example.org/test-class-required",
    "test-class-required",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

test_class_required::test_class_required(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    test_class(type, typeIRIs),
    _test_class_required_string_list_prop(
        this,
        "http://example.org/test-class/required-string-list-prop",
        "test-class/required-string-list-prop",
        1,
        2,
        std::optional<std::regex>()
    ),
    _test_class_required_string_scalar_prop(
        this,
        "http://example.org/test-class/required-string-scalar-prop",
        "test-class/required-string-scalar-prop",
        true,
        std::optional<std::regex>()
    )
{}

test_class_required::~test_class_required() {}


// test_derived_class

const test_derived_class::TypeClass test_derived_class::Type(
    "http://example.org/test-derived-class",
    "test-derived-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

test_derived_class::test_derived_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    test_class(type, typeIRIs),
    _test_derived_class_string_prop(
        this,
        "http://example.org/test-derived-class/string-prop",
        "test-derived-class/string-prop",
        false,
        std::optional<std::regex>()
    )
{}

test_derived_class::~test_derived_class() {}


// uses_extensible_abstract_class

const uses_extensible_abstract_class::TypeClass uses_extensible_abstract_class::Type(
    "http://example.org/uses-extensible-abstract-class",
    "uses-extensible-abstract-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

uses_extensible_abstract_class::uses_extensible_abstract_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLObject(type, typeIRIs),
    _uses_extensible_abstract_class_prop(
        this,
        "http://example.org/uses-extensible-abstract-class/prop",
        "uses-extensible-abstract-class/prop",
        true,
        std::optional<std::regex>(),
        PropertyContext::Context({
        })
    )
{}

uses_extensible_abstract_class::~uses_extensible_abstract_class() {}


// aaa_derived_class

const aaa_derived_class::TypeClass aaa_derived_class::Type(
    "http://example.org/aaa-derived-class",
    "aaa-derived-class",
    {},
    NodeKind::BlankNodeOrIRI,
    false
);

aaa_derived_class::aaa_derived_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    parent_class(type, typeIRIs)
{}

aaa_derived_class::~aaa_derived_class() {}


// derived_node_kind_iri

const derived_node_kind_iri::TypeClass derived_node_kind_iri::Type(
    "http://example.org/derived-node-kind-iri",
    "derived-node-kind-iri",
    {},
    NodeKind::IRI,
    false
);

derived_node_kind_iri::derived_node_kind_iri(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    node_kind_iri(type, typeIRIs)
{}

derived_node_kind_iri::~derived_node_kind_iri() {}


// extensible_class

const extensible_class::TypeClass extensible_class::Type(
    "http://example.org/extensible-class",
    "extensible-class",
    {},
    NodeKind::BlankNodeOrIRI,
    true
);

extensible_class::extensible_class(TypeBase const* type, SHACLObject::TypeIRIs const& typeIRIs) :
    SHACLExtensibleObject<link_class>(type, typeIRIs),
    _extensible_class_property(
        this,
        "http://example.org/extensible-class/property",
        "extensible-class/property",
        false,
        std::optional<std::regex>()
    ),
    _extensible_class_required(
        this,
        "http://example.org/extensible-class/required",
        "extensible-class/required",
        true,
        std::optional<std::regex>()
    )
{}

extensible_class::~extensible_class() {}

#endif

// clang-format on

/* */
}
/* */
