#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# This file was automatically generated by shacl2code. DO NOT MANUALLY MODIFY IT
#
# SPDX-License-Identifier: MIT

import functools
import hashlib
import json
import re
import time
from contextlib import contextmanager
from datetime import datetime, timezone
from enum import Enum
from abc import ABC, abstractmethod


def check_type(obj, types):
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj)}"
            )
        raise TypeError(f"Value must be of type {types.__name__}. Got {type(obj)}")


class Property(ABC):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    def __init__(self, *, pattern=None):
        self.pattern = pattern

    def init(self):
        return None

    def validate(self, value):
        check_type(value, self.VALID_TYPES)
        if self.pattern is not None and not re.search(self.pattern, self.set(value)):
            raise ValueError(f"Value is not correctly formatted. Got '{value}'")

    def set(self, value):
        return value

    def check_min_count(self, value, min_count):
        return min_count == 1

    def check_max_count(self, value, max_count):
        return max_count == 1

    def elide(self, value):
        return value is None

    def walk(self, value, callback, path):
        callback(value, path)

    def link_prop(self, value, link_cache, missing, visited):
        return value

    @abstractmethod
    def encode(self, encoder, value):
        pass

    @abstractmethod
    def decode(self, decoder, *, object_ids=None):
        pass


class StringProp(Property):
    """
    A scalar string property for an SHACL object
    """

    VALID_TYPES = str

    def set(self, value):
        return str(value)

    def encode(self, encoder, value):
        encoder.write_string(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_string()


class AnyURIProp(StringProp):
    def encode(self, encoder, value):
        encoder.write_iri(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_iri()


class DateTimeProp(Property):
    """
    A Date/Time Object
    """

    VALID_TYPES = datetime
    FORMAT_STR = "%Y-%m-%dT%H:%M:%SZ"

    def set(self, value):
        return value.astimezone(timezone.utc)

    def encode(self, encoder, value):
        encoder.write_datetime(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_datetime()

    @classmethod
    def to_string(cls, value):
        return value.astimezone(timezone.utc).strftime(cls.FORMAT_STR)

    @classmethod
    def from_string(cls, value):
        return datetime(
            *(time.strptime(value, cls.FORMAT_STR)[0:6]),
            tzinfo=timezone.utc,
        )


class IntegerProp(Property):
    VALID_TYPES = int

    def set(self, value):
        return int(value)

    def encode(self, encoder, value):
        encoder.write_integer(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_integer()


class PositiveIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property):
    VALID_TYPES = bool

    def set(self, value):
        return bool(value)

    def encode(self, encoder, value):
        encoder.write_bool(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_bool()


class FloatProp(Property):
    VALID_TYPES = (float, int)

    def set(self, value):
        return float(value)

    def encode(self, encoder, value):
        encoder.write_float(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_float()


class ObjectProp(Property):
    """
    A scalar SHACL object property of a SHACL object
    """

    def __init__(self, cls, required):
        super().__init__()
        self.cls = cls
        self.required = required

    def init(self):
        if self.required:
            return self.cls()
        return None

    def validate(self, value):
        check_type(value, (self.cls, str))

    def walk(self, value, callback, path):
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def encode(self, encoder, value):
        if value is None:
            raise ValueError("Object cannot be None")

        if isinstance(value, str):
            encoder.write_iri(value)
            return

        return value.encode(encoder, is_reference=True)

    def decode(self, decoder, *, object_ids=None):
        iri = decoder.read_iri()
        if iri is not None:
            if object_ids and iri in object_ids:
                return object_ids[iri]
            return iri

        return SHACLObject.deserialize(decoder, object_ids=object_ids)

    def link_prop(self, value, link_cache, missing, visited):
        if value is None:
            return value

        if isinstance(value, str):
            if value in link_cache:
                return link_cache[value]

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id and value._id is not link_cache[value._id]:
            value = link_cache[value._id]

        value.link_helper(link_cache, missing, visited)
        return value


class ListProxy(object):
    def __init__(self, prop, data=None):
        if data is None:
            self.__data = []
        else:
            self.__data = data
        self.__prop = prop

    def append(self, value):
        self.__prop.validate(value)
        self.__data.append(self.__prop.set(value))

    def insert(self, idx, value):
        self.__prop.validate(value)
        self.__data.insert(idx, self.__prop.set(value))

    def extend(self, items):
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs):
        self.__data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        if isinstance(key, slice):
            for v in value:
                self.__prop.validate(v)
            self.__data[key] = [self.__prop.set(v) for v in value]
        else:
            self.__prop.validate(value)
            self.__data[key] = self.__prop.set(value)

    def __delitem__(self, key):
        del self.__data[key]

    def __contains__(self, item):
        return item in self.__data

    def __iter__(self):
        return iter(self.__data)

    def __len__(self):
        return len(self.__data)

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)

    def __eq__(self, other):
        if isinstance(other, ListProxy):
            return self.__data == other.__data

        return self.__data == other


class ListProp(Property):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    def __init__(self, prop):
        super().__init__()
        self.prop = prop

    def init(self):
        return ListProxy(self.prop)

    def validate(self, value):
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(self, value):
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, [self.prop.set(d) for d in value])

    def check_min_count(self, value, min_count):
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value, max_count):
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value):
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(self, value, callback, path):
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def link_prop(self, value, link_cache, missing, visited):
        if isinstance(value, ListProxy):
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]
        else:
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]

        return ListProxy(self.prop, data=data)

    def encode(self, encoder, value):
        check_type(value, ListProxy)

        with encoder.write_list() as list_s:
            for v in value:
                with list_s.write_list_item() as item_s:
                    self.prop.encode(item_s, v)

    def decode(self, decoder, *, object_ids=None):
        data = []
        for val_d in decoder.read_list():
            v = self.prop.decode(val_d, object_ids=object_ids)
            self.prop.validate(v)
            data.append(v)

        return ListProxy(self.prop, data=data)


class EnumProp(Property):
    VALID_TYPES = str

    def validate(self, value):
        super().validate(value)

        if value not in (v for _, v in self.valid_values):
            raise ValueError(
                f"'{value}' is not a valid value for '{self.__class__.__name__}'"
            )

    def encode(self, encoder, value):
        encoder.write_enum(value, self)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_enum(self)


class Refable(Enum):
    no = 1
    local = 2
    optional = 3
    yes = 4
    always = 5


@functools.total_ordering
class SHACLObject(object):
    DESERIALIZERS = {}
    REFABLE = Refable.optional
    ID_ALIAS = None

    def __init__(self):
        self._obj_data = {}
        self._obj_properties = {}
        self._obj_iris = {}
        self._obj_written = False
        self._obj_metadata = {}

        self._add_property("_id", StringProp(), iri="@id")

    def _set_init_props(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def _add_property(
        self,
        pyname,
        prop,
        iri,
        min_count=None,
        max_count=None,
    ):
        if pyname in self._obj_iris:
            raise KeyError(
                f"'{pyname}' is already defined for '{self.__class__.__name__}'"
            )
        if iri in self._obj_properties:
            raise KeyError(
                f"'{iri}' is already defined for '{self.__class__.__name__}'"
            )

        self._obj_iris[pyname] = iri
        self._obj_properties[iri] = (prop, min_count, max_count, pyname)
        self._obj_data[iri] = prop.init()

    def __setattr__(self, name, value):
        if name.startswith("_obj_"):
            return super().__setattr__(name, value)

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            self[iri] = value
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __getattr__(self, name):
        if name.startswith("_obj_"):
            return self.__dict__[name]

        if name == "_metadata":
            return self._obj_metadata

        if name == "_IRI":
            return self._obj_iris

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            return self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __delattr__(self, name):
        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            del self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __get_prop(self, iri):
        if iri not in self._obj_properties:
            raise KeyError(
                f"'{iri}' is not a valid property of {self.__class__.__name__}"
            )

        return self._obj_properties[iri]

    def __iter_props(self):
        for iri, v in self._obj_properties.items():
            prop, min_count, max_count, pyname = v
            yield iri, prop, min_count, max_count, pyname

    def __getitem__(self, iri):
        return self._obj_data[iri]

    def __setitem__(self, iri, value):
        if iri == "@id":
            if self.REFABLE == Refable.no:
                raise ValueError(
                    "{self.__class__.__name__} ({id(self)}) is not referenceable. Property '{iri}' cannot be set to '{value}'"
                )
            elif self.REFABLE == Refable.local:
                if not value.startswith("_:"):
                    raise ValueError(
                        "{self.__class__.__name__} ({id(self)}) can only have local reference. Property '{iri}' cannot be set to '{value}' and must start with '_:'"
                    )
            elif self.REFABLE in [Refable.yes, Refable.always]:
                if value.startswith("_:"):
                    raise ValueError(
                        "{self.__class__.__name__} ({id(self)}) can has mandatory reference. Property '{iri}' cannot be set to '{value}'"
                    )

        prop, _, _, _ = self.__get_prop(iri)
        prop.validate(value)
        self._obj_data[iri] = prop.set(value)

    def __delitem__(self, iri):
        prop, _, _, _ = self.__get_prop(iri)
        self._obj_data[iri] = prop.init()

    def __iter__(self):
        return self._obj_properties.keys()

    def walk(self, callback, path=None):
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(object, path):
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for iri, prop, _, _, _ in self.__iter_props():
                prop.walk(self._obj_data[iri], callback, path + [f".{iri}"])

    def child_objects(self):
        """
        Iterate over each object that is a child of this one
        """
        seen = set()

        def _walk_callback(value, path):
            nonlocal seen

            if not isinstance(value, SHACLObject):
                return False

            if value in seen:
                return False

            seen.add(value)
            return True

        self.walk(_walk_callback)

        for obj in seen:
            yield obj

    def encode(self, encoder, *, is_reference=False):
        idname = self.ID_ALIAS or self._obj_iris["_id"]
        if self._id is not None and self.REFABLE == Refable.no:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) is not referenceable. Property '{idname}' must not be defined (currently '{self._id}')"
            )

        if not self._id and self.REFABLE in [Refable.yes, Refable.always]:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must have a '{idname}' property to be referenceable"
            )

        if self._id and self._obj_written:
            encoder.write_iri(self._id)
            return

        if is_reference and self.REFABLE == Refable.always:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must always be referenced by name, and cannot be inlined"
            )

        self._obj_written = True

        with encoder.write_object(self) as obj_s:
            for iri, prop, min_count, max_count, pyname in self.__iter_props():
                value = self._obj_data[iri]
                if prop.elide(value):
                    if min_count:
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) is required (currently {value!r})"
                        )
                    continue

                if min_count is not None:
                    if not prop.check_min_count(value, min_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a minimum of {min_count} elements"
                        )

                if max_count is not None:
                    if not prop.check_max_count(value, max_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a maximum of {max_count} elements"
                        )

                if iri == self._obj_iris["_id"]:
                    continue

                with obj_s.write_property(iri) as prop_s:
                    prop.encode(prop_s, value)

    @classmethod
    def decode(cls, decoder, *, object_ids=None):
        typ, obj_d = decoder.read_object()
        if typ is None:
            raise TypeError("Unable to determine type for object")

        if typ not in cls.DESERIALIZERS:
            raise TypeError(f"Unknown type {typ}")

        obj = cls.DESERIALIZERS[typ]()
        _id = obj_d.read_object_id(obj.ID_ALIAS)
        if _id is not None:
            if object_ids is not None:
                if _id in object_ids:
                    return object_ids[_id]
                object_ids[_id] = obj
            obj._id = _id

        for iri, prop, _, _, _ in obj.__iter_props():
            if iri == obj._obj_iris["_id"]:
                continue

            prop_d = obj_d.read_property(iri)
            if prop_d is None:
                continue

            v = prop.decode(prop_d, object_ids=object_ids)
            prop.validate(v)
            obj._obj_data[iri] = v

        return obj

    def link_helper(self, link_cache, missing, visited):
        if self in visited:
            return

        visited.add(self)

        for iri, prop, _, _, _ in self.__iter_props():
            self._obj_data[iri] = prop.link_prop(
                self._obj_data[iri],
                link_cache,
                missing,
                visited,
            )

    def link(self, link_cache=None):
        if not link_cache:
            link_cache = {obj._id: obj for obj in self.child_objects() if obj._id}

        missing = set()
        visited = set()

        self.link_helper(link_cache, missing, visited)

        return missing

    def __str__(self):
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self):
        return super().__hash__()

    def __eq__(self, other):
        return super().__eq__(other)

    def __lt__(self, other):
        def sort_key(obj):
            if isinstance(obj, str):
                return (obj, "", "", "")
            return (
                obj._id or "",
                obj.TYPE,
                getattr(obj, "name", None) or "",
                id(obj),
            )

        return sort_key(self) < sort_key(other)


def make_context():
    global CONTEXTS
    return Context(CONTEXTS)


def encode_objects(encoder, objects, force_list=False):
    """
    Serialize a list of objects to a serialization encoder

    If force_list is true, a list will always be written using the encoder.
    """
    ref_counts = {}
    id_objects = set()

    def walk_callback(value, path):
        nonlocal ref_counts

        if not isinstance(value, SHACLObject):
            return True

        value._obj_written = False

        # Remove blank node ID for re-assignment
        if value._id and value._id.startswith("_:"):
            del value._id

        if value._id or value.REFABLE == Refable.always:
            id_objects.add(value)

        ref_counts.setdefault(value, 0)
        ref_counts[value] += 1
        if ref_counts[value] > 1:
            id_objects.add(value)
            return False

        return True

    for o in objects:
        o.walk(walk_callback)

    for idx, o in enumerate(id_objects):
        if not o._id:
            o._id = f"_:{o.__class__.__name__}{idx}"

    use_list = force_list or len(objects) > 1

    objects = set(objects)

    if use_list:
        # If we are making a list, put all ID objects in the root
        objects |= id_objects

    objects = list(objects)
    objects.sort()

    if use_list:
        # Ensure top level objects are only written in the top level graph
        # node, and referenced by ID everywhere else. This is done by setting
        # the flag that indicates this object has been written for all the top
        # level objects, then clearing it right before serializing the object.
        #
        # In this way, if an object is referenced before it is supposed to be
        # serialized into the @graph, it will serialize as a string instead of
        # the actual object
        for o in objects:
            o._obj_written = True

        with encoder.write_list() as list_s:
            for o in objects:
                # Allow this specific object to be written now
                o._obj_written = False
                with list_s.write_list_item() as item_s:
                    o.encode(item_s)

    else:
        objects[0].encode(encoder)


def decode_objects(decoder):
    object_ids = {}
    objects = [
        SHACLObject.decode(obj_d, object_ids=object_ids)
        for obj_d in decoder.read_list()
    ]

    for o in objects:
        o.link(object_ids)

    # Remove blank node IDs
    for o in objects:
        for c in o.child_objects():
            if c._id and c._id.startswith("_:"):
                del c._id

    object_ids = {k: v for k, v in object_ids.items() if not k.startswith("_:")}

    return objects, object_ids


class Decoder(ABC):
    @abstractmethod
    def read_string(self):
        pass

    @abstractmethod
    def read_integer(self):
        pass

    @abstractmethod
    def read_iri(self):
        pass

    @abstractmethod
    def read_enum(self, e):
        pass

    @abstractmethod
    def read_bool(self):
        pass

    @abstractmethod
    def read_float(self):
        pass

    @abstractmethod
    def read_list(self):
        pass

    @abstractmethod
    def read_property(self, iri):
        pass

    @abstractmethod
    def read_object(self):
        pass

    @abstractmethod
    def read_object_id(self, alias=None):
        pass


class JSONLDDeserializer(object):
    class Helper(Decoder):
        def __init__(self, data, context):
            self.data = data
            self.context = context

        def read_string(self):
            if isinstance(self.data, str):
                return self.data
            return None

        def read_datetime(self):
            if isinstance(self.data, str):
                return DateTimeProp.from_string(self.data)
            return None

        def read_integer(self):
            if isinstance(self.data, int):
                return self.data
            return None

        def read_bool(self):
            if isinstance(self.data, bool):
                return self.data
            return None

        def read_float(self):
            if isinstance(self.data, (int, float)):
                return float(self.data)
            return None

        def read_iri(self):
            if isinstance(self.data, str):
                return self.context.expand(self.data)
            return None

        def read_enum(self, e):
            if isinstance(self.data, str):
                return self.context.expand_vocab(self.data)
            return None

        def read_list(self):
            if isinstance(self.data, (list, tuple, set)):
                for v in self.data:
                    yield self.__class__(v, self.context)
            else:
                yield self

        def read_property(self, iri):
            for k in (iri, self.context.compact(iri)):
                if k in self.data:
                    return self.__class__(self.data[k], self.context)

            return None

        def read_object(self):
            for k in ("@type", self.context.compact("@type")):
                if k not in self.data:
                    continue

                typ = self.context.expand(self.data[k])
                return typ, self

            return None, self

        def read_object_id(self, alias=None):
            if alias and alias in self.data:
                return self.data[alias]

            for k in ("@id", self.context.compact("@id")):
                if k in self.data:
                    return self.data[k]

            return None

    def read(self, f):
        context = make_context()
        data = json.load(f)
        if "@graph" in data:
            h = self.Helper(data["@graph"], context)
        else:
            h = self.Helper(data, context)

        return decode_objects(h)


class Encoder(ABC):
    @abstractmethod
    def write_string(self, v):
        pass

    @abstractmethod
    def write_datetime(self, v):
        pass

    @abstractmethod
    def write_integer(self, v):
        pass

    @abstractmethod
    def write_iri(self, v):
        pass

    @abstractmethod
    def write_enum(self, v, e):
        pass

    @abstractmethod
    def write_bool(self, v):
        pass

    @abstractmethod
    def write_float(self, v):
        pass

    @abstractmethod
    @contextmanager
    def write_property(self, iri):
        pass

    @abstractmethod
    @contextmanager
    def write_object(self, o):
        pass

    @abstractmethod
    @contextmanager
    def write_list(self):
        pass

    @abstractmethod
    @contextmanager
    def write_list_item(self):
        pass


class JSONLDSerializer(object):
    class Helper(Encoder):
        def __init__(self, context, data=None):
            self.data = data
            if context is None:
                self.context = make_context()
            else:
                self.context = context

        def write_string(self, v):
            self.data = v

        def write_datetime(self, v):
            self.data = DateTimeProp.to_string(v)

        def write_integer(self, v):
            self.data = v

        def write_iri(self, v):
            self.write_string(self.context.compact(v))

        def write_enum(self, v, e):
            self.write_string(self.context.compact_vocab(v))

        def write_bool(self, v):
            self.data = v

        def write_float(self, v):
            self.data = v

        @contextmanager
        def write_property(self, iri):
            s = self.__class__(self.context, None)
            with self.context.vocab_push(iri):
                yield s
            if s.data is not None:
                self.data[self.context.compact(iri)] = s.data

        @contextmanager
        def write_object(self, o):
            self.data = {
                self.context.compact("@type"): self.context.compact(o.TYPE),
            }
            if o._id:
                self.data[o.ID_ALIAS or o._IRI["_id"]] = self.context.compact(o._id)
            yield self

        @contextmanager
        def write_list(self):
            self.data = []
            yield self
            if not self.data:
                self.data = None

        @contextmanager
        def write_list_item(self):
            s = self.__class__(self.context, None)
            yield s
            if s.data is not None:
                self.data.append(s.data)

    def serialize_data(self, objects, force_graph=False):
        context = make_context()
        h = self.Helper(context)
        encode_objects(h, objects, force_graph)
        if isinstance(h.data, list):
            data = {
                "@graph": h.data,
            }
        else:
            data = h.data

        if len(CONTEXT_URLS) == 1:
            data["@context"] = CONTEXT_URLS[0]
        elif CONTEXT_URLS:
            data["@context"] = CONTEXT_URLS

        return data

    def write(self, objects, f, force_graph=False, **kwargs):
        """
        Write a list of objects to a JSON LD file

        If force_graph is True, a @graph node will always be written
        """
        data = self.serialize_data(objects, force_graph)

        sha1 = hashlib.sha1()
        for chunk in json.JSONEncoder(**kwargs).iterencode(data):
            chunk = chunk.encode("utf-8")
            f.write(chunk)
            sha1.update(chunk)

        return sha1.hexdigest()


class JSONLDInlineSerializer(object):
    class Helper(Encoder):
        def __init__(self, f, context, sha1):
            self.f = f
            self.context = context
            self.comma = False
            self.sha1 = sha1

        def write(self, s):
            s = s.encode("utf-8")
            self.f.write(s)
            self.sha1.update(s)

        def _write_comma(self):
            if self.comma:
                self.write(",")
                self.comma = False

        def _need_comma(self):
            self.comma = True

        def write_string(self, v):
            self.write(f'"{v}"')

        def write_datetime(self, v):
            self.write('"' + DateTimeProp.to_string(v) + '"')

        def write_integer(self, v):
            self.write(f"{v}")

        def write_iri(self, v):
            self.write_string(self.context.compact(v))

        def write_enum(self, v, e):
            self.write_iri(v)

        def write_bool(self, v):
            if v:
                self.write("true")
            else:
                self.write("false")

        def write_float(self, v):
            self.write(f"{v}")

        @contextmanager
        def write_property(self, iri):
            self._write_comma()
            p = self.context.compact(iri)
            self.write(f'"{p}":')
            with self.context.vocab_push(iri):
                yield self
            self.comma = True

        @contextmanager
        def write_object(self, o):
            self._write_comma()

            typname = self.context.compact("@type")
            typval = self.context.compact(o.TYPE)
            self.write("{")
            if o._id:
                idname = o.ID_ALIAS or o._IRI["_id"]
                idval = self.context.compact(o._id)
                self.write(f'"{idname}": "{idval}",')
            self.write(f'"{typname}":"{typval}"')

            self.comma = True
            yield self

            self.write("}")
            self.comma = True

        @contextmanager
        def write_list(self):
            self._write_comma()
            self.write("[")
            yield self.__class__(self.f, self.context, self.sha1)
            self.write("]")
            self.comma = True

        @contextmanager
        def write_list_item(self):
            self._write_comma()
            yield self.__class__(self.f, self.context, self.sha1)
            self.comma = True

    def write(self, objects, f):
        """
        Write a list of objects to a JSON LD file
        """
        sha1 = hashlib.sha1()
        h = self.Helper(f, make_context(), sha1)
        h.write('{"@context":')
        if len(CONTEXT_URLS) == 1:
            h.write(f'"{CONTEXT_URLS[0]}"')
        elif CONTEXT_URLS:
            h.write('["')
            h.write('","'.join(CONTEXT_URLS))
            h.write('"]')
        h.write(",")

        h.write('"@graph":')

        encode_objects(h, objects, True)
        h.write("}")
        return sha1.hexdigest()


def print_tree(objects, all_fields=False):
    """
    Print object tree
    """
    seen = set()

    def callback(value, path):
        nonlocal seen

        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard"""

CONTEXTS = [
    {
        "Agent": "https://rdf.spdx.org/v3/Core/Agent",
        "Annotation": "https://rdf.spdx.org/v3/Core/Annotation",
        "AnnotationType": "https://rdf.spdx.org/v3/Core/AnnotationType",
        "Artifact": "https://rdf.spdx.org/v3/Core/Artifact",
        "Bom": "https://rdf.spdx.org/v3/Core/Bom",
        "Bundle": "https://rdf.spdx.org/v3/Core/Bundle",
        "CreationInfo": "https://rdf.spdx.org/v3/Core/CreationInfo",
        "DictionaryEntry": "https://rdf.spdx.org/v3/Core/DictionaryEntry",
        "Element": "https://rdf.spdx.org/v3/Core/Element",
        "ElementCollection": "https://rdf.spdx.org/v3/Core/ElementCollection",
        "ExternalIdentifier": "https://rdf.spdx.org/v3/Core/ExternalIdentifier",
        "ExternalIdentifierType": "https://rdf.spdx.org/v3/Core/ExternalIdentifierType",
        "ExternalMap": "https://rdf.spdx.org/v3/Core/ExternalMap",
        "ExternalRef": "https://rdf.spdx.org/v3/Core/ExternalRef",
        "ExternalRefType": "https://rdf.spdx.org/v3/Core/ExternalRefType",
        "Hash": "https://rdf.spdx.org/v3/Core/Hash",
        "HashAlgorithm": "https://rdf.spdx.org/v3/Core/HashAlgorithm",
        "IntegrityMethod": "https://rdf.spdx.org/v3/Core/IntegrityMethod",
        "LifecycleScopeType": "https://rdf.spdx.org/v3/Core/LifecycleScopeType",
        "LifecycleScopedRelationship": "https://rdf.spdx.org/v3/Core/LifecycleScopedRelationship",
        "NamespaceMap": "https://rdf.spdx.org/v3/Core/NamespaceMap",
        "Organization": "https://rdf.spdx.org/v3/Core/Organization",
        "PackageVerificationCode": "https://rdf.spdx.org/v3/Core/PackageVerificationCode",
        "Person": "https://rdf.spdx.org/v3/Core/Person",
        "PositiveIntegerRange": "https://rdf.spdx.org/v3/Core/PositiveIntegerRange",
        "PresenceType": "https://rdf.spdx.org/v3/Core/PresenceType",
        "ProfileIdentifierType": "https://rdf.spdx.org/v3/Core/ProfileIdentifierType",
        "Relationship": "https://rdf.spdx.org/v3/Core/Relationship",
        "RelationshipCompleteness": "https://rdf.spdx.org/v3/Core/RelationshipCompleteness",
        "RelationshipType": "https://rdf.spdx.org/v3/Core/RelationshipType",
        "SoftwareAgent": "https://rdf.spdx.org/v3/Core/SoftwareAgent",
        "SpdxDocument": "https://rdf.spdx.org/v3/Core/SpdxDocument",
        "SupportType": "https://rdf.spdx.org/v3/Core/SupportType",
        "Tool": "https://rdf.spdx.org/v3/Core/Tool",
        "ai_AIPackage": "https://rdf.spdx.org/v3/AI/AIPackage",
        "ai_SafetyRiskAssessmentType": "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType",
        "ai_autonomyType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/PresenceType/",
            },
            "@id": "https://rdf.spdx.org/v3/AI/autonomyType",
            "@type": "@vocab",
        },
        "ai_domain": "https://rdf.spdx.org/v3/AI/domain",
        "ai_energyConsumption": "https://rdf.spdx.org/v3/AI/energyConsumption",
        "ai_hyperparameter" : {
            "@id": "https://rdf.spdx.org/v3/AI/hyperparameter",
            "@type": "@id",
        },
        "ai_informationAboutApplication": "https://rdf.spdx.org/v3/AI/informationAboutApplication",
        "ai_informationAboutTraining": "https://rdf.spdx.org/v3/AI/informationAboutTraining",
        "ai_limitation": "https://rdf.spdx.org/v3/AI/limitation",
        "ai_metric" : {
            "@id": "https://rdf.spdx.org/v3/AI/metric",
            "@type": "@id",
        },
        "ai_metricDecisionThreshold" : {
            "@id": "https://rdf.spdx.org/v3/AI/metricDecisionThreshold",
            "@type": "@id",
        },
        "ai_modelDataPreprocessing": "https://rdf.spdx.org/v3/AI/modelDataPreprocessing",
        "ai_modelExplainability": "https://rdf.spdx.org/v3/AI/modelExplainability",
        "ai_safetyRiskAssessment" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/",
            },
            "@id": "https://rdf.spdx.org/v3/AI/safetyRiskAssessment",
            "@type": "@vocab",
        },
        "ai_sensitivePersonalInformation" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/PresenceType/",
            },
            "@id": "https://rdf.spdx.org/v3/AI/sensitivePersonalInformation",
            "@type": "@vocab",
        },
        "ai_standardCompliance": "https://rdf.spdx.org/v3/AI/standardCompliance",
        "ai_typeOfModel": "https://rdf.spdx.org/v3/AI/typeOfModel",
        "algorithm" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/HashAlgorithm/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/algorithm",
            "@type": "@vocab",
        },
        "annotationType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/AnnotationType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/annotationType",
            "@type": "@vocab",
        },
        "beginIntegerRange": "https://rdf.spdx.org/v3/Core/beginIntegerRange",
        "build_Build": "https://rdf.spdx.org/v3/Build/Build",
        "build_buildEndTime": "https://rdf.spdx.org/v3/Build/buildEndTime",
        "build_buildId": "https://rdf.spdx.org/v3/Build/buildId",
        "build_buildStartTime": "https://rdf.spdx.org/v3/Build/buildStartTime",
        "build_buildType": "https://rdf.spdx.org/v3/Build/buildType",
        "build_configSourceDigest" : {
            "@id": "https://rdf.spdx.org/v3/Build/configSourceDigest",
            "@type": "@id",
        },
        "build_configSourceEntrypoint": "https://rdf.spdx.org/v3/Build/configSourceEntrypoint",
        "build_configSourceUri": "https://rdf.spdx.org/v3/Build/configSourceUri",
        "build_environment" : {
            "@id": "https://rdf.spdx.org/v3/Build/environment",
            "@type": "@id",
        },
        "build_parameters" : {
            "@id": "https://rdf.spdx.org/v3/Build/parameters",
            "@type": "@id",
        },
        "builtTime": "https://rdf.spdx.org/v3/Core/builtTime",
        "comment": "https://rdf.spdx.org/v3/Core/comment",
        "completeness" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/completeness",
            "@type": "@vocab",
        },
        "contentType": "https://rdf.spdx.org/v3/Core/contentType",
        "context": "https://rdf.spdx.org/v3/Core/context",
        "created": "https://rdf.spdx.org/v3/Core/created",
        "createdBy" : {
            "@id": "https://rdf.spdx.org/v3/Core/createdBy",
            "@type": "@id",
        },
        "createdUsing" : {
            "@id": "https://rdf.spdx.org/v3/Core/createdUsing",
            "@type": "@id",
        },
        "creationInfo" : {
            "@id": "https://rdf.spdx.org/v3/Core/creationInfo",
            "@type": "@id",
        },
        "dataLicense" : {
            "@id": "https://rdf.spdx.org/v3/Core/dataLicense",
            "@type": "@id",
        },
        "dataset_ConfidentialityLevelType": "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType",
        "dataset_Dataset": "https://rdf.spdx.org/v3/Dataset/Dataset",
        "dataset_DatasetAvailabilityType": "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType",
        "dataset_DatasetType": "https://rdf.spdx.org/v3/Dataset/DatasetType",
        "dataset_anonymizationMethodUsed": "https://rdf.spdx.org/v3/Dataset/anonymizationMethodUsed",
        "dataset_confidentialityLevel" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/",
            },
            "@id": "https://rdf.spdx.org/v3/Dataset/confidentialityLevel",
            "@type": "@vocab",
        },
        "dataset_dataCollectionProcess": "https://rdf.spdx.org/v3/Dataset/dataCollectionProcess",
        "dataset_dataPreprocessing": "https://rdf.spdx.org/v3/Dataset/dataPreprocessing",
        "dataset_datasetAvailability" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/",
            },
            "@id": "https://rdf.spdx.org/v3/Dataset/datasetAvailability",
            "@type": "@vocab",
        },
        "dataset_datasetNoise": "https://rdf.spdx.org/v3/Dataset/datasetNoise",
        "dataset_datasetSize": "https://rdf.spdx.org/v3/Dataset/datasetSize",
        "dataset_datasetType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Dataset/DatasetType/",
            },
            "@id": "https://rdf.spdx.org/v3/Dataset/datasetType",
            "@type": "@vocab",
        },
        "dataset_datasetUpdateMechanism": "https://rdf.spdx.org/v3/Dataset/datasetUpdateMechanism",
        "dataset_intendedUse": "https://rdf.spdx.org/v3/Dataset/intendedUse",
        "dataset_knownBias": "https://rdf.spdx.org/v3/Dataset/knownBias",
        "dataset_sensitivePersonalInformation" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/PresenceType/",
            },
            "@id": "https://rdf.spdx.org/v3/Dataset/sensitivePersonalInformation",
            "@type": "@vocab",
        },
        "dataset_sensor" : {
            "@id": "https://rdf.spdx.org/v3/Dataset/sensor",
            "@type": "@id",
        },
        "definingArtifact" : {
            "@id": "https://rdf.spdx.org/v3/Core/definingArtifact",
            "@type": "@id",
        },
        "description": "https://rdf.spdx.org/v3/Core/description",
        "element" : {
            "@id": "https://rdf.spdx.org/v3/Core/element",
            "@type": "@id",
        },
        "endIntegerRange": "https://rdf.spdx.org/v3/Core/endIntegerRange",
        "endTime": "https://rdf.spdx.org/v3/Core/endTime",
        "expandedlicensing_ConjunctiveLicenseSet": "https://rdf.spdx.org/v3/ExpandedLicensing/ConjunctiveLicenseSet",
        "expandedlicensing_CustomLicense": "https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicense",
        "expandedlicensing_CustomLicenseAddition": "https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicenseAddition",
        "expandedlicensing_DisjunctiveLicenseSet": "https://rdf.spdx.org/v3/ExpandedLicensing/DisjunctiveLicenseSet",
        "expandedlicensing_ExtendableLicense": "https://rdf.spdx.org/v3/ExpandedLicensing/ExtendableLicense",
        "expandedlicensing_IndividualLicensingInfo": "https://rdf.spdx.org/v3/ExpandedLicensing/IndividualLicensingInfo",
        "expandedlicensing_License": "https://rdf.spdx.org/v3/ExpandedLicensing/License",
        "expandedlicensing_LicenseAddition": "https://rdf.spdx.org/v3/ExpandedLicensing/LicenseAddition",
        "expandedlicensing_ListedLicense": "https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicense",
        "expandedlicensing_ListedLicenseException": "https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicenseException",
        "expandedlicensing_OrLaterOperator": "https://rdf.spdx.org/v3/ExpandedLicensing/OrLaterOperator",
        "expandedlicensing_WithAdditionOperator": "https://rdf.spdx.org/v3/ExpandedLicensing/WithAdditionOperator",
        "expandedlicensing_additionText": "https://rdf.spdx.org/v3/ExpandedLicensing/additionText",
        "expandedlicensing_deprecatedVersion": "https://rdf.spdx.org/v3/ExpandedLicensing/deprecatedVersion",
        "expandedlicensing_isDeprecatedAdditionId": "https://rdf.spdx.org/v3/ExpandedLicensing/isDeprecatedAdditionId",
        "expandedlicensing_isDeprecatedLicenseId": "https://rdf.spdx.org/v3/ExpandedLicensing/isDeprecatedLicenseId",
        "expandedlicensing_isFsfLibre": "https://rdf.spdx.org/v3/ExpandedLicensing/isFsfLibre",
        "expandedlicensing_isOsiApproved": "https://rdf.spdx.org/v3/ExpandedLicensing/isOsiApproved",
        "expandedlicensing_licenseXml": "https://rdf.spdx.org/v3/ExpandedLicensing/licenseXml",
        "expandedlicensing_listVersionAdded": "https://rdf.spdx.org/v3/ExpandedLicensing/listVersionAdded",
        "expandedlicensing_member" : {
            "@id": "https://rdf.spdx.org/v3/ExpandedLicensing/member",
            "@type": "@id",
        },
        "expandedlicensing_obsoletedBy": "https://rdf.spdx.org/v3/ExpandedLicensing/obsoletedBy",
        "expandedlicensing_seeAlso": "https://rdf.spdx.org/v3/ExpandedLicensing/seeAlso",
        "expandedlicensing_standardAdditionTemplate": "https://rdf.spdx.org/v3/ExpandedLicensing/standardAdditionTemplate",
        "expandedlicensing_standardLicenseHeader": "https://rdf.spdx.org/v3/ExpandedLicensing/standardLicenseHeader",
        "expandedlicensing_standardLicenseTemplate": "https://rdf.spdx.org/v3/ExpandedLicensing/standardLicenseTemplate",
        "expandedlicensing_subjectAddition" : {
            "@id": "https://rdf.spdx.org/v3/ExpandedLicensing/subjectAddition",
            "@type": "@id",
        },
        "expandedlicensing_subjectExtendableLicense" : {
            "@id": "https://rdf.spdx.org/v3/ExpandedLicensing/subjectExtendableLicense",
            "@type": "@id",
        },
        "expandedlicensing_subjectLicense" : {
            "@id": "https://rdf.spdx.org/v3/ExpandedLicensing/subjectLicense",
            "@type": "@id",
        },
        "extension" : {
            "@id": "https://rdf.spdx.org/v3/Core/extension",
            "@type": "@id",
        },
        "extension_Extension": "https://rdf.spdx.org/v3/Extension/Extension",
        "externalIdentifier" : {
            "@id": "https://rdf.spdx.org/v3/Core/externalIdentifier",
            "@type": "@id",
        },
        "externalIdentifierType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/externalIdentifierType",
            "@type": "@vocab",
        },
        "externalRef" : {
            "@id": "https://rdf.spdx.org/v3/Core/externalRef",
            "@type": "@id",
        },
        "externalRefType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/ExternalRefType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/externalRefType",
            "@type": "@vocab",
        },
        "externalSpdxId": "https://rdf.spdx.org/v3/Core/externalSpdxId",
        "from" : {
            "@id": "https://rdf.spdx.org/v3/Core/from",
            "@type": "@id",
        },
        "hashValue": "https://rdf.spdx.org/v3/Core/hashValue",
        "id": "@id",
        "identifier": "https://rdf.spdx.org/v3/Core/identifier",
        "identifierLocator": "https://rdf.spdx.org/v3/Core/identifierLocator",
        "imports" : {
            "@id": "https://rdf.spdx.org/v3/Core/imports",
            "@type": "@id",
        },
        "issuingAuthority": "https://rdf.spdx.org/v3/Core/issuingAuthority",
        "key": "https://rdf.spdx.org/v3/Core/key",
        "locationHint": "https://rdf.spdx.org/v3/Core/locationHint",
        "locator": "https://rdf.spdx.org/v3/Core/locator",
        "name": "https://rdf.spdx.org/v3/Core/name",
        "namespace": "https://rdf.spdx.org/v3/Core/namespace",
        "namespaceMap" : {
            "@id": "https://rdf.spdx.org/v3/Core/namespaceMap",
            "@type": "@id",
        },
        "originatedBy" : {
            "@id": "https://rdf.spdx.org/v3/Core/originatedBy",
            "@type": "@id",
        },
        "packageVerificationCodeExcludedFile": "https://rdf.spdx.org/v3/Core/packageVerificationCodeExcludedFile",
        "prefix": "https://rdf.spdx.org/v3/Core/prefix",
        "profileConformance" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/profileConformance",
            "@type": "@vocab",
        },
        "relationshipType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/RelationshipType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/relationshipType",
            "@type": "@vocab",
        },
        "releaseTime": "https://rdf.spdx.org/v3/Core/releaseTime",
        "rootElement" : {
            "@id": "https://rdf.spdx.org/v3/Core/rootElement",
            "@type": "@id",
        },
        "scope" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/LifecycleScopeType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/scope",
            "@type": "@vocab",
        },
        "security_CvssSeverityType": "https://rdf.spdx.org/v3/Security/CvssSeverityType",
        "security_CvssV2VulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/CvssV2VulnAssessmentRelationship",
        "security_CvssV3VulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/CvssV3VulnAssessmentRelationship",
        "security_CvssV4VulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/CvssV4VulnAssessmentRelationship",
        "security_EpssVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/EpssVulnAssessmentRelationship",
        "security_ExploitCatalogType": "https://rdf.spdx.org/v3/Security/ExploitCatalogType",
        "security_ExploitCatalogVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/ExploitCatalogVulnAssessmentRelationship",
        "security_SsvcDecisionType": "https://rdf.spdx.org/v3/Security/SsvcDecisionType",
        "security_SsvcVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/SsvcVulnAssessmentRelationship",
        "security_VexAffectedVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VexAffectedVulnAssessmentRelationship",
        "security_VexFixedVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VexFixedVulnAssessmentRelationship",
        "security_VexJustificationType": "https://rdf.spdx.org/v3/Security/VexJustificationType",
        "security_VexNotAffectedVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VexNotAffectedVulnAssessmentRelationship",
        "security_VexUnderInvestigationVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VexUnderInvestigationVulnAssessmentRelationship",
        "security_VexVulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VexVulnAssessmentRelationship",
        "security_VulnAssessmentRelationship": "https://rdf.spdx.org/v3/Security/VulnAssessmentRelationship",
        "security_Vulnerability": "https://rdf.spdx.org/v3/Security/Vulnerability",
        "security_actionStatement": "https://rdf.spdx.org/v3/Security/actionStatement",
        "security_actionStatementTime": "https://rdf.spdx.org/v3/Security/actionStatementTime",
        "security_assessedElement" : {
            "@id": "https://rdf.spdx.org/v3/Security/assessedElement",
            "@type": "@id",
        },
        "security_catalogType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Security/ExploitCatalogType/",
            },
            "@id": "https://rdf.spdx.org/v3/Security/catalogType",
            "@type": "@vocab",
        },
        "security_decisionType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Security/SsvcDecisionType/",
            },
            "@id": "https://rdf.spdx.org/v3/Security/decisionType",
            "@type": "@vocab",
        },
        "security_exploited": "https://rdf.spdx.org/v3/Security/exploited",
        "security_impactStatement": "https://rdf.spdx.org/v3/Security/impactStatement",
        "security_impactStatementTime": "https://rdf.spdx.org/v3/Security/impactStatementTime",
        "security_justificationType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Security/VexJustificationType/",
            },
            "@id": "https://rdf.spdx.org/v3/Security/justificationType",
            "@type": "@vocab",
        },
        "security_locator": "https://rdf.spdx.org/v3/Security/locator",
        "security_modifiedTime": "https://rdf.spdx.org/v3/Security/modifiedTime",
        "security_percentile": "https://rdf.spdx.org/v3/Security/percentile",
        "security_probability": "https://rdf.spdx.org/v3/Security/probability",
        "security_publishedTime": "https://rdf.spdx.org/v3/Security/publishedTime",
        "security_score": "https://rdf.spdx.org/v3/Security/score",
        "security_severity" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Security/CvssSeverityType/",
            },
            "@id": "https://rdf.spdx.org/v3/Security/severity",
            "@type": "@vocab",
        },
        "security_statusNotes": "https://rdf.spdx.org/v3/Security/statusNotes",
        "security_vectorString": "https://rdf.spdx.org/v3/Security/vectorString",
        "security_vexVersion": "https://rdf.spdx.org/v3/Security/vexVersion",
        "security_withdrawnTime": "https://rdf.spdx.org/v3/Security/withdrawnTime",
        "simplelicensing_AnyLicenseInfo": "https://rdf.spdx.org/v3/SimpleLicensing/AnyLicenseInfo",
        "simplelicensing_LicenseExpression": "https://rdf.spdx.org/v3/SimpleLicensing/LicenseExpression",
        "simplelicensing_SimpleLicensingText": "https://rdf.spdx.org/v3/SimpleLicensing/SimpleLicensingText",
        "simplelicensing_customIdToUri" : {
            "@id": "https://rdf.spdx.org/v3/SimpleLicensing/customIdToUri",
            "@type": "@id",
        },
        "simplelicensing_licenseExpression": "https://rdf.spdx.org/v3/SimpleLicensing/licenseExpression",
        "simplelicensing_licenseListVersion": "https://rdf.spdx.org/v3/SimpleLicensing/licenseListVersion",
        "simplelicensing_licenseText": "https://rdf.spdx.org/v3/SimpleLicensing/licenseText",
        "software_File": "https://rdf.spdx.org/v3/Software/File",
        "software_Package": "https://rdf.spdx.org/v3/Software/Package",
        "software_Sbom": "https://rdf.spdx.org/v3/Software/Sbom",
        "software_SbomType": "https://rdf.spdx.org/v3/Software/SbomType",
        "software_Snippet": "https://rdf.spdx.org/v3/Software/Snippet",
        "software_SoftwareArtifact": "https://rdf.spdx.org/v3/Software/SoftwareArtifact",
        "software_SoftwarePurpose": "https://rdf.spdx.org/v3/Software/SoftwarePurpose",
        "software_additionalPurpose" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Software/SoftwarePurpose/",
            },
            "@id": "https://rdf.spdx.org/v3/Software/additionalPurpose",
            "@type": "@vocab",
        },
        "software_attributionText": "https://rdf.spdx.org/v3/Software/attributionText",
        "software_byteRange": "https://rdf.spdx.org/v3/Software/byteRange",
        "software_contentType": "https://rdf.spdx.org/v3/Software/contentType",
        "software_copyrightText": "https://rdf.spdx.org/v3/Software/copyrightText",
        "software_downloadLocation": "https://rdf.spdx.org/v3/Software/downloadLocation",
        "software_gitoid": "https://rdf.spdx.org/v3/Software/gitoid",
        "software_homePage": "https://rdf.spdx.org/v3/Software/homePage",
        "software_isDirectory": "https://rdf.spdx.org/v3/Software/isDirectory",
        "software_lineRange": "https://rdf.spdx.org/v3/Software/lineRange",
        "software_packageUrl": "https://rdf.spdx.org/v3/Software/packageUrl",
        "software_packageVersion": "https://rdf.spdx.org/v3/Software/packageVersion",
        "software_primaryPurpose" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Software/SoftwarePurpose/",
            },
            "@id": "https://rdf.spdx.org/v3/Software/primaryPurpose",
            "@type": "@vocab",
        },
        "software_sbomType" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Software/SbomType/",
            },
            "@id": "https://rdf.spdx.org/v3/Software/sbomType",
            "@type": "@vocab",
        },
        "software_snippetFromFile" : {
            "@id": "https://rdf.spdx.org/v3/Software/snippetFromFile",
            "@type": "@id",
        },
        "software_sourceInfo": "https://rdf.spdx.org/v3/Software/sourceInfo",
        "spdx": "https://rdf.spdx.org/v3/",
        "spdxId": "@id",
        "specVersion": "https://rdf.spdx.org/v3/Core/specVersion",
        "standardName": "https://rdf.spdx.org/v3/Core/standardName",
        "startTime": "https://rdf.spdx.org/v3/Core/startTime",
        "statement": "https://rdf.spdx.org/v3/Core/statement",
        "subject" : {
            "@id": "https://rdf.spdx.org/v3/Core/subject",
            "@type": "@id",
        },
        "summary": "https://rdf.spdx.org/v3/Core/summary",
        "suppliedBy" : {
            "@id": "https://rdf.spdx.org/v3/Core/suppliedBy",
            "@type": "@id",
        },
        "supportLevel" : {
            "@context" : {
                "@vocab": "https://rdf.spdx.org/v3/Core/SupportType/",
            },
            "@id": "https://rdf.spdx.org/v3/Core/supportLevel",
            "@type": "@vocab",
        },
        "to" : {
            "@id": "https://rdf.spdx.org/v3/Core/to",
            "@type": "@id",
        },
        "type": "@type",
        "validUntilTime": "https://rdf.spdx.org/v3/Core/validUntilTime",
        "value": "https://rdf.spdx.org/v3/Core/value",
        "verifiedUsing" : {
            "@id": "https://rdf.spdx.org/v3/Core/verifiedUsing",
            "@type": "@id",
        },
    },
]

CONTEXT_URLS = [
    "https://spdx.github.io/spdx-3-model/context.json",
]


# ENUMERATIONS
# Categories of safety risk impact of the application.
class ai_SafetyRiskAssessmentType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType"
    valid_values = [
        ("high", "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/high"),
        ("low", "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/low"),
        ("medium", "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/medium"),
        ("serious", "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/serious"),
    ]
    # The second-highest level of risk posed by an AI software.
    high = "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/high"
    # Low/no risk is posed by the AI software.
    low = "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/low"
    # The third-highest level of risk posed by an AI software.
    medium = "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/medium"
    # The highest level of risk posed by an AI software.
    serious = "https://rdf.spdx.org/v3/AI/SafetyRiskAssessmentType/serious"


# Specifies the type of an annotation.
class AnnotationType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/AnnotationType"
    valid_values = [
        ("other", "https://rdf.spdx.org/v3/Core/AnnotationType/other"),
        ("review", "https://rdf.spdx.org/v3/Core/AnnotationType/review"),
    ]
    # Used to store extra information about an Element which is not part of a Review (e.g. extra information provided during the creation of the Element).
    other = "https://rdf.spdx.org/v3/Core/AnnotationType/other"
    # Used when someone reviews the Element.
    review = "https://rdf.spdx.org/v3/Core/AnnotationType/review"


# Specifies the type of an external identifier.
class ExternalIdentifierType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType"
    valid_values = [
        ("cpe22", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cpe22"),
        ("cpe23", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cpe23"),
        ("cve", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cve"),
        ("email", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/email"),
        ("gitoid", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/gitoid"),
        ("other", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/other"),
        ("packageUrl", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/packageUrl"),
        ("securityOther", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/securityOther"),
        ("swhid", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/swhid"),
        ("swid", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/swid"),
        ("urlScheme", "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/urlScheme"),
    ]
    # https://cpe.mitre.org/files/cpe-specification_2.2.pdf
    cpe22 = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cpe22"
    # https://nvlpubs.nist.gov/nistpubs/Legacy/IR/nistir7695.pdf
    cpe23 = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cpe23"
    # An identifier for a specific software flaw defined within the official CVE Dictionary and that conforms to the CVE specification as defined by https://csrc.nist.gov/glossary/term/cve_id.
    cve = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/cve"
    # https://datatracker.ietf.org/doc/html/rfc3696#section-3
    email = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/email"
    # https://www.iana.org/assignments/uri-schemes/prov/gitoid Gitoid stands for [Git Object ID](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects) and a gitoid of type blob is a unique hash of a binary artifact. A gitoid may represent the software [Artifact ID](https://github.com/omnibor/spec/blob/main/spec/SPEC.md#artifact-id) or the [OmniBOR Identifier](https://github.com/omnibor/spec/blob/main/spec/SPEC.md#omnibor-identifier) for the software artifact's associated [OmniBOR Document](https://github.com/omnibor/spec/blob/main/spec/SPEC.md#omnibor-document); this ambiguity exists because the OmniBOR Document is itself an artifact, and the gitoid of that artifact is its valid identifier. Omnibor is a minimalistic schema to describe software [Artifact Dependency Graphs](https://github.com/omnibor/spec/blob/main/spec/SPEC.md#artifact-dependency-graph-adg). Gitoids calculated on software artifacts (Snippet, File, or Package Elements) should be recorded in the SPDX 3.0 SoftwareArtifact's ContentIdentifier property. Gitoids calculated on the OmniBOR Document (OmniBOR Identifiers) should be recorded in the SPDX 3.0 Element's ExternalIdentifier property.
    gitoid = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/gitoid"
    # Used when the type doesn't match any of the other options.
    other = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/other"
    # https://github.com/package-url/purl-spec
    packageUrl = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/packageUrl"
    # Used when there is a security related identifier of unspecified type.
    securityOther = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/securityOther"
    # SoftWare Hash IDentifier, persistent intrinsic identifiers for digital artifacts, such as files, trees (also known as directories or folders), commits, and other objects typically found in version control systems. The syntax of the identifiers is defined in the [SWHID specification](https://www.swhid.org/specification/v1.1/4.Syntax) and they typically look like `swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2`.
    swhid = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/swhid"
    # https://www.ietf.org/archive/id/draft-ietf-sacm-coswid-21.html#section-2.3
    swid = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/swid"
    # the scheme used in order to locate a resource https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
    urlScheme = "https://rdf.spdx.org/v3/Core/ExternalIdentifierType/urlScheme"


# Specifies the type of an external reference.
class ExternalRefType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/ExternalRefType"
    valid_values = [
        ("altDownloadLocation", "https://rdf.spdx.org/v3/Core/ExternalRefType/altDownloadLocation"),
        ("altWebPage", "https://rdf.spdx.org/v3/Core/ExternalRefType/altWebPage"),
        ("binaryArtifact", "https://rdf.spdx.org/v3/Core/ExternalRefType/binaryArtifact"),
        ("bower", "https://rdf.spdx.org/v3/Core/ExternalRefType/bower"),
        ("buildMeta", "https://rdf.spdx.org/v3/Core/ExternalRefType/buildMeta"),
        ("buildSystem", "https://rdf.spdx.org/v3/Core/ExternalRefType/buildSystem"),
        ("certificationReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/certificationReport"),
        ("chat", "https://rdf.spdx.org/v3/Core/ExternalRefType/chat"),
        ("componentAnalysisReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/componentAnalysisReport"),
        ("documentation", "https://rdf.spdx.org/v3/Core/ExternalRefType/documentation"),
        ("dynamicAnalysisReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/dynamicAnalysisReport"),
        ("eolNotice", "https://rdf.spdx.org/v3/Core/ExternalRefType/eolNotice"),
        ("exportControlAssessment", "https://rdf.spdx.org/v3/Core/ExternalRefType/exportControlAssessment"),
        ("funding", "https://rdf.spdx.org/v3/Core/ExternalRefType/funding"),
        ("issueTracker", "https://rdf.spdx.org/v3/Core/ExternalRefType/issueTracker"),
        ("license", "https://rdf.spdx.org/v3/Core/ExternalRefType/license"),
        ("mailingList", "https://rdf.spdx.org/v3/Core/ExternalRefType/mailingList"),
        ("mavenCentral", "https://rdf.spdx.org/v3/Core/ExternalRefType/mavenCentral"),
        ("metrics", "https://rdf.spdx.org/v3/Core/ExternalRefType/metrics"),
        ("npm", "https://rdf.spdx.org/v3/Core/ExternalRefType/npm"),
        ("nuget", "https://rdf.spdx.org/v3/Core/ExternalRefType/nuget"),
        ("other", "https://rdf.spdx.org/v3/Core/ExternalRefType/other"),
        ("privacyAssessment", "https://rdf.spdx.org/v3/Core/ExternalRefType/privacyAssessment"),
        ("productMetadata", "https://rdf.spdx.org/v3/Core/ExternalRefType/productMetadata"),
        ("purchaseOrder", "https://rdf.spdx.org/v3/Core/ExternalRefType/purchaseOrder"),
        ("qualityAssessmentReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/qualityAssessmentReport"),
        ("releaseHistory", "https://rdf.spdx.org/v3/Core/ExternalRefType/releaseHistory"),
        ("releaseNotes", "https://rdf.spdx.org/v3/Core/ExternalRefType/releaseNotes"),
        ("riskAssessment", "https://rdf.spdx.org/v3/Core/ExternalRefType/riskAssessment"),
        ("runtimeAnalysisReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/runtimeAnalysisReport"),
        ("secureSoftwareAttestation", "https://rdf.spdx.org/v3/Core/ExternalRefType/secureSoftwareAttestation"),
        ("securityAdversaryModel", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityAdversaryModel"),
        ("securityAdvisory", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityAdvisory"),
        ("securityFix", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityFix"),
        ("securityOther", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityOther"),
        ("securityPenTestReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityPenTestReport"),
        ("securityPolicy", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityPolicy"),
        ("securityThreatModel", "https://rdf.spdx.org/v3/Core/ExternalRefType/securityThreatModel"),
        ("socialMedia", "https://rdf.spdx.org/v3/Core/ExternalRefType/socialMedia"),
        ("sourceArtifact", "https://rdf.spdx.org/v3/Core/ExternalRefType/sourceArtifact"),
        ("staticAnalysisReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/staticAnalysisReport"),
        ("support", "https://rdf.spdx.org/v3/Core/ExternalRefType/support"),
        ("vcs", "https://rdf.spdx.org/v3/Core/ExternalRefType/vcs"),
        ("vulnerabilityDisclosureReport", "https://rdf.spdx.org/v3/Core/ExternalRefType/vulnerabilityDisclosureReport"),
        ("vulnerabilityExploitabilityAssessment", "https://rdf.spdx.org/v3/Core/ExternalRefType/vulnerabilityExploitabilityAssessment"),
    ]
    # A reference to an alternative download location.
    altDownloadLocation = "https://rdf.spdx.org/v3/Core/ExternalRefType/altDownloadLocation"
    # A reference to an alternative web page.
    altWebPage = "https://rdf.spdx.org/v3/Core/ExternalRefType/altWebPage"
    # A reference to binary artifacts related to a package.
    binaryArtifact = "https://rdf.spdx.org/v3/Core/ExternalRefType/binaryArtifact"
    # A reference to a bower package.
    bower = "https://rdf.spdx.org/v3/Core/ExternalRefType/bower"
    # A reference build metadata related to a published package.
    buildMeta = "https://rdf.spdx.org/v3/Core/ExternalRefType/buildMeta"
    # A reference build system used to create or publish the package.
    buildSystem = "https://rdf.spdx.org/v3/Core/ExternalRefType/buildSystem"
    # A reference to a certification report for a package from an accredited/independent body.
    certificationReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/certificationReport"
    # A reference to the instant messaging system used by the maintainer for a package.
    chat = "https://rdf.spdx.org/v3/Core/ExternalRefType/chat"
    # A reference to a Software Composition Analysis (SCA) report.
    componentAnalysisReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/componentAnalysisReport"
    # A reference to the documentation for a package.
    documentation = "https://rdf.spdx.org/v3/Core/ExternalRefType/documentation"
    # A reference to a dynamic analysis report for a package.
    dynamicAnalysisReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/dynamicAnalysisReport"
    # A reference to the End Of Sale (EOS) and/or End Of Life (EOL) information related to a package.
    eolNotice = "https://rdf.spdx.org/v3/Core/ExternalRefType/eolNotice"
    # A reference to a export control assessment for a package.
    exportControlAssessment = "https://rdf.spdx.org/v3/Core/ExternalRefType/exportControlAssessment"
    # A reference to funding information related to a package.
    funding = "https://rdf.spdx.org/v3/Core/ExternalRefType/funding"
    # A reference to the issue tracker for a package.
    issueTracker = "https://rdf.spdx.org/v3/Core/ExternalRefType/issueTracker"
    # A reference to additional license information related to an artifact.
    license = "https://rdf.spdx.org/v3/Core/ExternalRefType/license"
    # A reference to the mailing list used by the maintainer for a package.
    mailingList = "https://rdf.spdx.org/v3/Core/ExternalRefType/mailingList"
    # A reference to a maven repository artifact.
    mavenCentral = "https://rdf.spdx.org/v3/Core/ExternalRefType/mavenCentral"
    # A reference to metrics related to package such as OpenSSF scorecards.
    metrics = "https://rdf.spdx.org/v3/Core/ExternalRefType/metrics"
    # A reference to an npm package.
    npm = "https://rdf.spdx.org/v3/Core/ExternalRefType/npm"
    # A reference to a nuget package.
    nuget = "https://rdf.spdx.org/v3/Core/ExternalRefType/nuget"
    # Used when the type doesn't match any of the other options.
    other = "https://rdf.spdx.org/v3/Core/ExternalRefType/other"
    # A reference to a privacy assessment for a package.
    privacyAssessment = "https://rdf.spdx.org/v3/Core/ExternalRefType/privacyAssessment"
    # A reference to additional product metadata such as reference within organization's product catalog.
    productMetadata = "https://rdf.spdx.org/v3/Core/ExternalRefType/productMetadata"
    # A reference to a purchase order for a package.
    purchaseOrder = "https://rdf.spdx.org/v3/Core/ExternalRefType/purchaseOrder"
    # A reference to a quality assessment for a package.
    qualityAssessmentReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/qualityAssessmentReport"
    # A reference to a published list of releases for a package.
    releaseHistory = "https://rdf.spdx.org/v3/Core/ExternalRefType/releaseHistory"
    # A reference to the release notes for a package.
    releaseNotes = "https://rdf.spdx.org/v3/Core/ExternalRefType/releaseNotes"
    # A reference to a risk assessment for a package.
    riskAssessment = "https://rdf.spdx.org/v3/Core/ExternalRefType/riskAssessment"
    # A reference to a runtime analysis report for a package.
    runtimeAnalysisReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/runtimeAnalysisReport"
    # A reference to information assuring that the software is developed using security practices as defined by [NIST SP 800-218 Secure Software Development Framework (SSDF)](https://csrc.nist.gov/publications/detail/sp/800-218/final) or [CISA Secure Software Development Attestation Form](https://www.cisa.gov/sites/default/files/2023-04/secure-software-self-attestation_common-form_508.pdf).
    secureSoftwareAttestation = "https://rdf.spdx.org/v3/Core/ExternalRefType/secureSoftwareAttestation"
    # A reference to the security adversary model for a package.
    securityAdversaryModel = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityAdversaryModel"
    # A reference to a published security advisory (where advisory as defined per ISO 29147:2018) that may affect one or more elements, e.g., vendor advisories or specific NVD entries.
    securityAdvisory = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityAdvisory"
    # A reference to the patch or source code that fixes a vulnerability.
    securityFix = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityFix"
    # A reference to related security information of unspecified type.
    securityOther = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityOther"
    # A reference to a [penetration test](https://en.wikipedia.org/wiki/Penetration_test) report for a package.
    securityPenTestReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityPenTestReport"
    # A reference to instructions for reporting newly discovered security vulnerabilities for a package.
    securityPolicy = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityPolicy"
    # A reference the [security threat model](https://en.wikipedia.org/wiki/Threat_model) for a package.
    securityThreatModel = "https://rdf.spdx.org/v3/Core/ExternalRefType/securityThreatModel"
    # A reference to a social media channel for a package.
    socialMedia = "https://rdf.spdx.org/v3/Core/ExternalRefType/socialMedia"
    # A reference to an artifact containing the sources for a package.
    sourceArtifact = "https://rdf.spdx.org/v3/Core/ExternalRefType/sourceArtifact"
    # A reference to a static analysis report for a package.
    staticAnalysisReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/staticAnalysisReport"
    # A reference to the software support channel or other support information for a package.
    support = "https://rdf.spdx.org/v3/Core/ExternalRefType/support"
    # A reference to a version control system related to a software artifact.
    vcs = "https://rdf.spdx.org/v3/Core/ExternalRefType/vcs"
    # A reference to a Vulnerability Disclosure Report (VDR) which provides the software supplier's analysis and findings describing the impact (or lack of impact) that reported vulnerabilities have on packages or products in the supplier's SBOM as defined in [NIST SP 800-161](https://csrc.nist.gov/publications/detail/sp/800-161/rev-1/final).
    vulnerabilityDisclosureReport = "https://rdf.spdx.org/v3/Core/ExternalRefType/vulnerabilityDisclosureReport"
    # A reference to a Vulnerability Exploitability eXchange (VEX) statement which provides information on whether a product is impacted by a specific vulnerability in an included package and, if affected, whether there are actions recommended to remediate. See also [NTIA VEX one-page](https://ntia.gov/files/ntia/publications/vex_one-page_summary.pdf).
    vulnerabilityExploitabilityAssessment = "https://rdf.spdx.org/v3/Core/ExternalRefType/vulnerabilityExploitabilityAssessment"


# A mathematical algorithm that maps data of arbitrary size to a bit string.
class HashAlgorithm(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/HashAlgorithm"
    valid_values = [
        ("blake2b256", "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b256"),
        ("blake2b384", "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b384"),
        ("blake2b512", "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b512"),
        ("blake3", "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake3"),
        ("crystalsDilithium", "https://rdf.spdx.org/v3/Core/HashAlgorithm/crystalsDilithium"),
        ("crystalsKyber", "https://rdf.spdx.org/v3/Core/HashAlgorithm/crystalsKyber"),
        ("falcon", "https://rdf.spdx.org/v3/Core/HashAlgorithm/falcon"),
        ("md2", "https://rdf.spdx.org/v3/Core/HashAlgorithm/md2"),
        ("md4", "https://rdf.spdx.org/v3/Core/HashAlgorithm/md4"),
        ("md5", "https://rdf.spdx.org/v3/Core/HashAlgorithm/md5"),
        ("md6", "https://rdf.spdx.org/v3/Core/HashAlgorithm/md6"),
        ("other", "https://rdf.spdx.org/v3/Core/HashAlgorithm/other"),
        ("sha1", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha1"),
        ("sha224", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha224"),
        ("sha256", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha256"),
        ("sha384", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha384"),
        ("sha3_224", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_224"),
        ("sha3_256", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_256"),
        ("sha3_384", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_384"),
        ("sha3_512", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_512"),
        ("sha512", "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha512"),
    ]
    # blake2b algorithm with a digest size of 256 https://datatracker.ietf.org/doc/html/rfc7693#section-4
    blake2b256 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b256"
    # blake2b algorithm with a digest size of 384 https://datatracker.ietf.org/doc/html/rfc7693#section-4
    blake2b384 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b384"
    # blake2b algorithm with a digest size of 512 https://datatracker.ietf.org/doc/html/rfc7693#section-4
    blake2b512 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake2b512"
    # https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf
    blake3 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/blake3"
    # https://pq-crystals.org/dilithium/index.shtml
    crystalsDilithium = "https://rdf.spdx.org/v3/Core/HashAlgorithm/crystalsDilithium"
    # https://pq-crystals.org/kyber/index.shtml
    crystalsKyber = "https://rdf.spdx.org/v3/Core/HashAlgorithm/crystalsKyber"
    # https://falcon-sign.info/falcon.pdf
    falcon = "https://rdf.spdx.org/v3/Core/HashAlgorithm/falcon"
    # https://datatracker.ietf.org/doc/rfc1319/
    md2 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/md2"
    # https://datatracker.ietf.org/doc/html/rfc1186
    md4 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/md4"
    # https://datatracker.ietf.org/doc/html/rfc1321
    md5 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/md5"
    # https://people.csail.mit.edu/rivest/pubs/RABCx08.pdf
    md6 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/md6"
    # any hashing algorithm that does not exist in this list of entries
    other = "https://rdf.spdx.org/v3/Core/HashAlgorithm/other"
    # https://datatracker.ietf.org/doc/html/rfc3174
    sha1 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha1"
    # secure hashing algorithm with a digest length of 224 https://datatracker.ietf.org/doc/html/draft-ietf-pkix-sha224-01
    sha224 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha224"
    # secure hashing algorithm with a digest length of 256 https://www.rfc-editor.org/rfc/rfc4634
    sha256 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha256"
    # secure hashing algorithm with a digest length of 384 https://www.rfc-editor.org/rfc/rfc4634
    sha384 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha384"
    # sha3 with a digest length of 224 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
    sha3_224 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_224"
    # sha3 with a digest length of 256 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
    sha3_256 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_256"
    # sha3 with a digest length of 384 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
    sha3_384 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_384"
    # sha3 with a digest length of 512 https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
    sha3_512 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha3_512"
    # secure hashing algorithm with a digest length of 512 https://www.rfc-editor.org/rfc/rfc4634
    sha512 = "https://rdf.spdx.org/v3/Core/HashAlgorithm/sha512"


# Provide an enumerated set of software lifecycle phases that can provide context to relationships.
class LifecycleScopeType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/LifecycleScopeType"
    valid_values = [
        ("build", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/build"),
        ("design", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/design"),
        ("development", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/development"),
        ("other", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/other"),
        ("runtime", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/runtime"),
        ("test", "https://rdf.spdx.org/v3/Core/LifecycleScopeType/test"),
    ]
    # A relationship has specific context implications during an element's build phase, during development.
    build = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/build"
    # A relationship has specific context implications during an element's design.
    design = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/design"
    # A relationship has specific context implications during development phase of an element.
    development = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/development"
    # A relationship has other specific context information necessary to capture that the above set of enumerations does not handle.
    other = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/other"
    # A relationship has specific context implications during the execution phase of an element.
    runtime = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/runtime"
    # A relationship has specific context implications during an element's testing phase, during development.
    test = "https://rdf.spdx.org/v3/Core/LifecycleScopeType/test"


# Categories of presence or absence.
class PresenceType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/PresenceType"
    valid_values = [
        ("no", "https://rdf.spdx.org/v3/Core/PresenceType/no"),
        ("noAssertion", "https://rdf.spdx.org/v3/Core/PresenceType/noAssertion"),
        ("yes", "https://rdf.spdx.org/v3/Core/PresenceType/yes"),
    ]
    # Indicates absence of the field.
    no = "https://rdf.spdx.org/v3/Core/PresenceType/no"
    # Makes no assertion about the field.
    noAssertion = "https://rdf.spdx.org/v3/Core/PresenceType/noAssertion"
    # Indicates presence of the field.
    yes = "https://rdf.spdx.org/v3/Core/PresenceType/yes"


# Enumeration of the valid profiles.
class ProfileIdentifierType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType"
    valid_values = [
        ("ai", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/ai"),
        ("build", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/build"),
        ("core", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/core"),
        ("dataset", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/dataset"),
        ("expandedLicensing", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/expandedLicensing"),
        ("extension", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/extension"),
        ("security", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/security"),
        ("simpleLicensing", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/simpleLicensing"),
        ("software", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/software"),
        ("usage", "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/usage"),
    ]
    # the element follows the AI profile specification
    ai = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/ai"
    # the element follows the Build profile specification
    build = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/build"
    # the element follows the Core profile specification
    core = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/core"
    # the element follows the Dataset profile specification
    dataset = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/dataset"
    # the element follows the expanded Licensing profile specification
    expandedLicensing = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/expandedLicensing"
    # the element follows the Extension profile specification
    extension = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/extension"
    # the element follows the Security profile specification
    security = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/security"
    # the element follows the simple Licensing profile specification
    simpleLicensing = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/simpleLicensing"
    # the element follows the Software profile specification
    software = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/software"
    # the element follows the Usage profile specification
    usage = "https://rdf.spdx.org/v3/Core/ProfileIdentifierType/usage"


# Indicates whether a relationship is known to be complete, incomplete, or if no assertion is made with respect to relationship completeness.
class RelationshipCompleteness(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/RelationshipCompleteness"
    valid_values = [
        ("complete", "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/complete"),
        ("incomplete", "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/incomplete"),
        ("noAssertion", "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/noAssertion"),
    ]
    # The relationship is known to be exhaustive.
    complete = "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/complete"
    # The relationship is known not to be exhaustive.
    incomplete = "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/incomplete"
    # No assertion can be made about the completeness of the relationship.
    noAssertion = "https://rdf.spdx.org/v3/Core/RelationshipCompleteness/noAssertion"


# Information about the relationship between two Elements.
class RelationshipType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/RelationshipType"
    valid_values = [
        ("affects", "https://rdf.spdx.org/v3/Core/RelationshipType/affects"),
        ("amendedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/amendedBy"),
        ("ancestorOf", "https://rdf.spdx.org/v3/Core/RelationshipType/ancestorOf"),
        ("availableFrom", "https://rdf.spdx.org/v3/Core/RelationshipType/availableFrom"),
        ("configures", "https://rdf.spdx.org/v3/Core/RelationshipType/configures"),
        ("contains", "https://rdf.spdx.org/v3/Core/RelationshipType/contains"),
        ("coordinatedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/coordinatedBy"),
        ("copiedTo", "https://rdf.spdx.org/v3/Core/RelationshipType/copiedTo"),
        ("delegatedTo", "https://rdf.spdx.org/v3/Core/RelationshipType/delegatedTo"),
        ("dependsOn", "https://rdf.spdx.org/v3/Core/RelationshipType/dependsOn"),
        ("descendantOf", "https://rdf.spdx.org/v3/Core/RelationshipType/descendantOf"),
        ("describes", "https://rdf.spdx.org/v3/Core/RelationshipType/describes"),
        ("doesNotAffect", "https://rdf.spdx.org/v3/Core/RelationshipType/doesNotAffect"),
        ("expandsTo", "https://rdf.spdx.org/v3/Core/RelationshipType/expandsTo"),
        ("exploitCreatedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/exploitCreatedBy"),
        ("fixedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/fixedBy"),
        ("fixedIn", "https://rdf.spdx.org/v3/Core/RelationshipType/fixedIn"),
        ("foundBy", "https://rdf.spdx.org/v3/Core/RelationshipType/foundBy"),
        ("generates", "https://rdf.spdx.org/v3/Core/RelationshipType/generates"),
        ("hasAddedFile", "https://rdf.spdx.org/v3/Core/RelationshipType/hasAddedFile"),
        ("hasAssessmentFor", "https://rdf.spdx.org/v3/Core/RelationshipType/hasAssessmentFor"),
        ("hasAssociatedVulnerability", "https://rdf.spdx.org/v3/Core/RelationshipType/hasAssociatedVulnerability"),
        ("hasConcludedLicense", "https://rdf.spdx.org/v3/Core/RelationshipType/hasConcludedLicense"),
        ("hasDataFile", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDataFile"),
        ("hasDeclaredLicense", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDeclaredLicense"),
        ("hasDeletedFile", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDeletedFile"),
        ("hasDependencyManifest", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDependencyManifest"),
        ("hasDistributionArtifact", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDistributionArtifact"),
        ("hasDocumentation", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDocumentation"),
        ("hasDynamicLink", "https://rdf.spdx.org/v3/Core/RelationshipType/hasDynamicLink"),
        ("hasEvidence", "https://rdf.spdx.org/v3/Core/RelationshipType/hasEvidence"),
        ("hasExample", "https://rdf.spdx.org/v3/Core/RelationshipType/hasExample"),
        ("hasHost", "https://rdf.spdx.org/v3/Core/RelationshipType/hasHost"),
        ("hasInputs", "https://rdf.spdx.org/v3/Core/RelationshipType/hasInputs"),
        ("hasMetadata", "https://rdf.spdx.org/v3/Core/RelationshipType/hasMetadata"),
        ("hasOptionalComponent", "https://rdf.spdx.org/v3/Core/RelationshipType/hasOptionalComponent"),
        ("hasOptionalDependency", "https://rdf.spdx.org/v3/Core/RelationshipType/hasOptionalDependency"),
        ("hasOutputs", "https://rdf.spdx.org/v3/Core/RelationshipType/hasOutputs"),
        ("hasPrerequsite", "https://rdf.spdx.org/v3/Core/RelationshipType/hasPrerequsite"),
        ("hasProvidedDependency", "https://rdf.spdx.org/v3/Core/RelationshipType/hasProvidedDependency"),
        ("hasRequirement", "https://rdf.spdx.org/v3/Core/RelationshipType/hasRequirement"),
        ("hasSpecification", "https://rdf.spdx.org/v3/Core/RelationshipType/hasSpecification"),
        ("hasStaticLink", "https://rdf.spdx.org/v3/Core/RelationshipType/hasStaticLink"),
        ("hasTest", "https://rdf.spdx.org/v3/Core/RelationshipType/hasTest"),
        ("hasTestCase", "https://rdf.spdx.org/v3/Core/RelationshipType/hasTestCase"),
        ("hasVariant", "https://rdf.spdx.org/v3/Core/RelationshipType/hasVariant"),
        ("invokedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/invokedBy"),
        ("modifiedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/modifiedBy"),
        ("other", "https://rdf.spdx.org/v3/Core/RelationshipType/other"),
        ("packagedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/packagedBy"),
        ("patchedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/patchedBy"),
        ("publishedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/publishedBy"),
        ("reportedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/reportedBy"),
        ("republishedBy", "https://rdf.spdx.org/v3/Core/RelationshipType/republishedBy"),
        ("serializedInArtifact", "https://rdf.spdx.org/v3/Core/RelationshipType/serializedInArtifact"),
        ("testedOn", "https://rdf.spdx.org/v3/Core/RelationshipType/testedOn"),
        ("trainedOn", "https://rdf.spdx.org/v3/Core/RelationshipType/trainedOn"),
        ("underInvestigationFor", "https://rdf.spdx.org/v3/Core/RelationshipType/underInvestigationFor"),
        ("usesTool", "https://rdf.spdx.org/v3/Core/RelationshipType/usesTool"),
    ]
    # (Security/VEX) The `from` vulnerability affect each `to` Element
    affects = "https://rdf.spdx.org/v3/Core/RelationshipType/affects"
    # The `from` Element is amended by each `to` Element
    amendedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/amendedBy"
    # The `from` Element is an ancestor of each `to` Element
    ancestorOf = "https://rdf.spdx.org/v3/Core/RelationshipType/ancestorOf"
    # The `from` Element is available from the additional supplier described by each `to` Element
    availableFrom = "https://rdf.spdx.org/v3/Core/RelationshipType/availableFrom"
    # The `from` Element is a configuration applied to each `to` Element during a LifecycleScopeType period
    configures = "https://rdf.spdx.org/v3/Core/RelationshipType/configures"
    # The `from` Element contains each `to` Element
    contains = "https://rdf.spdx.org/v3/Core/RelationshipType/contains"
    # (Security) The `from` Vulnerability is coordinatedBy the `to` Agent(s) (vendor, researcher, or consumer agent)
    coordinatedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/coordinatedBy"
    # The `from` Element has been copied to each `to` Element
    copiedTo = "https://rdf.spdx.org/v3/Core/RelationshipType/copiedTo"
    # The `from` Agent is delegating an action to the Agent of the `to` Relationship (which must be of type invokedBy) during a LifecycleScopeType. (e.g. the `to` invokedBy Relationship is being done on behalf of `from`)
    delegatedTo = "https://rdf.spdx.org/v3/Core/RelationshipType/delegatedTo"
    # The `from` Element depends on each `to` Element during a LifecycleScopeType period.
    dependsOn = "https://rdf.spdx.org/v3/Core/RelationshipType/dependsOn"
    # The `from` Element is a descendant of each `to` Element
    descendantOf = "https://rdf.spdx.org/v3/Core/RelationshipType/descendantOf"
    # The `from` Element describes each `to` Element. To denote the root(s) of a tree of elements in a collection, the rootElement property should be used.
    describes = "https://rdf.spdx.org/v3/Core/RelationshipType/describes"
    # (Security/VEX) The `from` Vulnerability has no impact on each `to` Element
    doesNotAffect = "https://rdf.spdx.org/v3/Core/RelationshipType/doesNotAffect"
    # The `from` archive expands out as an artifact described by each `to` Element
    expandsTo = "https://rdf.spdx.org/v3/Core/RelationshipType/expandsTo"
    # (Security) The `from` Vulnerability has had an exploit created against it by each `to` Agent
    exploitCreatedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/exploitCreatedBy"
    # (Security) Designates a `from` Vulnerability has been fixed by the `to` Agent(s)
    fixedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/fixedBy"
    # (Security/VEX) A `from` Vulnerability has been fixed in each of the `to` Element(s)
    fixedIn = "https://rdf.spdx.org/v3/Core/RelationshipType/fixedIn"
    # (Security) Designates a `from` Vulnerability was originally discovered by the `to` Agent(s)
    foundBy = "https://rdf.spdx.org/v3/Core/RelationshipType/foundBy"
    # The `from` Element generates each `to` Element
    generates = "https://rdf.spdx.org/v3/Core/RelationshipType/generates"
    # Every `to` Element is is a file added to the `from` Element (`from` hasAddedFile `to`)
    hasAddedFile = "https://rdf.spdx.org/v3/Core/RelationshipType/hasAddedFile"
    # (Security) Relates a `from` Vulnerability and each `to` Element(s) with a security assessment. To be used with `VulnAssessmentRelationship` types
    hasAssessmentFor = "https://rdf.spdx.org/v3/Core/RelationshipType/hasAssessmentFor"
    # (Security) Used to associate a `from` Artifact with each `to` Vulnerability
    hasAssociatedVulnerability = "https://rdf.spdx.org/v3/Core/RelationshipType/hasAssociatedVulnerability"
    # The `from` Software Artifact is concluded by the SPDX data creator to be governed by each `to` license
    hasConcludedLicense = "https://rdf.spdx.org/v3/Core/RelationshipType/hasConcludedLicense"
    # The `from` Element treats each `to` Element as a data file
    hasDataFile = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDataFile"
    # The `from` Software Artifact was discovered to actually contain each `to` license, for example as detected by use of automated tooling.
    hasDeclaredLicense = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDeclaredLicense"
    # Every `to` Element is a file deleted from the `from` Element (`from` hasDeletedFile `to`)
    hasDeletedFile = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDeletedFile"
    # The `from` Element has manifest files that contain dependency information in each `to` Element
    hasDependencyManifest = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDependencyManifest"
    # The `from` Element is distributed as an artifact in each Element `to`, (e.g. an RPM or archive file)
    hasDistributionArtifact = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDistributionArtifact"
    # The `from` Element is documented by each `to` Element
    hasDocumentation = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDocumentation"
    # The `from` Element dynamically links in each `to` Element, during a LifecycleScopeType period.
    hasDynamicLink = "https://rdf.spdx.org/v3/Core/RelationshipType/hasDynamicLink"
    # (Dataset) Every `to` Element is considered as evidence for the `from` Element (`from` hasEvidence `to`)
    hasEvidence = "https://rdf.spdx.org/v3/Core/RelationshipType/hasEvidence"
    # Every `to` Element is an example for the `from` Element (`from` hasExample `to`)
    hasExample = "https://rdf.spdx.org/v3/Core/RelationshipType/hasExample"
    # The `from` Build was run on the `to` Element during a LifecycleScopeType period (e.g. The host that the build runs on)
    hasHost = "https://rdf.spdx.org/v3/Core/RelationshipType/hasHost"
    # The `from` Build has each `to` Elements as an input during a LifecycleScopeType period.
    hasInputs = "https://rdf.spdx.org/v3/Core/RelationshipType/hasInputs"
    # Every `to` Element is metadata about the `from` Element (`from` hasMetadata `to`)
    hasMetadata = "https://rdf.spdx.org/v3/Core/RelationshipType/hasMetadata"
    # Every `to` Element is an optional component of the `from` Element (`from` hasOptionalComponent` `to`)
    hasOptionalComponent = "https://rdf.spdx.org/v3/Core/RelationshipType/hasOptionalComponent"
    # The `from` Element optionally depends on each `to` Element during a LifecycleScopeType period
    hasOptionalDependency = "https://rdf.spdx.org/v3/Core/RelationshipType/hasOptionalDependency"
    # The `from` Build element generates each `to` Element as an output during a LifecycleScopeType period.
    hasOutputs = "https://rdf.spdx.org/v3/Core/RelationshipType/hasOutputs"
    # The `from` Element has a prerequsite on each `to` Element, during a LifecycleScopeType period
    hasPrerequsite = "https://rdf.spdx.org/v3/Core/RelationshipType/hasPrerequsite"
    # The `from` Element has a dependency on each `to` Element, but dependency is not in the distributed artifact, but assumed to be provided, during a LifecycleScopeType period
    hasProvidedDependency = "https://rdf.spdx.org/v3/Core/RelationshipType/hasProvidedDependency"
    # The `from` Element has a requirement on each `to` Element, during a LifecycleScopeType period
    hasRequirement = "https://rdf.spdx.org/v3/Core/RelationshipType/hasRequirement"
    # Every `to` Element is a specification for the `from` Element (`from` hasSpecification `to`), during a LifecycleScopeType period
    hasSpecification = "https://rdf.spdx.org/v3/Core/RelationshipType/hasSpecification"
    # The `from` Element statically links in each `to` Element, during a LifecycleScopeType period
    hasStaticLink = "https://rdf.spdx.org/v3/Core/RelationshipType/hasStaticLink"
    # Every `to` Element is a test artifact for the `from` Element (`from` hasTest `to`), during a LifecycleScopeType period
    hasTest = "https://rdf.spdx.org/v3/Core/RelationshipType/hasTest"
    # Every `to` Element is a test case for the `from` Element (`from` hasTestCase `to`)
    hasTestCase = "https://rdf.spdx.org/v3/Core/RelationshipType/hasTestCase"
    # Every `to` Element is a variant the `from` Element (`from` hasVariant `to`)
    hasVariant = "https://rdf.spdx.org/v3/Core/RelationshipType/hasVariant"
    # The `from` Element was invoked by the `to` Agent during a LifecycleScopeType period (for example, a Build element that describes a build step)
    invokedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/invokedBy"
    # The `from` Element is modified by each `to` Element
    modifiedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/modifiedBy"
    # Every `to` Element is related to the `from` Element where the relationship type is not described by any of the SPDX relationhip types (this relationship is directionless)
    other = "https://rdf.spdx.org/v3/Core/RelationshipType/other"
    # Every `to` Element is a packaged instance of the `from` Element (`from` packagedBy `to`)
    packagedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/packagedBy"
    # Every `to` Element is a patch for the `from` Element (`from` patchedBy `to`)
    patchedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/patchedBy"
    # (Security) Designates a `from` Vulnerability was made available for public use or reference by each `to` Agent
    publishedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/publishedBy"
    # (Security) Designates a `from` Vulnerability was first reported to a project, vendor, or tracking database for formal identification by each `to` Agent
    reportedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/reportedBy"
    # (Security) Designates a `from` Vulnerability's details were tracked, aggregated, and/or enriched to improve context (i.e. NVD) by a `to` Agent(s)
    republishedBy = "https://rdf.spdx.org/v3/Core/RelationshipType/republishedBy"
    # The `from` SPDXDocument can be found in a serialized form in each `to` Artifact
    serializedInArtifact = "https://rdf.spdx.org/v3/Core/RelationshipType/serializedInArtifact"
    # (AI, Dataset) The `from` Element has been tested on the `to` Element
    testedOn = "https://rdf.spdx.org/v3/Core/RelationshipType/testedOn"
    # (AI, Dataset) The `from` Element has been trained by the `to` Element(s)
    trainedOn = "https://rdf.spdx.org/v3/Core/RelationshipType/trainedOn"
    # (Security/VEX) The `from` Vulnerability impact is being investigated for each `to` Element
    underInvestigationFor = "https://rdf.spdx.org/v3/Core/RelationshipType/underInvestigationFor"
    # The `from` Element uses each `to` Element as a tool during a LifecycleScopeType period.
    usesTool = "https://rdf.spdx.org/v3/Core/RelationshipType/usesTool"


# Indicates the type of support that is associated with an artifact.
class SupportType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Core/SupportType"
    valid_values = [
        ("development", "https://rdf.spdx.org/v3/Core/SupportType/development"),
        ("endOfSupport", "https://rdf.spdx.org/v3/Core/SupportType/endOfSupport"),
        ("limitedSupport", "https://rdf.spdx.org/v3/Core/SupportType/limitedSupport"),
        ("noAssertion", "https://rdf.spdx.org/v3/Core/SupportType/noAssertion"),
        ("noSupport", "https://rdf.spdx.org/v3/Core/SupportType/noSupport"),
        ("support", "https://rdf.spdx.org/v3/Core/SupportType/support"),
    ]
    # the artifact is in active development and is not considered ready for formal support from the supplier.
    development = "https://rdf.spdx.org/v3/Core/SupportType/development"
    # there is a defined end of support for the artifact from the supplier.  This may also be referred to as end of life. There is a validUntilDate that can be used to signal when support ends for the artifact.
    endOfSupport = "https://rdf.spdx.org/v3/Core/SupportType/endOfSupport"
    # the artifact has been released, and there is limited support available from the supplier. There is a validUntilDate that can provide additional information about the duration of support.
    limitedSupport = "https://rdf.spdx.org/v3/Core/SupportType/limitedSupport"
    # no assertion about the type of support is made.   This is considered the default if no other support type is used.
    noAssertion = "https://rdf.spdx.org/v3/Core/SupportType/noAssertion"
    # there is no support for the artifact from the supplier, consumer assumes any support obligations.
    noSupport = "https://rdf.spdx.org/v3/Core/SupportType/noSupport"
    # the artifact has been released, and is supported from the supplier.   There is a validUntilDate that can provide additional information about the duration of support.
    support = "https://rdf.spdx.org/v3/Core/SupportType/support"


# Categories of confidentiality level.
class dataset_ConfidentialityLevelType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType"
    valid_values = [
        ("amber", "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/amber"),
        ("clear", "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/clear"),
        ("green", "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/green"),
        ("red", "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/red"),
    ]
    # Data points in the dataset can be shared only with specific organizations and their clients on a need to know basis.
    amber = "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/amber"
    # Dataset may be distributed freely, without restriction.
    clear = "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/clear"
    # Dataset can be shared within a community of peers and partners.
    green = "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/green"
    # Data points in the dataset are highly confidential and can only be shared with named recipients.
    red = "https://rdf.spdx.org/v3/Dataset/ConfidentialityLevelType/red"


# Availability of dataset
class dataset_DatasetAvailabilityType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType"
    valid_values = [
        ("clickthrough", "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/clickthrough"),
        ("directDownload", "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/directDownload"),
        ("query", "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/query"),
        ("registration", "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/registration"),
        ("scrapingScript", "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/scrapingScript"),
    ]
    # the dataset is not publicly available and can only be accessed after affirmatively accepting terms on a clickthrough webpage.
    clickthrough = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/clickthrough"
    # the dataset is publicly available and can be downloaded directly.
    directDownload = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/directDownload"
    # the dataset is publicly available, but not all at once, and can only be accessed through queries which return parts of the dataset.
    query = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/query"
    # the dataset is not publicly available and an email registration is required before accessing the dataset, although without an affirmative acceptance of terms.
    registration = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/registration"
    # the dataset provider is not making available the underlying data and the dataset must be reassembled, typically using the provided script for scraping the data.
    scrapingScript = "https://rdf.spdx.org/v3/Dataset/DatasetAvailabilityType/scrapingScript"


# Enumeration of dataset types.
class dataset_DatasetType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Dataset/DatasetType"
    valid_values = [
        ("audio", "https://rdf.spdx.org/v3/Dataset/DatasetType/audio"),
        ("categorical", "https://rdf.spdx.org/v3/Dataset/DatasetType/categorical"),
        ("graph", "https://rdf.spdx.org/v3/Dataset/DatasetType/graph"),
        ("image", "https://rdf.spdx.org/v3/Dataset/DatasetType/image"),
        ("noAssertion", "https://rdf.spdx.org/v3/Dataset/DatasetType/noAssertion"),
        ("numeric", "https://rdf.spdx.org/v3/Dataset/DatasetType/numeric"),
        ("other", "https://rdf.spdx.org/v3/Dataset/DatasetType/other"),
        ("sensor", "https://rdf.spdx.org/v3/Dataset/DatasetType/sensor"),
        ("structured", "https://rdf.spdx.org/v3/Dataset/DatasetType/structured"),
        ("syntactic", "https://rdf.spdx.org/v3/Dataset/DatasetType/syntactic"),
        ("text", "https://rdf.spdx.org/v3/Dataset/DatasetType/text"),
        ("timeseries", "https://rdf.spdx.org/v3/Dataset/DatasetType/timeseries"),
        ("timestamp", "https://rdf.spdx.org/v3/Dataset/DatasetType/timestamp"),
        ("video", "https://rdf.spdx.org/v3/Dataset/DatasetType/video"),
    ]
    # data is audio based, such as a collection of music from the 80s.
    audio = "https://rdf.spdx.org/v3/Dataset/DatasetType/audio"
    # data that is classified into a discrete number of categories, such as the eye color of a population of people.
    categorical = "https://rdf.spdx.org/v3/Dataset/DatasetType/categorical"
    # data is in the form of a graph where entries are somehow related to each other through edges, such a social network of friends.
    graph = "https://rdf.spdx.org/v3/Dataset/DatasetType/graph"
    # data is a collection of images such as pictures of animals.
    image = "https://rdf.spdx.org/v3/Dataset/DatasetType/image"
    # data type is not known.
    noAssertion = "https://rdf.spdx.org/v3/Dataset/DatasetType/noAssertion"
    # data consists only of numeric entries.
    numeric = "https://rdf.spdx.org/v3/Dataset/DatasetType/numeric"
    # data is of a type not included in this list.
    other = "https://rdf.spdx.org/v3/Dataset/DatasetType/other"
    # data is recorded from a physical sensor, such as a thermometer reading or biometric device.
    sensor = "https://rdf.spdx.org/v3/Dataset/DatasetType/sensor"
    # data is stored in tabular format or retrieved from a relational database.
    structured = "https://rdf.spdx.org/v3/Dataset/DatasetType/structured"
    # data describes the syntax or semantics of a language or text, such as a parse tree used for natural language processing.
    syntactic = "https://rdf.spdx.org/v3/Dataset/DatasetType/syntactic"
    # data consists of unstructured text, such as a book, wikipedia article (without images), or transcript.
    text = "https://rdf.spdx.org/v3/Dataset/DatasetType/text"
    # data is recorded in an ordered sequence of timestamped entries, such as the price of a stock over the course of a day.
    timeseries = "https://rdf.spdx.org/v3/Dataset/DatasetType/timeseries"
    # data is recorded with a timestamp for each entry, but not necessarily ordered or at specific intervals, such as when a taxi ride starts and ends.
    timestamp = "https://rdf.spdx.org/v3/Dataset/DatasetType/timestamp"
    # data is video based, such as a collection of movie clips featuring Tom Hanks.
    video = "https://rdf.spdx.org/v3/Dataset/DatasetType/video"


# Specifies the CVSS base, temporal, threat, or environmental severity type.
class security_CvssSeverityType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Security/CvssSeverityType"
    valid_values = [
        ("critical", "https://rdf.spdx.org/v3/Security/CvssSeverityType/critical"),
        ("high", "https://rdf.spdx.org/v3/Security/CvssSeverityType/high"),
        ("low", "https://rdf.spdx.org/v3/Security/CvssSeverityType/low"),
        ("medium", "https://rdf.spdx.org/v3/Security/CvssSeverityType/medium"),
        ("none", "https://rdf.spdx.org/v3/Security/CvssSeverityType/none"),
    ]
    # When a CVSS score is between 9.0 - 10.0
    critical = "https://rdf.spdx.org/v3/Security/CvssSeverityType/critical"
    # When a CVSS score is between 7.0 - 8.9
    high = "https://rdf.spdx.org/v3/Security/CvssSeverityType/high"
    # When a CVSS score is between 0 - 3.9
    low = "https://rdf.spdx.org/v3/Security/CvssSeverityType/low"
    # When a CVSS score is between 4 - 6.9
    medium = "https://rdf.spdx.org/v3/Security/CvssSeverityType/medium"
    # When a CVSS score is 0
    none = "https://rdf.spdx.org/v3/Security/CvssSeverityType/none"


# Specifies the exploit catalog type.
class security_ExploitCatalogType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Security/ExploitCatalogType"
    valid_values = [
        ("kev", "https://rdf.spdx.org/v3/Security/ExploitCatalogType/kev"),
        ("other", "https://rdf.spdx.org/v3/Security/ExploitCatalogType/other"),
    ]
    # CISA's Known Exploited Vulnerability (KEV) Catalog
    kev = "https://rdf.spdx.org/v3/Security/ExploitCatalogType/kev"
    # Other exploit catalogs
    other = "https://rdf.spdx.org/v3/Security/ExploitCatalogType/other"


# Specifies the SSVC decision type.
class security_SsvcDecisionType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Security/SsvcDecisionType"
    valid_values = [
        ("act", "https://rdf.spdx.org/v3/Security/SsvcDecisionType/act"),
        ("attend", "https://rdf.spdx.org/v3/Security/SsvcDecisionType/attend"),
        ("track", "https://rdf.spdx.org/v3/Security/SsvcDecisionType/track"),
        ("trackStar", "https://rdf.spdx.org/v3/Security/SsvcDecisionType/trackStar"),
    ]
    # The vulnerability requires attention from the organization's internal, supervisory-level and leadership-level individuals. Necessary actions include requesting assistance or information about the vulnerability, as well as publishing a notification either internally and/or externally. Typically, internal groups would meet to determine the overall response and then execute agreed upon actions. CISA recommends remediating Act vulnerabilities as soon as possible.
    act = "https://rdf.spdx.org/v3/Security/SsvcDecisionType/act"
    # The vulnerability requires attention from the organization's internal, supervisory-level individuals. Necessary actions include requesting assistance or information about the vulnerability, and may involve publishing a notification either internally and/or externally. CISA recommends remediating Attend vulnerabilities sooner than standard update timelines.
    attend = "https://rdf.spdx.org/v3/Security/SsvcDecisionType/attend"
    # The vulnerability does not require action at this time. The organization would continue to track the vulnerability and reassess it if new information becomes available. CISA recommends remediating Track vulnerabilities within standard update timelines.
    track = "https://rdf.spdx.org/v3/Security/SsvcDecisionType/track"
    # (Track* in the SSVC spec) The vulnerability contains specific characteristics that may require closer monitoring for changes. CISA recommends remediating Track* vulnerabilities within standard update timelines.
    trackStar = "https://rdf.spdx.org/v3/Security/SsvcDecisionType/trackStar"


# Specifies the VEX justification type.
class security_VexJustificationType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Security/VexJustificationType"
    valid_values = [
        ("componentNotPresent", "https://rdf.spdx.org/v3/Security/VexJustificationType/componentNotPresent"),
        ("inlineMitigationsAlreadyExist", "https://rdf.spdx.org/v3/Security/VexJustificationType/inlineMitigationsAlreadyExist"),
        ("vulnerableCodeCannotBeControlledByAdversary", "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeCannotBeControlledByAdversary"),
        ("vulnerableCodeNotInExecutePath", "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeNotInExecutePath"),
        ("vulnerableCodeNotPresent", "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeNotPresent"),
    ]
    # The software is not affected because the vulnerable component is not in the product.
    componentNotPresent = "https://rdf.spdx.org/v3/Security/VexJustificationType/componentNotPresent"
    # Built-in inline controls or mitigations prevent an adversary from leveraging the vulnerability.
    inlineMitigationsAlreadyExist = "https://rdf.spdx.org/v3/Security/VexJustificationType/inlineMitigationsAlreadyExist"
    # The vulnerable component is present, and the component contains the vulnerable code. However, vulnerable code is used in such a way that an attacker cannot mount any anticipated attack.
    vulnerableCodeCannotBeControlledByAdversary = "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeCannotBeControlledByAdversary"
    # The affected code is not reachable through the execution of the code, including non-anticipated states of the product.
    vulnerableCodeNotInExecutePath = "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeNotInExecutePath"
    # The product is not affected because the code underlying the vulnerability is not present in the product.
    vulnerableCodeNotPresent = "https://rdf.spdx.org/v3/Security/VexJustificationType/vulnerableCodeNotPresent"


# Provides a set of values to be used to describe the common types of SBOMs that tools may create.
class software_SbomType(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Software/SbomType"
    valid_values = [
        ("analyzed", "https://rdf.spdx.org/v3/Software/SbomType/analyzed"),
        ("build", "https://rdf.spdx.org/v3/Software/SbomType/build"),
        ("deployed", "https://rdf.spdx.org/v3/Software/SbomType/deployed"),
        ("design", "https://rdf.spdx.org/v3/Software/SbomType/design"),
        ("runtime", "https://rdf.spdx.org/v3/Software/SbomType/runtime"),
        ("source", "https://rdf.spdx.org/v3/Software/SbomType/source"),
    ]
    # SBOM generated through analysis of artifacts (e.g., executables, packages, containers, and virtual machine images) after its build. Such analysis generally requires a variety of heuristics. In some contexts, this may also be referred to as a “3rd party” SBOM.
    analyzed = "https://rdf.spdx.org/v3/Software/SbomType/analyzed"
    # SBOM generated as part of the process of building the software to create a releasable artifact (e.g., executable or package) from data such as source files, dependencies, built components, build process ephemeral data, and other SBOMs.
    build = "https://rdf.spdx.org/v3/Software/SbomType/build"
    # SBOM provides an inventory of software that is present on a system. This may be an assembly of other SBOMs that combines analysis of configuration options, and examination of execution behavior in a (potentially simulated) deployment environment.
    deployed = "https://rdf.spdx.org/v3/Software/SbomType/deployed"
    # SBOM of intended, planned software project or product with included components (some of which may not yet exist) for a new software artifact.
    design = "https://rdf.spdx.org/v3/Software/SbomType/design"
    # SBOM generated through instrumenting the system running the software, to capture only components present in the system, as well as external call-outs or dynamically loaded components. In some contexts, this may also be referred to as an “Instrumented” or “Dynamic” SBOM.
    runtime = "https://rdf.spdx.org/v3/Software/SbomType/runtime"
    # SBOM created directly from the development environment, source files, and included dependencies used to build an product artifact.
    source = "https://rdf.spdx.org/v3/Software/SbomType/source"


# Provides information about the primary purpose of an Element.
class software_SoftwarePurpose(EnumProp):
    TYPE = "https://rdf.spdx.org/v3/Software/SoftwarePurpose"
    valid_values = [
        ("application", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/application"),
        ("archive", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/archive"),
        ("bom", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/bom"),
        ("configuration", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/configuration"),
        ("container", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/container"),
        ("data", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/data"),
        ("device", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/device"),
        ("deviceDriver", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/deviceDriver"),
        ("diskImage", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/diskImage"),
        ("documentation", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/documentation"),
        ("evidence", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/evidence"),
        ("executable", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/executable"),
        ("file", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/file"),
        ("filesystemImage", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/filesystemImage"),
        ("firmware", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/firmware"),
        ("framework", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/framework"),
        ("install", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/install"),
        ("library", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/library"),
        ("manifest", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/manifest"),
        ("model", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/model"),
        ("module", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/module"),
        ("operatingSystem", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/operatingSystem"),
        ("other", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/other"),
        ("patch", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/patch"),
        ("platform", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/platform"),
        ("requirement", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/requirement"),
        ("source", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/source"),
        ("specification", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/specification"),
        ("test", "https://rdf.spdx.org/v3/Software/SoftwarePurpose/test"),
    ]
    # the Element is a software application
    application = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/application"
    # the Element is an archived collection of one or more files (.tar, .zip, etc)
    archive = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/archive"
    # Element is a bill of materials
    bom = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/bom"
    # Element is configuration data
    configuration = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/configuration"
    # the Element is a container image which can be used by a container runtime application
    container = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/container"
    # Element is data
    data = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/data"
    # the Element refers to a chipset, processor, or electronic board
    device = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/device"
    # Element represents software that controls hardware devices
    deviceDriver = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/deviceDriver"
    # the Element refers to a disk image that can be written to a disk, booted in a VM, etc. A disk image typically contains most or all of the components necessary to boot, such as bootloaders, kernels, firmware, userspace, etc.
    diskImage = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/diskImage"
    # Element is documentation
    documentation = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/documentation"
    # the Element is the evidence that a specification or requirement has been fulfilled
    evidence = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/evidence"
    # Element is an Artifact that can be run on a computer
    executable = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/executable"
    # the Element is a single file which can be independently distributed (configuration file, statically linked binary, Kubernetes deployment, etc)
    file = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/file"
    # the Element is a file system image that can be written to a disk (or virtual) partition
    filesystemImage = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/filesystemImage"
    # the Element provides low level control over a device's hardware
    firmware = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/firmware"
    # the Element is a software framework
    framework = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/framework"
    # the Element is used to install software on disk
    install = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/install"
    # the Element is a software library
    library = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/library"
    # the Element is a software manifest
    manifest = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/manifest"
    # the Element is a machine learning or artificial intelligence model
    model = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/model"
    # the Element is a module of a piece of software
    module = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/module"
    # the Element is an operating system
    operatingSystem = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/operatingSystem"
    # the Element doesn't fit into any of the other categories
    other = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/other"
    # Element contains a set of changes to update, fix, or improve another Element
    patch = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/patch"
    # Element represents a runtime environment
    platform = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/platform"
    # the Element provides a requirement needed as input for another Element
    requirement = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/requirement"
    # the Element is a single or a collection of source files
    source = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/source"
    # the Element is a plan, guideline or strategy how to create, perform or analyse an application
    specification = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/specification"
    # The Element is a test used to verify functionality on an software element
    test = "https://rdf.spdx.org/v3/Software/SoftwarePurpose/test"


# CLASSES
# Provides information about the creation of the Element.
class CreationInfo(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/CreationInfo"
    REFABLE = Refable.local
    ID_ALIAS = "id"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides a reference number that can be used to understand how to parse and interpret an Element.
        self._add_property(
            "specVersion",
            StringProp(pattern=r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$",),
            iri="https://rdf.spdx.org/v3/Core/specVersion",
            min_count=1,
        )
        # Provide consumers with comments by the creator of the Element about the Element.
        self._add_property(
            "comment",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/comment",
        )
        # Identifies when the Element was originally created.
        self._add_property(
            "created",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/created",
            min_count=1,
        )
        # Identifies who or what created the Element.
        self._add_property(
            "createdBy",
            ListProp(ObjectProp(Agent, False)),
            iri="https://rdf.spdx.org/v3/Core/createdBy",
            min_count=1,
        )
        # Identifies the tooling that was used during the creation of the Element.
        self._add_property(
            "createdUsing",
            ListProp(ObjectProp(Tool, False)),
            iri="https://rdf.spdx.org/v3/Core/createdUsing",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/CreationInfo"] = CreationInfo


# A key with an associated value.
class DictionaryEntry(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/DictionaryEntry"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # A key used in a generic key-value pair.
        self._add_property(
            "key",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/key",
            min_count=1,
        )
        # A value used in a generic key-value pair.
        self._add_property(
            "value",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/value",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/DictionaryEntry"] = DictionaryEntry


# Base domain class from which all other SPDX-3.0 domain classes derive.
class Element(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/Element"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies the name of an Element as designated by the creator.
        self._add_property(
            "name",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/name",
        )
        # A short description of an Element.
        self._add_property(
            "summary",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/summary",
        )
        # Provides a detailed description of the Element.
        self._add_property(
            "description",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/description",
        )
        # Provide consumers with comments by the creator of the Element about the Element.
        self._add_property(
            "comment",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/comment",
        )
        # Provides information about the creation of the Element.
        self._add_property(
            "creationInfo",
            ObjectProp(CreationInfo, True),
            iri="https://rdf.spdx.org/v3/Core/creationInfo",
            min_count=1,
        )
        # Provides an IntegrityMethod with which the integrity of an Element can be asserted.
        self._add_property(
            "verifiedUsing",
            ListProp(ObjectProp(IntegrityMethod, False)),
            iri="https://rdf.spdx.org/v3/Core/verifiedUsing",
        )
        # Points to a resource outside the scope of the SPDX-3.0 content
        # that provides additional characteristics of an Element.
        self._add_property(
            "externalRef",
            ListProp(ObjectProp(ExternalRef, False)),
            iri="https://rdf.spdx.org/v3/Core/externalRef",
        )
        # Provides a reference to a resource outside the scope of SPDX-3.0 content
        # that uniquely identifies an Element.
        self._add_property(
            "externalIdentifier",
            ListProp(ObjectProp(ExternalIdentifier, False)),
            iri="https://rdf.spdx.org/v3/Core/externalIdentifier",
        )
        # Specifies an Extension characterization of some aspect of an Element.
        self._add_property(
            "extension",
            ListProp(ObjectProp(extension_Extension, False)),
            iri="https://rdf.spdx.org/v3/Core/extension",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Element"] = Element


# A collection of Elements, not necessarily with unifying context.
class ElementCollection(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/ElementCollection"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Refers to one or more Elements that are part of an ElementCollection.
        self._add_property(
            "element",
            ListProp(ObjectProp(Element, False)),
            iri="https://rdf.spdx.org/v3/Core/element",
        )
        # This property is used to denote the root Element(s) of a tree of elements contained in an SBOM.
        self._add_property(
            "rootElement",
            ListProp(ObjectProp(Element, False)),
            iri="https://rdf.spdx.org/v3/Core/rootElement",
        )
        # Describes one a profile which the creator of this ElementCollection intends to conform to.
        self._add_property(
            "profileConformance",
            ListProp(ProfileIdentifierType()),
            iri="https://rdf.spdx.org/v3/Core/profileConformance",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/ElementCollection"] = ElementCollection


# A reference to a resource outside the scope of SPDX-3.0 content that uniquely identifies an Element.
class ExternalIdentifier(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/ExternalIdentifier"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the type of the external identifier.
        self._add_property(
            "externalIdentifierType",
            ExternalIdentifierType(),
            iri="https://rdf.spdx.org/v3/Core/externalIdentifierType",
            min_count=1,
        )
        # Uniquely identifies an external element.
        self._add_property(
            "identifier",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/identifier",
            min_count=1,
        )
        # Provide consumers with comments by the creator of the Element about the Element.
        self._add_property(
            "comment",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/comment",
        )
        # Provides the location for more information regarding an external identifier.
        self._add_property(
            "identifierLocator",
            ListProp(AnyURIProp()),
            iri="https://rdf.spdx.org/v3/Core/identifierLocator",
        )
        # An entity that is authorized to issue identification credentials.
        self._add_property(
            "issuingAuthority",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/issuingAuthority",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/ExternalIdentifier"] = ExternalIdentifier


# A map of Element identifiers that are used within a Document but defined external to that Document.
class ExternalMap(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/ExternalMap"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies an external Element used within a Document but defined external to that Document.
        self._add_property(
            "externalSpdxId",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Core/externalSpdxId",
            min_count=1,
        )
        # Provides an IntegrityMethod with which the integrity of an Element can be asserted.
        self._add_property(
            "verifiedUsing",
            ListProp(ObjectProp(IntegrityMethod, False)),
            iri="https://rdf.spdx.org/v3/Core/verifiedUsing",
        )
        # Provides an indication of where to retrieve an external Element.
        self._add_property(
            "locationHint",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Core/locationHint",
        )
        # Artifact representing a serialization instance of SPDX data containing the definition of a particular Element.
        self._add_property(
            "definingArtifact",
            ObjectProp(Artifact, False),
            iri="https://rdf.spdx.org/v3/Core/definingArtifact",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/ExternalMap"] = ExternalMap


# A reference to a resource outside the scope of SPDX-3.0 content.
class ExternalRef(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/ExternalRef"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the type of the external reference.
        self._add_property(
            "externalRefType",
            ExternalRefType(),
            iri="https://rdf.spdx.org/v3/Core/externalRefType",
        )
        # Provides the location of an external reference.
        self._add_property(
            "locator",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Core/locator",
        )
        # Specifies the media type of an Element or Property.
        self._add_property(
            "contentType",
            StringProp(pattern=r"^[^\/]+\/[^\/]+$",),
            iri="https://rdf.spdx.org/v3/Core/contentType",
        )
        # Provide consumers with comments by the creator of the Element about the Element.
        self._add_property(
            "comment",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/comment",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/ExternalRef"] = ExternalRef


# Provides an independently reproducible mechanism that permits verification of a specific Element.
class IntegrityMethod(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/IntegrityMethod"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Provide consumers with comments by the creator of the Element about the Element.
        self._add_property(
            "comment",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/comment",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/IntegrityMethod"] = IntegrityMethod


# A mapping between prefixes and namespace partial URIs.
class NamespaceMap(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/NamespaceMap"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # A substitute for a URI.
        self._add_property(
            "prefix",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/prefix",
            min_count=1,
        )
        # Provides an unambiguous mechanism for conveying a URI fragment portion of an ElementID.
        self._add_property(
            "namespace",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Core/namespace",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/NamespaceMap"] = NamespaceMap


# An SPDX version 2.X compatible verification method for software packages.
class PackageVerificationCode(IntegrityMethod):
    TYPE = "https://rdf.spdx.org/v3/Core/PackageVerificationCode"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # The result of applying a hash algorithm to an Element.
        self._add_property(
            "hashValue",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/hashValue",
            min_count=1,
        )
        # The relative file name of a file to be excluded from the `PackageVerificationCode`.
        self._add_property(
            "packageVerificationCodeExcludedFile",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Core/packageVerificationCodeExcludedFile",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/PackageVerificationCode"] = PackageVerificationCode


# A tuple of two positive integers that define a range.
class PositiveIntegerRange(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Core/PositiveIntegerRange"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Defines the beginning of a range.
        self._add_property(
            "beginIntegerRange",
            PositiveIntegerProp(),
            iri="https://rdf.spdx.org/v3/Core/beginIntegerRange",
            min_count=1,
        )
        # Defines the end of a range.
        self._add_property(
            "endIntegerRange",
            PositiveIntegerProp(),
            iri="https://rdf.spdx.org/v3/Core/endIntegerRange",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/PositiveIntegerRange"] = PositiveIntegerRange


# Describes a relationship between one or more elements.
class Relationship(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/Relationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # References the Element on the left-hand side of a relationship.
        self._add_property(
            "from_",
            ObjectProp(Element, True),
            iri="https://rdf.spdx.org/v3/Core/from",
            min_count=1,
        )
        # References an Element on the right-hand side of a relationship.
        self._add_property(
            "to",
            ListProp(ObjectProp(Element, False)),
            iri="https://rdf.spdx.org/v3/Core/to",
        )
        # Information about the relationship between two Elements.
        self._add_property(
            "relationshipType",
            RelationshipType(),
            iri="https://rdf.spdx.org/v3/Core/relationshipType",
            min_count=1,
        )
        # Provides information about the completeness of relationships.
        self._add_property(
            "completeness",
            RelationshipCompleteness(),
            iri="https://rdf.spdx.org/v3/Core/completeness",
        )
        # Specifies the time from which an element is applicable / valid.
        self._add_property(
            "startTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/startTime",
        )
        # Specifies the time from which an element is no longer applicable / valid.
        self._add_property(
            "endTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/endTime",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Relationship"] = Relationship


# A collection of SPDX Elements that could potentially be serialized.
class SpdxDocument(ElementCollection):
    TYPE = "https://rdf.spdx.org/v3/Core/SpdxDocument"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides an ExternalMap of Element identifiers.
        self._add_property(
            "imports",
            ListProp(ObjectProp(ExternalMap, False)),
            iri="https://rdf.spdx.org/v3/Core/imports",
        )
        # Provides a NamespaceMap of prefixes and associated namespace partial URIs applicable to an SpdxDocument and independent of any specific serialization format or instance.
        self._add_property(
            "namespaceMap",
            ListProp(ObjectProp(NamespaceMap, False)),
            iri="https://rdf.spdx.org/v3/Core/namespaceMap",
        )
        # Provides the license under which the SPDX documentation of the Element can be used.
        self._add_property(
            "dataLicense",
            ObjectProp(simplelicensing_AnyLicenseInfo, False),
            iri="https://rdf.spdx.org/v3/Core/dataLicense",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/SpdxDocument"] = SpdxDocument


# An element of hardware and/or software utilized to carry out a particular function.
class Tool(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/Tool"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Tool"] = Tool


# Abstract class for additional text intended to be added to a License, but
# which is not itself a standalone License.
class expandedlicensing_LicenseAddition(Element):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/LicenseAddition"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies the full text of a LicenseAddition.
        self._add_property(
            "expandedlicensing_additionText",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/additionText",
            min_count=1,
        )
        # Identifies the full text of a LicenseAddition, in SPDX templating format.
        self._add_property(
            "expandedlicensing_standardAdditionTemplate",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/standardAdditionTemplate",
        )
        # Specifies whether an additional text identifier has been marked as deprecated.
        self._add_property(
            "expandedlicensing_isDeprecatedAdditionId",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/isDeprecatedAdditionId",
        )
        # Specifies the licenseId that is preferred to be used in place of a deprecated
        # License or LicenseAddition.
        self._add_property(
            "expandedlicensing_obsoletedBy",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/obsoletedBy",
        )
        # Identifies all the text and metadata associated with a license in the license XML format.
        self._add_property(
            "expandedlicensing_licenseXml",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/licenseXml",
        )
        # Contains a URL where the License or LicenseAddition can be found in use.
        self._add_property(
            "expandedlicensing_seeAlso",
            ListProp(AnyURIProp()),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/seeAlso",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/LicenseAddition"] = expandedlicensing_LicenseAddition


# A license exception that is listed on the SPDX Exceptions list.
class expandedlicensing_ListedLicenseException(expandedlicensing_LicenseAddition):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicenseException"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the SPDX License List version in which this ListedLicense or
        # ListedLicenseException identifier was first added.
        self._add_property(
            "expandedlicensing_listVersionAdded",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/listVersionAdded",
        )
        # Specifies the SPDX License List version in which this license or exception
        # identifier was deprecated.
        self._add_property(
            "expandedlicensing_deprecatedVersion",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/deprecatedVersion",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicenseException"] = expandedlicensing_ListedLicenseException


# A characterization of some aspect of an Element that is associated with the Element in a generalized fashion.
class extension_Extension(SHACLObject):
    TYPE = "https://rdf.spdx.org/v3/Extension/Extension"
    REFABLE = Refable.optional

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Extension/Extension"] = extension_Extension


# Abstract ancestor class for all vulnerability assessments
class security_VulnAssessmentRelationship(Relationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies an element contained in a piece of software where a vulnerability was
        # found.
        self._add_property(
            "security_assessedElement",
            ObjectProp(Element, False),
            iri="https://rdf.spdx.org/v3/Security/assessedElement",
        )
        # Specifies the time when a vulnerability was published.
        self._add_property(
            "security_publishedTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/publishedTime",
        )
        # Identifies who or what supplied the artifact or VulnAssessmentRelationship referenced by the Element.
        self._add_property(
            "suppliedBy",
            ObjectProp(Agent, False),
            iri="https://rdf.spdx.org/v3/Core/suppliedBy",
        )
        # Specifies a time when a vulnerability assessment was modified
        self._add_property(
            "security_modifiedTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/modifiedTime",
        )
        # Specified the time and date when a vulnerability was withdrawn.
        self._add_property(
            "security_withdrawnTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/withdrawnTime",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VulnAssessmentRelationship"] = security_VulnAssessmentRelationship


# Abstract class representing a license combination consisting of one or more
# licenses (optionally including additional text), which may be combined
# according to the SPDX license expression syntax.
class simplelicensing_AnyLicenseInfo(Element):
    TYPE = "https://rdf.spdx.org/v3/SimpleLicensing/AnyLicenseInfo"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/SimpleLicensing/AnyLicenseInfo"] = simplelicensing_AnyLicenseInfo


# An SPDX Element containing an SPDX license expression string.
class simplelicensing_LicenseExpression(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/SimpleLicensing/LicenseExpression"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A string in the license expression format.
        self._add_property(
            "simplelicensing_licenseExpression",
            StringProp(),
            iri="https://rdf.spdx.org/v3/SimpleLicensing/licenseExpression",
            min_count=1,
        )
        # The version of the SPDX License List used in the license expression.
        self._add_property(
            "simplelicensing_licenseListVersion",
            StringProp(pattern=r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$",),
            iri="https://rdf.spdx.org/v3/SimpleLicensing/licenseListVersion",
        )
        # Maps a LicenseRef or AdditionRef string for a Custom License or a Custom License Addition to its URI ID.
        self._add_property(
            "simplelicensing_customIdToUri",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/SimpleLicensing/customIdToUri",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/SimpleLicensing/LicenseExpression"] = simplelicensing_LicenseExpression


# A license or addition that is not listed on the SPDX License List.
class simplelicensing_SimpleLicensingText(Element):
    TYPE = "https://rdf.spdx.org/v3/SimpleLicensing/SimpleLicensingText"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies the full text of a License or Addition.
        self._add_property(
            "simplelicensing_licenseText",
            StringProp(),
            iri="https://rdf.spdx.org/v3/SimpleLicensing/licenseText",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/SimpleLicensing/SimpleLicensingText"] = simplelicensing_SimpleLicensingText


# Class that describes a build instance of software/artifacts.
class build_Build(Element):
    TYPE = "https://rdf.spdx.org/v3/Build/Build"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A buildType is a hint that is used to indicate the toolchain, platform, or infrastructure that the build was invoked on.
        self._add_property(
            "build_buildType",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Build/buildType",
            min_count=1,
        )
        # A buildId is a locally unique identifier used by a builder to identify a unique instance of a build produced by it.
        self._add_property(
            "build_buildId",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Build/buildId",
        )
        # Property describes the invocation entrypoint of a build.
        self._add_property(
            "build_configSourceEntrypoint",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Build/configSourceEntrypoint",
        )
        # Property that describes the URI of the build configuration source file.
        self._add_property(
            "build_configSourceUri",
            ListProp(AnyURIProp()),
            iri="https://rdf.spdx.org/v3/Build/configSourceUri",
        )
        # Property that describes the digest of the build configuration file used to invoke a build.
        self._add_property(
            "build_configSourceDigest",
            ListProp(ObjectProp(Hash, False)),
            iri="https://rdf.spdx.org/v3/Build/configSourceDigest",
        )
        # Property describing the parameters used in an instance of a build.
        self._add_property(
            "build_parameters",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/Build/parameters",
        )
        # Property describing the start time of a build.
        self._add_property(
            "build_buildStartTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Build/buildStartTime",
        )
        # Property that describes the time at which a build stops.
        self._add_property(
            "build_buildEndTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Build/buildEndTime",
        )
        # Property describing the session in which a build is invoked.
        self._add_property(
            "build_environment",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/Build/environment",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Build/Build"] = build_Build


# Agent represents anything with the potential to act on a system.
class Agent(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/Agent"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Agent"] = Agent


# An assertion made in relation to one or more elements.
class Annotation(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/Annotation"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Describes the type of annotation.
        self._add_property(
            "annotationType",
            AnnotationType(),
            iri="https://rdf.spdx.org/v3/Core/annotationType",
            min_count=1,
        )
        # Specifies the media type of an Element or Property.
        self._add_property(
            "contentType",
            StringProp(pattern=r"^[^\/]+\/[^\/]+$",),
            iri="https://rdf.spdx.org/v3/Core/contentType",
        )
        # Commentary on an assertion that an annotator has made.
        self._add_property(
            "statement",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/statement",
        )
        # An Element an annotator has made an assertion about.
        self._add_property(
            "subject",
            ObjectProp(Element, True),
            iri="https://rdf.spdx.org/v3/Core/subject",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Annotation"] = Annotation


# A distinct article or unit within the digital domain.
class Artifact(Element):
    TYPE = "https://rdf.spdx.org/v3/Core/Artifact"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies from where or whom the Element originally came.
        self._add_property(
            "originatedBy",
            ListProp(ObjectProp(Agent, False)),
            iri="https://rdf.spdx.org/v3/Core/originatedBy",
        )
        # Identifies who or what supplied the artifact or VulnAssessmentRelationship referenced by the Element.
        self._add_property(
            "suppliedBy",
            ObjectProp(Agent, False),
            iri="https://rdf.spdx.org/v3/Core/suppliedBy",
        )
        # Specifies the time an artifact was built.
        self._add_property(
            "builtTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/builtTime",
        )
        # Specifies the time an artifact was released.
        self._add_property(
            "releaseTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/releaseTime",
        )
        # Specifies until when the artifact can be used before its usage needs to be reassessed.
        self._add_property(
            "validUntilTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Core/validUntilTime",
        )
        # The name of a relevant standard that may apply to an artifact.
        self._add_property(
            "standardName",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Core/standardName",
        )
        # Specifies the level of support associated with an artifact.
        self._add_property(
            "supportLevel",
            ListProp(SupportType()),
            iri="https://rdf.spdx.org/v3/Core/supportLevel",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Artifact"] = Artifact


# A collection of Elements that have a shared context.
class Bundle(ElementCollection):
    TYPE = "https://rdf.spdx.org/v3/Core/Bundle"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Gives information about the circumstances or unifying properties
        # that Elements of the bundle have been assembled under.
        self._add_property(
            "context",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/context",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Bundle"] = Bundle


# A mathematically calculated representation of a grouping of data.
class Hash(IntegrityMethod):
    TYPE = "https://rdf.spdx.org/v3/Core/Hash"
    REFABLE = Refable.no

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the algorithm used for calculating the hash value.
        self._add_property(
            "algorithm",
            HashAlgorithm(),
            iri="https://rdf.spdx.org/v3/Core/algorithm",
            min_count=1,
        )
        # The result of applying a hash algorithm to an Element.
        self._add_property(
            "hashValue",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Core/hashValue",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Hash"] = Hash


# Provide context for a relationship that occurs in the software lifecycle.
class LifecycleScopedRelationship(Relationship):
    TYPE = "https://rdf.spdx.org/v3/Core/LifecycleScopedRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Capture the scope of information about a specific relationship between elements.
        self._add_property(
            "scope",
            LifecycleScopeType(),
            iri="https://rdf.spdx.org/v3/Core/scope",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/LifecycleScopedRelationship"] = LifecycleScopedRelationship


# A group of people who work together in an organized way for a shared purpose.
class Organization(Agent):
    TYPE = "https://rdf.spdx.org/v3/Core/Organization"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Organization"] = Organization


# An individual human being.
class Person(Agent):
    TYPE = "https://rdf.spdx.org/v3/Core/Person"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Person"] = Person


# A software agent.
class SoftwareAgent(Agent):
    TYPE = "https://rdf.spdx.org/v3/Core/SoftwareAgent"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/SoftwareAgent"] = SoftwareAgent


# Portion of an AnyLicenseInfo representing a set of licensing information
# where all elements apply.
class expandedlicensing_ConjunctiveLicenseSet(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/ConjunctiveLicenseSet"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A license expression participating in a license set.
        self._add_property(
            "expandedlicensing_member",
            ListProp(ObjectProp(simplelicensing_AnyLicenseInfo, False)),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/member",
            min_count=2,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/ConjunctiveLicenseSet"] = expandedlicensing_ConjunctiveLicenseSet


# A license addition that is not listed on the SPDX Exceptions List.
class expandedlicensing_CustomLicenseAddition(expandedlicensing_LicenseAddition):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicenseAddition"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicenseAddition"] = expandedlicensing_CustomLicenseAddition


# Portion of an AnyLicenseInfo representing a set of licensing information
# where only any one of the elements applies.
class expandedlicensing_DisjunctiveLicenseSet(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/DisjunctiveLicenseSet"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A license expression participating in a license set.
        self._add_property(
            "expandedlicensing_member",
            ListProp(ObjectProp(simplelicensing_AnyLicenseInfo, False)),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/member",
            min_count=2,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/DisjunctiveLicenseSet"] = expandedlicensing_DisjunctiveLicenseSet


# Abstract class representing a License or an OrLaterOperator.
class expandedlicensing_ExtendableLicense(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/ExtendableLicense"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/ExtendableLicense"] = expandedlicensing_ExtendableLicense


# A concrete subclass of AnyLicenseInfo used by Individuals in the ExpandedLicensing profile.
class expandedlicensing_IndividualLicensingInfo(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/IndividualLicensingInfo"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/IndividualLicensingInfo"] = expandedlicensing_IndividualLicensingInfo


# Abstract class for the portion of an AnyLicenseInfo representing a license.
class expandedlicensing_License(expandedlicensing_ExtendableLicense):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/License"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identifies the full text of a License or Addition.
        self._add_property(
            "simplelicensing_licenseText",
            StringProp(),
            iri="https://rdf.spdx.org/v3/SimpleLicensing/licenseText",
            min_count=1,
        )
        # Specifies whether the License is listed as approved by the
        # [Open Source Initiative (OSI)](https://opensource.org).
        self._add_property(
            "expandedlicensing_isOsiApproved",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/isOsiApproved",
        )
        # Specifies whether the License is listed as free by the
        # [Free Software Foundation (FSF)](https://fsf.org).
        self._add_property(
            "expandedlicensing_isFsfLibre",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/isFsfLibre",
        )
        # Provides a License author's preferred text to indicate that a file is covered
        # by the License.
        self._add_property(
            "expandedlicensing_standardLicenseHeader",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/standardLicenseHeader",
        )
        # Identifies the full text of a License, in SPDX templating format.
        self._add_property(
            "expandedlicensing_standardLicenseTemplate",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/standardLicenseTemplate",
        )
        # Specifies whether a license or additional text identifier has been marked as
        # deprecated.
        self._add_property(
            "expandedlicensing_isDeprecatedLicenseId",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/isDeprecatedLicenseId",
        )
        # Specifies the licenseId that is preferred to be used in place of a deprecated
        # License or LicenseAddition.
        self._add_property(
            "expandedlicensing_obsoletedBy",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/obsoletedBy",
        )
        # Identifies all the text and metadata associated with a license in the license XML format.
        self._add_property(
            "expandedlicensing_licenseXml",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/licenseXml",
        )
        # Contains a URL where the License or LicenseAddition can be found in use.
        self._add_property(
            "expandedlicensing_seeAlso",
            ListProp(AnyURIProp()),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/seeAlso",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/License"] = expandedlicensing_License


# A license that is listed on the SPDX License List.
class expandedlicensing_ListedLicense(expandedlicensing_License):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicense"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the SPDX License List version in which this ListedLicense or
        # ListedLicenseException identifier was first added.
        self._add_property(
            "expandedlicensing_listVersionAdded",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/listVersionAdded",
        )
        # Specifies the SPDX License List version in which this license or exception
        # identifier was deprecated.
        self._add_property(
            "expandedlicensing_deprecatedVersion",
            StringProp(),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/deprecatedVersion",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/ListedLicense"] = expandedlicensing_ListedLicense


# Portion of an AnyLicenseInfo representing this version, or any later version,
# of the indicated License.
class expandedlicensing_OrLaterOperator(expandedlicensing_ExtendableLicense):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/OrLaterOperator"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A License participating in an 'or later' model.
        self._add_property(
            "expandedlicensing_subjectLicense",
            ObjectProp(expandedlicensing_License, True),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/subjectLicense",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/OrLaterOperator"] = expandedlicensing_OrLaterOperator


# Portion of an AnyLicenseInfo representing a License which has additional
# text applied to it.
class expandedlicensing_WithAdditionOperator(simplelicensing_AnyLicenseInfo):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/WithAdditionOperator"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A License participating in a 'with addition' model.
        self._add_property(
            "expandedlicensing_subjectExtendableLicense",
            ObjectProp(expandedlicensing_ExtendableLicense, True),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/subjectExtendableLicense",
            min_count=1,
        )
        # A LicenseAddition participating in a 'with addition' model.
        self._add_property(
            "expandedlicensing_subjectAddition",
            ObjectProp(expandedlicensing_LicenseAddition, True),
            iri="https://rdf.spdx.org/v3/ExpandedLicensing/subjectAddition",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/WithAdditionOperator"] = expandedlicensing_WithAdditionOperator


# Provides a CVSS version 2.0 assessment for a vulnerability.
class security_CvssV2VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/CvssV2VulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides a numerical (0-10) representation of the severity of a vulnerability.
        self._add_property(
            "security_score",
            FloatProp(),
            iri="https://rdf.spdx.org/v3/Security/score",
            min_count=1,
        )
        # Specifies the CVSS vector string for a vulnerability.
        self._add_property(
            "security_vectorString",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/CvssV2VulnAssessmentRelationship"] = security_CvssV2VulnAssessmentRelationship


# Provides a CVSS version 3 assessment for a vulnerability.
class security_CvssV3VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/CvssV3VulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides a numerical (0-10) representation of the severity of a vulnerability.
        self._add_property(
            "security_score",
            FloatProp(),
            iri="https://rdf.spdx.org/v3/Security/score",
            min_count=1,
        )
        # Specifies the CVSS qualitative severity rating of a vulnerability in relation to a piece of software.
        self._add_property(
            "security_severity",
            security_CvssSeverityType(),
            iri="https://rdf.spdx.org/v3/Security/severity",
            min_count=1,
        )
        # Specifies the CVSS vector string for a vulnerability.
        self._add_property(
            "security_vectorString",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/CvssV3VulnAssessmentRelationship"] = security_CvssV3VulnAssessmentRelationship


# Provides a CVSS version 4 assessment for a vulnerability.
class security_CvssV4VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/CvssV4VulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides a numerical (0-10) representation of the severity of a vulnerability.
        self._add_property(
            "security_score",
            FloatProp(),
            iri="https://rdf.spdx.org/v3/Security/score",
            min_count=1,
        )
        # Specifies the CVSS qualitative severity rating of a vulnerability in relation to a piece of software.
        self._add_property(
            "security_severity",
            security_CvssSeverityType(),
            iri="https://rdf.spdx.org/v3/Security/severity",
            min_count=1,
        )
        # Specifies the CVSS vector string for a vulnerability.
        self._add_property(
            "security_vectorString",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/CvssV4VulnAssessmentRelationship"] = security_CvssV4VulnAssessmentRelationship


# Provides an EPSS assessment for a vulnerability.
class security_EpssVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/EpssVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # A probability score between 0 and 1 of a vulnerability being exploited.
        self._add_property(
            "security_probability",
            FloatProp(),
            iri="https://rdf.spdx.org/v3/Security/probability",
            min_count=1,
        )
        # The percentile of the current probability score.
        self._add_property(
            "security_percentile",
            FloatProp(),
            iri="https://rdf.spdx.org/v3/Security/percentile",
            min_count=1,
        )
        # Specifies the time when a vulnerability was published.
        self._add_property(
            "security_publishedTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/publishedTime",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/EpssVulnAssessmentRelationship"] = security_EpssVulnAssessmentRelationship


# Provides an exploit assessment of a vulnerability.
class security_ExploitCatalogVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/ExploitCatalogVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the exploit catalog type.
        self._add_property(
            "security_catalogType",
            security_ExploitCatalogType(),
            iri="https://rdf.spdx.org/v3/Security/catalogType",
            min_count=1,
        )
        # Describe that a CVE is known to have an exploit because it's been listed in an exploit catalog.
        self._add_property(
            "security_exploited",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/Security/exploited",
            min_count=1,
        )
        # Provides the location of an exploit catalog.
        self._add_property(
            "security_locator",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Security/locator",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/ExploitCatalogVulnAssessmentRelationship"] = security_ExploitCatalogVulnAssessmentRelationship


# Provides an SSVC assessment for a vulnerability.
class security_SsvcVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/SsvcVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provide the enumeration of possible decisions in the Stakeholder-Specific Vulnerability Categorization (SSVC) decision tree [https://www.cisa.gov/sites/default/files/publications/cisa-ssvc-guide%20508c.pdf](https://www.cisa.gov/sites/default/files/publications/cisa-ssvc-guide%20508c.pdf)
        self._add_property(
            "security_decisionType",
            security_SsvcDecisionType(),
            iri="https://rdf.spdx.org/v3/Security/decisionType",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/SsvcVulnAssessmentRelationship"] = security_SsvcVulnAssessmentRelationship


# Asbtract ancestor class for all VEX relationships
class security_VexVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VexVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the version of the VEX document.
        self._add_property(
            "security_vexVersion",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/vexVersion",
        )
        # Conveys information about how VEX status was determined.
        self._add_property(
            "security_statusNotes",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/statusNotes",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VexVulnAssessmentRelationship"] = security_VexVulnAssessmentRelationship


# Specifies a vulnerability and its associated information.
class security_Vulnerability(Artifact):
    TYPE = "https://rdf.spdx.org/v3/Security/Vulnerability"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the time when a vulnerability was published.
        self._add_property(
            "security_publishedTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/publishedTime",
        )
        # Specifies a time when a vulnerability assessment was modified
        self._add_property(
            "security_modifiedTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/modifiedTime",
        )
        # Specified the time and date when a vulnerability was withdrawn.
        self._add_property(
            "security_withdrawnTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/withdrawnTime",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/Vulnerability"] = security_Vulnerability


# A distinct article or unit related to Software.
class software_SoftwareArtifact(Artifact):
    TYPE = "https://rdf.spdx.org/v3/Software/SoftwareArtifact"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Used to record the artifact’s gitoid: a canonical, unique, immutable identifier that can be used for software integrity verification.
        self._add_property(
            "software_gitoid",
            ListProp(AnyURIProp()),
            iri="https://rdf.spdx.org/v3/Software/gitoid",
            max_count=2,
        )
        # Provides information about the primary purpose of the software artifact.
        self._add_property(
            "software_primaryPurpose",
            software_SoftwarePurpose(),
            iri="https://rdf.spdx.org/v3/Software/primaryPurpose",
        )
        # Provides additional purpose information of the software artifact.
        self._add_property(
            "software_additionalPurpose",
            ListProp(software_SoftwarePurpose()),
            iri="https://rdf.spdx.org/v3/Software/additionalPurpose",
        )
        # Identifies the text of one or more copyright notices for a software Package,
        # File or Snippet, if any.
        self._add_property(
            "software_copyrightText",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Software/copyrightText",
        )
        # Provides a place for the SPDX data creator to record acknowledgement text for
        # a software Package, File or Snippet.
        self._add_property(
            "software_attributionText",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Software/attributionText",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Software/SoftwareArtifact"] = software_SoftwareArtifact


# A container for a grouping of SPDX-3.0 content characterizing details
# (provenence, composition, licensing, etc.) about a product.
class Bom(Bundle):
    TYPE = "https://rdf.spdx.org/v3/Core/Bom"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Core/Bom"] = Bom


# A license that is not listed on the SPDX License List.
class expandedlicensing_CustomLicense(expandedlicensing_License):
    TYPE = "https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicense"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/ExpandedLicensing/CustomLicense"] = expandedlicensing_CustomLicense


# Connects a vulnerability and an element designating the element as a product
# affected by the vulnerability.
class security_VexAffectedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VexAffectedVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides advise on how to mitigate or remediate a vulnerability when a VEX product
        # is affected by it.
        self._add_property(
            "security_actionStatement",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/actionStatement",
        )
        # Records the time when a recommended action was communicated in a VEX statement
        # to mitigate a vulnerability.
        self._add_property(
            "security_actionStatementTime",
            ListProp(StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",)),
            iri="https://rdf.spdx.org/v3/Security/actionStatementTime",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VexAffectedVulnAssessmentRelationship"] = security_VexAffectedVulnAssessmentRelationship


# Links a vulnerability and elements representing products (in the VEX sense) where
# a fix has been applied and are no longer affected.
class security_VexFixedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VexFixedVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VexFixedVulnAssessmentRelationship"] = security_VexFixedVulnAssessmentRelationship


# Links a vulnerability and one or more elements designating the latter as products
# not affected by the vulnerability.
class security_VexNotAffectedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VexNotAffectedVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Impact justification label to be used when linking a vulnerability to an element
        # representing a VEX product with a VexNotAffectedVulnAssessmentRelationship
        # relationship.
        self._add_property(
            "security_justificationType",
            security_VexJustificationType(),
            iri="https://rdf.spdx.org/v3/Security/justificationType",
        )
        # Explains why a VEX product is not affected by a vulnerability. It is an
        # alternative in VexNotAffectedVulnAssessmentRelationship to the machine-readable
        # justification label.
        self._add_property(
            "security_impactStatement",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Security/impactStatement",
        )
        # Timestamp of impact statement.
        self._add_property(
            "security_impactStatementTime",
            StringProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="https://rdf.spdx.org/v3/Security/impactStatementTime",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VexNotAffectedVulnAssessmentRelationship"] = security_VexNotAffectedVulnAssessmentRelationship


# Designates elements as products where the impact of a vulnerability is being
# investigated.
class security_VexUnderInvestigationVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://rdf.spdx.org/v3/Security/VexUnderInvestigationVulnAssessmentRelationship"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Security/VexUnderInvestigationVulnAssessmentRelationship"] = security_VexUnderInvestigationVulnAssessmentRelationship


# Refers to any object that stores content on a computer.
class software_File(software_SoftwareArtifact):
    TYPE = "https://rdf.spdx.org/v3/Software/File"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides information about the content type of an Element.
        self._add_property(
            "software_contentType",
            StringProp(pattern=r"^[^\/]+\/[^\/]+$",),
            iri="https://rdf.spdx.org/v3/Software/contentType",
        )
        # If true, denotes the Element is a directory.
        self._add_property(
            "software_isDirectory",
            BooleanProp(),
            iri="https://rdf.spdx.org/v3/Software/isDirectory",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Software/File"] = software_File


# Refers to any unit of content that can be associated with a distribution of software.
class software_Package(software_SoftwareArtifact):
    TYPE = "https://rdf.spdx.org/v3/Software/Package"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Identify the version of a package.
        self._add_property(
            "software_packageVersion",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Software/packageVersion",
        )
        # Identifies the download Uniform Resource Identifier for the package at the time that the document was created.
        self._add_property(
            "software_downloadLocation",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Software/downloadLocation",
        )
        # Provides a place for the SPDX data creator to record the package URL string (in accordance with the [package URL spec](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst)) for a software Package.
        self._add_property(
            "software_packageUrl",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Software/packageUrl",
        )
        # A place for the SPDX document creator to record a website that serves as the package's home page.
        self._add_property(
            "software_homePage",
            AnyURIProp(),
            iri="https://rdf.spdx.org/v3/Software/homePage",
        )
        # Records any relevant background information or additional comments
        # about the origin of the package.
        self._add_property(
            "software_sourceInfo",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Software/sourceInfo",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Software/Package"] = software_Package


# A collection of SPDX Elements describing a single package.
class software_Sbom(Bom):
    TYPE = "https://rdf.spdx.org/v3/Software/Sbom"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Provides information about the type of an SBOM.
        self._add_property(
            "software_sbomType",
            ListProp(software_SbomType()),
            iri="https://rdf.spdx.org/v3/Software/sbomType",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Software/Sbom"] = software_Sbom


# Describes a certain part of a file.
class software_Snippet(software_SoftwareArtifact):
    TYPE = "https://rdf.spdx.org/v3/Software/Snippet"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Defines the byte range in the original host file that the snippet information applies to.
        self._add_property(
            "software_byteRange",
            ObjectProp(PositiveIntegerRange, False),
            iri="https://rdf.spdx.org/v3/Software/byteRange",
        )
        # Defines the line range in the original host file that the snippet information applies to.
        self._add_property(
            "software_lineRange",
            ObjectProp(PositiveIntegerRange, False),
            iri="https://rdf.spdx.org/v3/Software/lineRange",
        )
        # Defines the original host file that the snippet information applies to.
        self._add_property(
            "software_snippetFromFile",
            ObjectProp(software_File, True),
            iri="https://rdf.spdx.org/v3/Software/snippetFromFile",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Software/Snippet"] = software_Snippet


# Provides information about the fields in the AI package profile.
class ai_AIPackage(software_Package):
    TYPE = "https://rdf.spdx.org/v3/AI/AIPackage"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Indicates the amount of energy consumed to build the AI package.
        self._add_property(
            "ai_energyConsumption",
            StringProp(),
            iri="https://rdf.spdx.org/v3/AI/energyConsumption",
        )
        # Captures a standard that is being complied with.
        self._add_property(
            "ai_standardCompliance",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/AI/standardCompliance",
        )
        # Captures a limitation of the AI software.
        self._add_property(
            "ai_limitation",
            StringProp(),
            iri="https://rdf.spdx.org/v3/AI/limitation",
        )
        # Records the type of the model used in the AI software.
        self._add_property(
            "ai_typeOfModel",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/AI/typeOfModel",
        )
        # Describes relevant information about different steps of the training process.
        self._add_property(
            "ai_informationAboutTraining",
            StringProp(),
            iri="https://rdf.spdx.org/v3/AI/informationAboutTraining",
        )
        # Provides relevant information about the AI software, not including the model description.
        self._add_property(
            "ai_informationAboutApplication",
            StringProp(),
            iri="https://rdf.spdx.org/v3/AI/informationAboutApplication",
        )
        # Records a hyperparameter used to build the AI model contained in the AI package.
        self._add_property(
            "ai_hyperparameter",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/AI/hyperparameter",
        )
        # Describes all the preprocessing steps applied to the training data before the model training.
        self._add_property(
            "ai_modelDataPreprocessing",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/AI/modelDataPreprocessing",
        )
        # Describes methods that can be used to explain the model.
        self._add_property(
            "ai_modelExplainability",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/AI/modelExplainability",
        )
        # Records if sensitive personal information is used during model training.
        self._add_property(
            "ai_sensitivePersonalInformation",
            PresenceType(),
            iri="https://rdf.spdx.org/v3/AI/sensitivePersonalInformation",
        )
        # Captures the threshold that was used for computation of a metric described in the metric field.
        self._add_property(
            "ai_metricDecisionThreshold",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/AI/metricDecisionThreshold",
        )
        # Records the measurement of prediction quality of the AI model.
        self._add_property(
            "ai_metric",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/AI/metric",
        )
        # Captures the domain in which the AI package can be used.
        self._add_property(
            "ai_domain",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/AI/domain",
        )
        # States if a human is involved in the decisions of the AI software.
        self._add_property(
            "ai_autonomyType",
            PresenceType(),
            iri="https://rdf.spdx.org/v3/AI/autonomyType",
        )
        # Categorizes safety risk impact of AI software.
        self._add_property(
            "ai_safetyRiskAssessment",
            ai_SafetyRiskAssessmentType(),
            iri="https://rdf.spdx.org/v3/AI/safetyRiskAssessment",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/AI/AIPackage"] = ai_AIPackage


# Provides information about the fields in the Dataset profile.
class dataset_Dataset(software_Package):
    TYPE = "https://rdf.spdx.org/v3/Dataset/Dataset"
    REFABLE = Refable.yes
    ID_ALIAS = "spdxId"

    def __init__(self, **kwargs):
        super().__init__()
        # Describes the type of the given dataset.
        self._add_property(
            "dataset_datasetType",
            ListProp(dataset_DatasetType()),
            iri="https://rdf.spdx.org/v3/Dataset/datasetType",
            min_count=1,
        )
        # Describes how the dataset was collected.
        self._add_property(
            "dataset_dataCollectionProcess",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Dataset/dataCollectionProcess",
        )
        # Describes what the given dataset should be used for.
        self._add_property(
            "dataset_intendedUse",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Dataset/intendedUse",
        )
        # Captures the size of the dataset.
        self._add_property(
            "dataset_datasetSize",
            NonNegativeIntegerProp(),
            iri="https://rdf.spdx.org/v3/Dataset/datasetSize",
        )
        # Describes potentially noisy elements of the dataset.
        self._add_property(
            "dataset_datasetNoise",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Dataset/datasetNoise",
        )
        # Describes the preprocessing steps that were applied to the raw data to create the given dataset.
        self._add_property(
            "dataset_dataPreprocessing",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Dataset/dataPreprocessing",
        )
        # Describes a sensor used for collecting the data.
        self._add_property(
            "dataset_sensor",
            ListProp(ObjectProp(DictionaryEntry, False)),
            iri="https://rdf.spdx.org/v3/Dataset/sensor",
        )
        # Records the biases that the dataset is known to encompass.
        self._add_property(
            "dataset_knownBias",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Dataset/knownBias",
        )
        # Describes if any sensitive personal information is present in the dataset.
        self._add_property(
            "dataset_sensitivePersonalInformation",
            PresenceType(),
            iri="https://rdf.spdx.org/v3/Dataset/sensitivePersonalInformation",
        )
        # Describes the anonymization methods used.
        self._add_property(
            "dataset_anonymizationMethodUsed",
            ListProp(StringProp()),
            iri="https://rdf.spdx.org/v3/Dataset/anonymizationMethodUsed",
        )
        # Describes the confidentiality level of the data points contained in the dataset.
        self._add_property(
            "dataset_confidentialityLevel",
            dataset_ConfidentialityLevelType(),
            iri="https://rdf.spdx.org/v3/Dataset/confidentialityLevel",
        )
        # Describes a mechanism to update the dataset.
        self._add_property(
            "dataset_datasetUpdateMechanism",
            StringProp(),
            iri="https://rdf.spdx.org/v3/Dataset/datasetUpdateMechanism",
        )
        # The field describes the availability of a dataset.
        self._add_property(
            "dataset_datasetAvailability",
            dataset_DatasetAvailabilityType(),
            iri="https://rdf.spdx.org/v3/Dataset/datasetAvailability",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["https://rdf.spdx.org/v3/Dataset/Dataset"] = dataset_Dataset


# Copyright (c) 2024 Joshua Watt
#
# SPDX-License-Identifier: MIT


class Context(object):
    from contextlib import contextmanager

    def __init__(self, contexts=[]):
        self.contexts = [c for c in contexts if c]
        self.__vocabs = []
        self.__expanded = {}
        self.__compacted = {}

    @contextmanager
    def vocab_push(self, vocab):
        if not vocab:
            yield self
            return

        self.__vocabs.append(vocab)
        try:
            yield self
        finally:
            self.__vocabs.pop()

    def __get_vocab_contexts(self):
        contexts = []

        for v in self.__vocabs:
            for ctx in self.contexts:
                # Check for vocabulary contexts
                for name, value in ctx.items():
                    if (
                        isinstance(value, dict)
                        and value["@type"] == "@vocab"
                        and v == self.__expand(value["@id"], self.contexts)
                    ):
                        contexts.insert(0, value["@context"])

        return contexts

    def compact(self, _id):
        return self.__compact_contexts(_id)

    def compact_vocab(self, _id, vocab=None):
        with self.vocab_push(vocab):
            if not self.__vocabs:
                v = ""
            else:
                v = self.__vocabs[-1]

            return self.__compact_contexts(_id, v, self.__get_vocab_contexts())

    def __compact_contexts(self, _id, v="", apply_vocabs=False):
        if v not in self.__compacted or _id not in self.__compacted[v]:
            if apply_vocabs:
                contexts = self.__get_vocab_contexts() + self.contexts
            else:
                contexts = self.contexts

            self.__compacted.setdefault(v, {})[_id] = self.__compact(
                _id,
                contexts,
                apply_vocabs,
            )
        return self.__compacted[v][_id]

    def __compact(self, _id, contexts, apply_vocabs):
        def remove_prefix(_id, value):
            possible = set()
            if _id.startswith(value):
                tmp_id = _id[len(value) :]
                possible.add(tmp_id)
                possible |= collect_possible(tmp_id)
            return possible

        def collect_possible(_id):
            possible = set()
            for ctx in contexts:
                for name, value in ctx.items():
                    if name == "@vocab":
                        if apply_vocabs:
                            possible |= remove_prefix(_id, value)
                    elif name == "@base":
                        possible |= remove_prefix(_id, value)
                    else:
                        if isinstance(value, dict):
                            value = value["@id"]

                        if _id == value:
                            possible.add(name)
                            possible |= collect_possible(name)
                        elif _id.startswith(value):
                            tmp_id = name + ":" + _id[len(value) :].lstrip("/")
                            possible.add(tmp_id)
                            possible |= collect_possible(tmp_id)

            return possible

        possible = collect_possible(_id)
        if not possible:
            return _id

        # To select from the possible identifiers, choose the one that has the
        # least context (fewest ":"), then the shortest, and finally
        # alphabetically
        possible = list(possible)
        possible.sort(key=lambda p: (p.count(":"), len(p), p))

        return possible[0]

    def is_relative(self, _id):
        import re

        return not re.match(r"[^:]+:", _id)

    def __expand_contexts(self, _id, v="", apply_vocabs=False):
        if v not in self.__expanded or _id not in self.__expanded[v]:
            if apply_vocabs:
                contexts = self.__get_vocab_contexts() + self.contexts

                # Apply contexts
                for ctx in contexts:
                    for name, value in ctx.items():
                        if name == "@vocab":
                            _id = value + _id
            else:
                contexts = self.contexts

            for ctx in contexts:
                for name, value in ctx.items():
                    if name == "@base" and self.is_relative(_id):
                        _id = value + _id

            self.__expanded.setdefault(v, {})[_id] = self.__expand(_id, contexts)

        return self.__expanded[v][_id]

    def expand(self, _id):
        return self.__expand_contexts(_id)

    def expand_vocab(self, _id, vocab=""):
        with self.vocab_push(vocab):
            if not self.__vocabs:
                v = ""
            else:
                v = self.__vocabs[-1]

            return self.__expand_contexts(_id, v, True)

    def __expand(self, _id, contexts):
        for ctx in contexts:
            if ":" not in _id:
                if _id in ctx:
                    if isinstance(ctx[_id], dict):
                        return self.__expand(ctx[_id]["@id"], contexts)
                    return self.__expand(ctx[_id], contexts)
                continue

            prefix, suffix = _id.split(":", 1)
            if prefix not in ctx:
                continue

            return self.__expand(prefix, contexts) + suffix

        return _id


"""Format Guard"""
# fmt: on


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    with args.infile.open("r") as f:
        d = JSONLDDeserializer()
        objects, _ = d.read(f)

    if args.print:
        print_tree(objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            s = JSONLDSerializer()
            s.write(objects, f)

    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
