#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# This file was automatically generated by shacl2code. DO NOT MANUALLY MODIFY IT
#
# SPDX-License-Identifier: MIT

import functools
import hashlib
import json
import re
from datetime import datetime, timezone


def check_type(obj, types):
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj)}"
            )
        raise TypeError(f"Value must be of type {types.__name__}. Got {type(obj)}")


class Property(object):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    TYPE = None

    def __init__(self):
        pass

    def init(self):
        return None

    def validate(self, value):
        check_type(value, self.VALID_TYPES)

    def set(self, value):
        return value

    def get(self, value):
        return value

    def check_min_count(self, value, min_count):
        return min_count == 1

    def check_max_count(self, value, max_count):
        return max_count == 1

    def elide(self, value):
        return value is None

    def walk(self, value, callback, path):
        callback(value, path)

    def serializer(self, value):
        return value

    def deserialize(self, data, object_ids=None):
        if isinstance(data, dict) and "@value" in data:
            if "@type" in data and self.TYPE and data["@type"] != self.TYPE:
                raise TypeError(
                    f"Value must be of type {self.TYPE}, but got {data['@type']}"
                )

            return data["@value"]

        return data

    def link_prop(self, value, link_cache, missing, visited):
        return value


class StringProp(Property):
    """
    A scalar string property for an SHACL object
    """

    TYPE = None
    VALID_TYPES = str
    REGEX = None

    def set(self, value):
        return str(value)

    def set(self, value):
        return str(value)

    def validate(self, value):
        super().validate(value)
        if self.REGEX is not None and not re.match(self.REGEX, value):
            raise ValueError(f"Value is not correctly formatted. Got '{value}'")


class AnyURIProp(StringProp):
    TYPE = "http://www.w3.org/2001/XMLSchema#anyURI"

    def validate(self, value):
        super().validate(value)


class MediaTypeProp(StringProp):
    TYPE = "https://spdx.org/rdf/v3/Core/MediaType"
    REGEX = r"^([a-zA-Z0-9][-a-zA-Z0-9!#$&^_.+]{0,126})\/([a-zA-Z0-9][-a-zA-Z0-9!#$&^_.+]{0,126})(;.+)?$"


class SemVerProp(StringProp):
    TYPE = "https://spdx.org/rdf/v3/Core/SemVer"
    REGEX = r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$"


class ExtensionProp(StringProp):
    TYPE = "https://spdx.org/rdf/v3/Core/Extension"


class DateTimeProp(Property):
    """
    A Date/Time Object
    """

    TYPE = "https://spdx.org/rdf/v3/Core/DateTime"
    VALID_TYPES = datetime

    def set(self, value):
        return value.astimezone(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    def get(self, value):
        return datetime.fromisoformat(value)


class IntegerProp(Property):
    VALID_TYPES = int

    def set(self, value):
        return int(value)


class PositiveIntegerProp(IntegerProp):
    def validate(self, value):
        super.validate()
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property):
    VALID_TYPES = bool

    def set(self, value):
        return bool(value)


class FloatProp(Property):
    VALID_TYPES = float

    def set(self, value):
        return float(value)


class ObjectProp(Property):
    """
    A scalar SHACL object property of a SHACL object
    """

    def __init__(self, cls, required):
        super().__init__()
        self.cls = cls
        self.required = required

    def init(self):
        if self.required:
            return self.cls()
        return None

    def validate(self, value):
        check_type(value, (self.cls, str))

    def walk(self, value, callback, path):
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def serializer(self, value):
        if value is None:
            return None

        if isinstance(value, str):
            return value

        return value.serializer()

    def deserialize(self, data, object_ids=None):
        if data is None:
            return data

        if isinstance(data, str):
            if data in object_ids:
                return object_ids[data]

            return data

        if isinstance(data, dict) and "@id" in data and not "@type" in data:
            return data["@id"]

        return SHACLObject.deserialize(data, object_ids)

    def link_prop(self, value, link_cache, missing, visited):
        if value is None:
            return value

        if isinstance(value, str):
            if value in link_cache:
                return link_cache[value]

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id and value._id is not link_cache[value._id]:
            value = link_cache[value._id]

        value.link_helper(link_cache, missing, visited)
        return value


class ListProxy(object):
    def __init__(self, prop, data=None):
        if data is None:
            self.__data = []
        else:
            self.__data = data
        self.__prop = prop

    def append(self, value):
        self.__prop.validate(value)
        self.__data.append(value)

    def insert(self, idx, value):
        self.__prop.validate(value)
        self.__data.insert(idx, value)

    def extend(self, items):
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs):
        self.__data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        if isinstance(key, slice):
            for v in value:
                self.__prop.validate(v)
        else:
            self.__prop.validate(value)

        self.__data[key] = value

    def __delitem__(self, key):
        del self.__data[key]

    def __contains__(self, item):
        return item in self.__data

    def __iter__(self):
        return iter(self.__data)

    def __len__(self):
        return len(self.__data)

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)


class ListProp(Property):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    def __init__(self, prop):
        super().__init__()
        self.prop = prop

    def init(self):
        return ListProxy(self.prop)

    def validate(self, value):
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(self, value):
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, value)

    def check_min_count(self, value, min_count):
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value, max_count):
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value):
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(self, value, callback, path):
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def deserialize(self, data, object_ids=None):
        if isinstance(data, (list, tuple, set)):
            data = [self.prop.deserialize(d, object_ids) for d in data]
        else:
            data = [self.prop.deserialize(data, object_ids)]

        return ListProxy(self.prop, data=data)

    def link_prop(self, value, link_cache, missing, visited):
        return ListProxy(
            self.prop,
            data=[self.prop.link_prop(v, link_cache, missing, visited) for v in value],
        )

    def serializer(self, value):
        check_type(value, ListProxy)
        if len(value) == 1:
            return self.prop.serializer(value[0])
        return [self.prop.serializer(v) for v in value]


class EnumProp(Property):
    VALID_TYPES = str

    def validate(self, value):
        super().validate(value)

        if value not in (v for _, v in self.valid_values):
            raise ValueError(
                f"'{value}' is not a valid value for '{self.__class__.__name__}'"
            )


@functools.total_ordering
class SHACLObject(object):
    DESERIALIZERS = {}

    def __init__(self):
        self._obj_data = {}
        self._obj_properties = {}
        self._obj_written = False
        self._obj_metadata = {}

        self._add_property("_id", StringProp(), json_name="@id")

    def _set_init_props(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def _add_property(
        self, pyname, prop, json_name=None, min_count=None, max_count=None
    ):
        if json_name is None:
            json_name = pyname
        if pyname in self._obj_properties:
            raise KeyError(
                f"'{pyname}' is already defined for '{self.__class__.__name__}'"
            )
        self._obj_properties[pyname] = (json_name, prop, min_count, max_count)
        self._obj_data[json_name] = prop.init()

    def __setattr__(self, name, value):
        if name.startswith("_obj_"):
            return super().__setattr__(name, value)

        try:
            (json_name, prop, _, _) = self._obj_properties[name]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )
        prop.validate(value)
        self._obj_data[json_name] = prop.set(value)

    def __getattr__(self, name):
        if name.startswith("_obj_"):
            return self.__dict__[name]

        if name == "_metadata":
            return self._obj_metadata

        try:
            (json_name, prop, _, _) = self._obj_properties[name]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )
        return prop.get(self._obj_data[json_name])

    def __delattr__(self, name):
        try:
            (json_name, prop, _, _) = self._obj_properties[name]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )
        self._obj_data[json_name] = prop.init()

    def walk(self, callback, path=None):
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(object, path):
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for json_name, prop, _, _ in self._obj_properties.values():
                prop.walk(self._obj_data[json_name], callback, path + [f".{json_name}"])

    def child_objects(self):
        """
        Iterate over each object that is a child of this one
        """
        seen = set()

        def _walk_callback(value, path):
            nonlocal seen

            if not isinstance(value, SHACLObject):
                return False

            if value in seen:
                return False

            seen.add(value)
            return True

        self.walk(_walk_callback)

        for obj in seen:
            yield obj

    def serializer(self):
        if self._id and self._obj_written:
            return self._id

        self._obj_written = True

        d = {
            "@type": self.TYPE,
        }

        for pyname, v in self._obj_properties.items():
            json_name, prop, min_count, max_count = v
            value = self._obj_data[json_name]
            if prop.elide(value):
                if min_count:
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} is required (currently {value!r})"
                    )
                continue

            if min_count is not None:
                if not prop.check_min_count(value, min_count):
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} requires a minimum of {min_count} elements"
                    )

            if max_count is not None:
                if not prop.check_max_count(value, max_count):
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} requires a maximum of {max_count} elements"
                    )

            d[json_name] = prop.serializer(value)
        return d

    def to_jsonld(self, f, *args, **kwargs):
        """
        Serialize this object to a JSON LD file
        """
        return write_jsonld([self], f, *args, **kwargs)

    @classmethod
    def deserialize(cls, data, object_ids=None):
        if not "@type" in data:
            return None

        typ = data["@type"]

        if not typ in cls.DESERIALIZERS:
            raise Exception("Unknown type f{typ}")

        obj = cls.DESERIALIZERS[typ]()

        if obj._id and obj._id in object_ids:
            return object_ids[obj._id]

        for pyname, v in obj._obj_properties.items():
            json_name, prop, _, _ = v
            if json_name in data:
                obj._obj_data[json_name] = prop.deserialize(data[json_name], object_ids)

        if obj._id:
            object_ids[obj._id] = obj

        return obj

    def link_helper(self, link_cache, missing, visited):
        if self in visited:
            return

        visited.add(self)

        for pyname, v in self._obj_properties.items():
            json_name, prop, _, _ = v
            self._obj_data[json_name] = prop.link_prop(
                self._obj_data[json_name],
                link_cache,
                missing,
                visited,
            )

    def link(self, link_cache=None):
        if not link_cache:
            link_cache = {obj._id: obj for obj in self.child_objects() if obj._id}

        missing = set()
        visited = set()

        self.link_helper(link_cache, missing, visited)

        return missing

    def __str__(self):
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self):
        return super().__hash__()

    def __eq__(self, other):
        return super().__eq__(other)

    def __lt__(self, other):
        def sort_key(obj):
            return (
                obj._id or "",
                obj.TYPE,
                getattr(obj, "name", None) or "",
                id(obj),
            )

        return sort_key(self) < sort_key(other)


def write_jsonld(objects, f, force_graph=False, **kwargs):
    """
    Write a list of objects to a JSON LD file

    If force_graph is True, a @graph node will always be written
    """
    ref_counts = {}
    id_objects = set()

    def walk_callback(value, path):
        nonlocal ref_counts

        if not isinstance(value, SHACLObject):
            return True

        value._obj_written = False

        # Remove blank node ID for re-assignment
        if value._id and value._id.startswith("_:"):
            del value._id

        if value._id:
            id_objects.add(value)

        ref_counts.setdefault(value, 0)
        ref_counts[value] += 1
        if ref_counts[value] > 1:
            id_objects.add(value)
            return False

        return True

    for o in objects:
        o.walk(walk_callback)

    for idx, o in enumerate(id_objects):
        if not o._id:
            o._id = f"_:{o.__class__.__name__}{idx}"

    use_graph = force_graph or len(objects) > 1

    objects = set(objects)

    if use_graph:
        # If we are making a graph, put all ID objects in the root
        objects |= id_objects

    objects = list(objects)
    objects.sort()

    if use_graph:
        graph_data = []
        # Ensure top level objects are only written in the top level graph
        # node, and referenced by ID everywhere else. This is done by setting
        # the flag that indicates this object has been written for all the top
        # level objects, then clearing it right before serializing the object.
        #
        # In this way, if an object is referenced before it is supposed to be
        # serialized into the @graph, it will serialize as a string instead of
        # the actual object
        for o in objects:
            o._obj_written = True

        for o in objects:
            # Allow this specific object to be written now
            o._obj_written = False
            graph_data.append(o.serializer())

        data = {"@graph": graph_data}
    else:
        data = objects[0].serializer()

    sha1 = hashlib.sha1()
    for chunk in json.JSONEncoder(**kwargs).iterencode(data):
        chunk = chunk.encode("utf-8")
        f.write(chunk)
        sha1.update(chunk)

    return sha1.hexdigest()


def read_jsonld(f):
    """
    Read objects from a JSON LD file

    Returns the list of top level objects in the file, and a set of all
    object_ids that are present in the file

    The returned objects are fully linked
    """
    data = json.load(f)
    object_ids = {}
    if not "@graph" in data:
        objects = [SHACLObject.deserialize(data, object_ids)]
    else:
        objects = [SHACLObject.deserialize(o, object_ids) for o in data["@graph"]]

    for o in objects:
        o.link(object_ids)

    # Remove blank node IDs
    for o in objects:
        for c in o.child_objects():
            if c._id and c._id.startswith("_:"):
                del c._id

    object_ids = {k: v for k, v in object_ids.items() if not k.startswith("_:")}

    return objects, object_ids


def print_tree(objects, all_fields=False):
    """
    Print object tree
    """
    seen = set()

    def callback(value, path):
        nonlocal seen

        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard"""


# ENUMERATIONS
# Lists the different safety risk type values that can be used to describe the safety risk of AI software
# according to [Article 20 of Regulation 765/2008/EC](https://ec.europa.eu/docsroom/documents/17107/attachments/1/translations/en/renditions/pdf).
class ai_SafetyRiskAssessmentType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType"
    valid_values = [
        ("high", "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/high"),
        ("low", "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/low"),
        ("medium", "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/medium"),
        ("serious", "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/serious"),
    ]
    high = "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/high"
    low = "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/low"
    medium = "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/medium"
    serious = "https://spdx.org/rdf/v3/AI/SafetyRiskAssessmentType/serious"


# AnnotationType specifies the type of an annotation.
class core_AnnotationType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/AnnotationType"
    valid_values = [
        ("other", "https://spdx.org/rdf/v3/Core/AnnotationType/other"),
        ("review", "https://spdx.org/rdf/v3/Core/AnnotationType/review"),
    ]
    other = "https://spdx.org/rdf/v3/Core/AnnotationType/other"
    review = "https://spdx.org/rdf/v3/Core/AnnotationType/review"


# ExteralIdentifierType specifies the type of an external identifier.
class core_ExternalIdentifierType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType"
    valid_values = [
        ("cpe22", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cpe22"),
        ("cpe23", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cpe23"),
        ("cve", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cve"),
        ("email", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/email"),
        ("gitoid", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/gitoid"),
        ("other", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/other"),
        ("packageUrl", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/packageUrl"),
        ("securityOther", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/securityOther"),
        ("swhid", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/swhid"),
        ("swid", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/swid"),
        ("urlScheme", "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/urlScheme"),
    ]
    cpe22 = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cpe22"
    cpe23 = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cpe23"
    cve = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/cve"
    email = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/email"
    gitoid = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/gitoid"
    other = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/other"
    packageUrl = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/packageUrl"
    securityOther = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/securityOther"
    swhid = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/swhid"
    swid = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/swid"
    urlScheme = "https://spdx.org/rdf/v3/Core/ExternalIdentifierType/urlScheme"


# ExternalRefType specifies the type of an external reference.
class core_ExternalRefType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/ExternalRefType"
    valid_values = [
        ("altDownloadLocation", "https://spdx.org/rdf/v3/Core/ExternalRefType/altDownloadLocation"),
        ("altWebPage", "https://spdx.org/rdf/v3/Core/ExternalRefType/altWebPage"),
        ("binaryArtifact", "https://spdx.org/rdf/v3/Core/ExternalRefType/binaryArtifact"),
        ("bower", "https://spdx.org/rdf/v3/Core/ExternalRefType/bower"),
        ("buildMeta", "https://spdx.org/rdf/v3/Core/ExternalRefType/buildMeta"),
        ("buildSystem", "https://spdx.org/rdf/v3/Core/ExternalRefType/buildSystem"),
        ("certificationReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/certificationReport"),
        ("chat", "https://spdx.org/rdf/v3/Core/ExternalRefType/chat"),
        ("componentAnalysisReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/componentAnalysisReport"),
        ("documentation", "https://spdx.org/rdf/v3/Core/ExternalRefType/documentation"),
        ("dynamicAnalysisReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/dynamicAnalysisReport"),
        ("eolNotice", "https://spdx.org/rdf/v3/Core/ExternalRefType/eolNotice"),
        ("exportControlAssessment", "https://spdx.org/rdf/v3/Core/ExternalRefType/exportControlAssessment"),
        ("funding", "https://spdx.org/rdf/v3/Core/ExternalRefType/funding"),
        ("issueTracker", "https://spdx.org/rdf/v3/Core/ExternalRefType/issueTracker"),
        ("license", "https://spdx.org/rdf/v3/Core/ExternalRefType/license"),
        ("mailingList", "https://spdx.org/rdf/v3/Core/ExternalRefType/mailingList"),
        ("mavenCentral", "https://spdx.org/rdf/v3/Core/ExternalRefType/mavenCentral"),
        ("metrics", "https://spdx.org/rdf/v3/Core/ExternalRefType/metrics"),
        ("npm", "https://spdx.org/rdf/v3/Core/ExternalRefType/npm"),
        ("nuget", "https://spdx.org/rdf/v3/Core/ExternalRefType/nuget"),
        ("other", "https://spdx.org/rdf/v3/Core/ExternalRefType/other"),
        ("privacyAssessment", "https://spdx.org/rdf/v3/Core/ExternalRefType/privacyAssessment"),
        ("productMetadata", "https://spdx.org/rdf/v3/Core/ExternalRefType/productMetadata"),
        ("purchaseOrder", "https://spdx.org/rdf/v3/Core/ExternalRefType/purchaseOrder"),
        ("qualityAssessmentReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/qualityAssessmentReport"),
        ("releaseHistory", "https://spdx.org/rdf/v3/Core/ExternalRefType/releaseHistory"),
        ("releaseNotes", "https://spdx.org/rdf/v3/Core/ExternalRefType/releaseNotes"),
        ("riskAssessment", "https://spdx.org/rdf/v3/Core/ExternalRefType/riskAssessment"),
        ("runtimeAnalysisReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/runtimeAnalysisReport"),
        ("secureSoftwareAttestation", "https://spdx.org/rdf/v3/Core/ExternalRefType/secureSoftwareAttestation"),
        ("securityAdversaryModel", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityAdversaryModel"),
        ("securityAdvisory", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityAdvisory"),
        ("securityFix", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityFix"),
        ("securityOther", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityOther"),
        ("securityPenTestReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityPenTestReport"),
        ("securityPolicy", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityPolicy"),
        ("securityThreatModel", "https://spdx.org/rdf/v3/Core/ExternalRefType/securityThreatModel"),
        ("socialMedia", "https://spdx.org/rdf/v3/Core/ExternalRefType/socialMedia"),
        ("sourceArtifact", "https://spdx.org/rdf/v3/Core/ExternalRefType/sourceArtifact"),
        ("staticAnalysisReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/staticAnalysisReport"),
        ("support", "https://spdx.org/rdf/v3/Core/ExternalRefType/support"),
        ("vcs", "https://spdx.org/rdf/v3/Core/ExternalRefType/vcs"),
        ("vulnerabilityDisclosureReport", "https://spdx.org/rdf/v3/Core/ExternalRefType/vulnerabilityDisclosureReport"),
        ("vulnerabilityExploitabilityAssessment", "https://spdx.org/rdf/v3/Core/ExternalRefType/vulnerabilityExploitabilityAssessment"),
    ]
    altDownloadLocation = "https://spdx.org/rdf/v3/Core/ExternalRefType/altDownloadLocation"
    altWebPage = "https://spdx.org/rdf/v3/Core/ExternalRefType/altWebPage"
    binaryArtifact = "https://spdx.org/rdf/v3/Core/ExternalRefType/binaryArtifact"
    bower = "https://spdx.org/rdf/v3/Core/ExternalRefType/bower"
    buildMeta = "https://spdx.org/rdf/v3/Core/ExternalRefType/buildMeta"
    buildSystem = "https://spdx.org/rdf/v3/Core/ExternalRefType/buildSystem"
    certificationReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/certificationReport"
    chat = "https://spdx.org/rdf/v3/Core/ExternalRefType/chat"
    componentAnalysisReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/componentAnalysisReport"
    documentation = "https://spdx.org/rdf/v3/Core/ExternalRefType/documentation"
    dynamicAnalysisReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/dynamicAnalysisReport"
    eolNotice = "https://spdx.org/rdf/v3/Core/ExternalRefType/eolNotice"
    exportControlAssessment = "https://spdx.org/rdf/v3/Core/ExternalRefType/exportControlAssessment"
    funding = "https://spdx.org/rdf/v3/Core/ExternalRefType/funding"
    issueTracker = "https://spdx.org/rdf/v3/Core/ExternalRefType/issueTracker"
    license = "https://spdx.org/rdf/v3/Core/ExternalRefType/license"
    mailingList = "https://spdx.org/rdf/v3/Core/ExternalRefType/mailingList"
    mavenCentral = "https://spdx.org/rdf/v3/Core/ExternalRefType/mavenCentral"
    metrics = "https://spdx.org/rdf/v3/Core/ExternalRefType/metrics"
    npm = "https://spdx.org/rdf/v3/Core/ExternalRefType/npm"
    nuget = "https://spdx.org/rdf/v3/Core/ExternalRefType/nuget"
    other = "https://spdx.org/rdf/v3/Core/ExternalRefType/other"
    privacyAssessment = "https://spdx.org/rdf/v3/Core/ExternalRefType/privacyAssessment"
    productMetadata = "https://spdx.org/rdf/v3/Core/ExternalRefType/productMetadata"
    purchaseOrder = "https://spdx.org/rdf/v3/Core/ExternalRefType/purchaseOrder"
    qualityAssessmentReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/qualityAssessmentReport"
    releaseHistory = "https://spdx.org/rdf/v3/Core/ExternalRefType/releaseHistory"
    releaseNotes = "https://spdx.org/rdf/v3/Core/ExternalRefType/releaseNotes"
    riskAssessment = "https://spdx.org/rdf/v3/Core/ExternalRefType/riskAssessment"
    runtimeAnalysisReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/runtimeAnalysisReport"
    secureSoftwareAttestation = "https://spdx.org/rdf/v3/Core/ExternalRefType/secureSoftwareAttestation"
    securityAdversaryModel = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityAdversaryModel"
    securityAdvisory = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityAdvisory"
    securityFix = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityFix"
    securityOther = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityOther"
    securityPenTestReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityPenTestReport"
    securityPolicy = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityPolicy"
    securityThreatModel = "https://spdx.org/rdf/v3/Core/ExternalRefType/securityThreatModel"
    socialMedia = "https://spdx.org/rdf/v3/Core/ExternalRefType/socialMedia"
    sourceArtifact = "https://spdx.org/rdf/v3/Core/ExternalRefType/sourceArtifact"
    staticAnalysisReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/staticAnalysisReport"
    support = "https://spdx.org/rdf/v3/Core/ExternalRefType/support"
    vcs = "https://spdx.org/rdf/v3/Core/ExternalRefType/vcs"
    vulnerabilityDisclosureReport = "https://spdx.org/rdf/v3/Core/ExternalRefType/vulnerabilityDisclosureReport"
    vulnerabilityExploitabilityAssessment = "https://spdx.org/rdf/v3/Core/ExternalRefType/vulnerabilityExploitabilityAssessment"


# A HashAlgorithm is a mathematical algorithm that maps data of arbitrary size to a bit string (the hash)
# and is a one-way function, that is, a function which is practically infeasible to invert.
class core_HashAlgorithm(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/HashAlgorithm"
    valid_values = [
        ("blake2b256", "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b256"),
        ("blake2b384", "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b384"),
        ("blake2b512", "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b512"),
        ("blake3", "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake3"),
        ("crystalsDilithium", "https://spdx.org/rdf/v3/Core/HashAlgorithm/crystalsDilithium"),
        ("crystalsKyber", "https://spdx.org/rdf/v3/Core/HashAlgorithm/crystalsKyber"),
        ("falcon", "https://spdx.org/rdf/v3/Core/HashAlgorithm/falcon"),
        ("md2", "https://spdx.org/rdf/v3/Core/HashAlgorithm/md2"),
        ("md4", "https://spdx.org/rdf/v3/Core/HashAlgorithm/md4"),
        ("md5", "https://spdx.org/rdf/v3/Core/HashAlgorithm/md5"),
        ("md6", "https://spdx.org/rdf/v3/Core/HashAlgorithm/md6"),
        ("other", "https://spdx.org/rdf/v3/Core/HashAlgorithm/other"),
        ("sha1", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha1"),
        ("sha224", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha224"),
        ("sha256", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha256"),
        ("sha384", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha384"),
        ("sha3_224", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_224"),
        ("sha3_256", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_256"),
        ("sha3_384", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_384"),
        ("sha3_512", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_512"),
        ("sha512", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha512"),
        ("spdxPvcSha1", "https://spdx.org/rdf/v3/Core/HashAlgorithm/spdxPvcSha1"),
        ("spdxPvcSha256", "https://spdx.org/rdf/v3/Core/HashAlgorithm/spdxPvcSha256"),
        ("sphincsPlus", "https://spdx.org/rdf/v3/Core/HashAlgorithm/sphincsPlus"),
    ]
    blake2b256 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b256"
    blake2b384 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b384"
    blake2b512 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake2b512"
    blake3 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/blake3"
    crystalsDilithium = "https://spdx.org/rdf/v3/Core/HashAlgorithm/crystalsDilithium"
    crystalsKyber = "https://spdx.org/rdf/v3/Core/HashAlgorithm/crystalsKyber"
    falcon = "https://spdx.org/rdf/v3/Core/HashAlgorithm/falcon"
    md2 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/md2"
    md4 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/md4"
    md5 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/md5"
    md6 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/md6"
    other = "https://spdx.org/rdf/v3/Core/HashAlgorithm/other"
    sha1 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha1"
    sha224 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha224"
    sha256 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha256"
    sha384 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha384"
    sha3_224 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_224"
    sha3_256 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_256"
    sha3_384 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_384"
    sha3_512 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha3_512"
    sha512 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sha512"
    spdxPvcSha1 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/spdxPvcSha1"
    spdxPvcSha256 = "https://spdx.org/rdf/v3/Core/HashAlgorithm/spdxPvcSha256"
    sphincsPlus = "https://spdx.org/rdf/v3/Core/HashAlgorithm/sphincsPlus"


# TODO
class core_LifecycleScopeType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/LifecycleScopeType"
    valid_values = [
        ("build", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/build"),
        ("design", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/design"),
        ("development", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/development"),
        ("other", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/other"),
        ("runtime", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/runtime"),
        ("test", "https://spdx.org/rdf/v3/Core/LifecycleScopeType/test"),
    ]
    build = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/build"
    design = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/design"
    development = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/development"
    other = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/other"
    runtime = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/runtime"
    test = "https://spdx.org/rdf/v3/Core/LifecycleScopeType/test"


# This type is used to indicate if a given field is present or absent or unknown.
class core_PresenceType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/PresenceType"
    valid_values = [
        ("no", "https://spdx.org/rdf/v3/Core/PresenceType/no"),
        ("noAssertion", "https://spdx.org/rdf/v3/Core/PresenceType/noAssertion"),
        ("yes", "https://spdx.org/rdf/v3/Core/PresenceType/yes"),
    ]
    no = "https://spdx.org/rdf/v3/Core/PresenceType/no"
    noAssertion = "https://spdx.org/rdf/v3/Core/PresenceType/noAssertion"
    yes = "https://spdx.org/rdf/v3/Core/PresenceType/yes"


# There are a set of profiles that have been defined by a profile team.
# A profile consists of a namespace that may add properties and classes to the core profile unique to the domain covered by the profile.
# The profile may also contain additional restrictions on existing properties and classes defined in other profiles.
# If the creator of an SPDX collection of elements includes a profile in the list of conformanceProfiles, they are claiming that all contained elements conform to all restrictions defined for that profile.
class core_ProfileIdentifierType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType"
    valid_values = [
        ("ai", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/ai"),
        ("build", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/build"),
        ("core", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/core"),
        ("dataset", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/dataset"),
        ("expandedLicensing", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/expandedLicensing"),
        ("extension", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/extension"),
        ("security", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/security"),
        ("simpleLicensing", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/simpleLicensing"),
        ("software", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/software"),
        ("usage", "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/usage"),
    ]
    ai = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/ai"
    build = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/build"
    core = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/core"
    dataset = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/dataset"
    expandedLicensing = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/expandedLicensing"
    extension = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/extension"
    security = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/security"
    simpleLicensing = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/simpleLicensing"
    software = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/software"
    usage = "https://spdx.org/rdf/v3/Core/ProfileIdentifierType/usage"


# RelationshipCompleteness indicates whether the provided relationship is known to be complete, known to be incomplete, or if no assertion is made by the relationship creator.
class core_RelationshipCompleteness(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/RelationshipCompleteness"
    valid_values = [
        ("complete", "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/complete"),
        ("incomplete", "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/incomplete"),
        ("noAssertion", "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/noAssertion"),
    ]
    complete = "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/complete"
    incomplete = "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/incomplete"
    noAssertion = "https://spdx.org/rdf/v3/Core/RelationshipCompleteness/noAssertion"


# Provides information about the relationship between two Elements.
# For example, you can represent a relationship between two different Files,
# between a Package and a File, between two Packages, or between one SPDXDocument and another SPDXDocument.
#
# Relationship names be descriptive enough to easily deduce the correct direction
# from their name. The best way to do this is to make sure that the relationship
# name completes the sentence:
#
# `from` (is) (a) `RELATIONSHIP` `to`
class core_RelationshipType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Core/RelationshipType"
    valid_values = [
        ("affects", "https://spdx.org/rdf/v3/Core/RelationshipType/affects"),
        ("amendedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/amendedBy"),
        ("ancestorOf", "https://spdx.org/rdf/v3/Core/RelationshipType/ancestorOf"),
        ("availableFrom", "https://spdx.org/rdf/v3/Core/RelationshipType/availableFrom"),
        ("configures", "https://spdx.org/rdf/v3/Core/RelationshipType/configures"),
        ("contains", "https://spdx.org/rdf/v3/Core/RelationshipType/contains"),
        ("coordinatedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/coordinatedBy"),
        ("copiedTo", "https://spdx.org/rdf/v3/Core/RelationshipType/copiedTo"),
        ("delegatedTo", "https://spdx.org/rdf/v3/Core/RelationshipType/delegatedTo"),
        ("dependsOn", "https://spdx.org/rdf/v3/Core/RelationshipType/dependsOn"),
        ("descendantOf", "https://spdx.org/rdf/v3/Core/RelationshipType/descendantOf"),
        ("describes", "https://spdx.org/rdf/v3/Core/RelationshipType/describes"),
        ("doesNotAffect", "https://spdx.org/rdf/v3/Core/RelationshipType/doesNotAffect"),
        ("expandsTo", "https://spdx.org/rdf/v3/Core/RelationshipType/expandsTo"),
        ("exploitCreatedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/exploitCreatedBy"),
        ("fixedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/fixedBy"),
        ("fixedIn", "https://spdx.org/rdf/v3/Core/RelationshipType/fixedIn"),
        ("foundBy", "https://spdx.org/rdf/v3/Core/RelationshipType/foundBy"),
        ("generates", "https://spdx.org/rdf/v3/Core/RelationshipType/generates"),
        ("hasAddedFile", "https://spdx.org/rdf/v3/Core/RelationshipType/hasAddedFile"),
        ("hasAssessmentFor", "https://spdx.org/rdf/v3/Core/RelationshipType/hasAssessmentFor"),
        ("hasAssociatedVulnerability", "https://spdx.org/rdf/v3/Core/RelationshipType/hasAssociatedVulnerability"),
        ("hasConcludedLicense", "https://spdx.org/rdf/v3/Core/RelationshipType/hasConcludedLicense"),
        ("hasDataFile", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDataFile"),
        ("hasDeclaredLicense", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDeclaredLicense"),
        ("hasDeletedFile", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDeletedFile"),
        ("hasDependencyManifest", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDependencyManifest"),
        ("hasDistributionArtifact", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDistributionArtifact"),
        ("hasDocumentation", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDocumentation"),
        ("hasDynamicLink", "https://spdx.org/rdf/v3/Core/RelationshipType/hasDynamicLink"),
        ("hasEvidence", "https://spdx.org/rdf/v3/Core/RelationshipType/hasEvidence"),
        ("hasExample", "https://spdx.org/rdf/v3/Core/RelationshipType/hasExample"),
        ("hasHost", "https://spdx.org/rdf/v3/Core/RelationshipType/hasHost"),
        ("hasInputs", "https://spdx.org/rdf/v3/Core/RelationshipType/hasInputs"),
        ("hasMetadata", "https://spdx.org/rdf/v3/Core/RelationshipType/hasMetadata"),
        ("hasOptionalComponent", "https://spdx.org/rdf/v3/Core/RelationshipType/hasOptionalComponent"),
        ("hasOptionalDependency", "https://spdx.org/rdf/v3/Core/RelationshipType/hasOptionalDependency"),
        ("hasOutputs", "https://spdx.org/rdf/v3/Core/RelationshipType/hasOutputs"),
        ("hasPrerequsite", "https://spdx.org/rdf/v3/Core/RelationshipType/hasPrerequsite"),
        ("hasProvidedDependency", "https://spdx.org/rdf/v3/Core/RelationshipType/hasProvidedDependency"),
        ("hasRequirement", "https://spdx.org/rdf/v3/Core/RelationshipType/hasRequirement"),
        ("hasSpecification", "https://spdx.org/rdf/v3/Core/RelationshipType/hasSpecification"),
        ("hasStaticLink", "https://spdx.org/rdf/v3/Core/RelationshipType/hasStaticLink"),
        ("hasTest", "https://spdx.org/rdf/v3/Core/RelationshipType/hasTest"),
        ("hasTestCase", "https://spdx.org/rdf/v3/Core/RelationshipType/hasTestCase"),
        ("hasVariant", "https://spdx.org/rdf/v3/Core/RelationshipType/hasVariant"),
        ("invokedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/invokedBy"),
        ("modifiedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/modifiedBy"),
        ("other", "https://spdx.org/rdf/v3/Core/RelationshipType/other"),
        ("packagedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/packagedBy"),
        ("patchedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/patchedBy"),
        ("publishedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/publishedBy"),
        ("reportedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/reportedBy"),
        ("republishedBy", "https://spdx.org/rdf/v3/Core/RelationshipType/republishedBy"),
        ("serializedInArtifact", "https://spdx.org/rdf/v3/Core/RelationshipType/serializedInArtifact"),
        ("testedOn", "https://spdx.org/rdf/v3/Core/RelationshipType/testedOn"),
        ("trainedOn", "https://spdx.org/rdf/v3/Core/RelationshipType/trainedOn"),
        ("underInvestigationFor", "https://spdx.org/rdf/v3/Core/RelationshipType/underInvestigationFor"),
        ("usesTool", "https://spdx.org/rdf/v3/Core/RelationshipType/usesTool"),
    ]
    affects = "https://spdx.org/rdf/v3/Core/RelationshipType/affects"
    amendedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/amendedBy"
    ancestorOf = "https://spdx.org/rdf/v3/Core/RelationshipType/ancestorOf"
    availableFrom = "https://spdx.org/rdf/v3/Core/RelationshipType/availableFrom"
    configures = "https://spdx.org/rdf/v3/Core/RelationshipType/configures"
    contains = "https://spdx.org/rdf/v3/Core/RelationshipType/contains"
    coordinatedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/coordinatedBy"
    copiedTo = "https://spdx.org/rdf/v3/Core/RelationshipType/copiedTo"
    delegatedTo = "https://spdx.org/rdf/v3/Core/RelationshipType/delegatedTo"
    dependsOn = "https://spdx.org/rdf/v3/Core/RelationshipType/dependsOn"
    descendantOf = "https://spdx.org/rdf/v3/Core/RelationshipType/descendantOf"
    describes = "https://spdx.org/rdf/v3/Core/RelationshipType/describes"
    doesNotAffect = "https://spdx.org/rdf/v3/Core/RelationshipType/doesNotAffect"
    expandsTo = "https://spdx.org/rdf/v3/Core/RelationshipType/expandsTo"
    exploitCreatedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/exploitCreatedBy"
    fixedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/fixedBy"
    fixedIn = "https://spdx.org/rdf/v3/Core/RelationshipType/fixedIn"
    foundBy = "https://spdx.org/rdf/v3/Core/RelationshipType/foundBy"
    generates = "https://spdx.org/rdf/v3/Core/RelationshipType/generates"
    hasAddedFile = "https://spdx.org/rdf/v3/Core/RelationshipType/hasAddedFile"
    hasAssessmentFor = "https://spdx.org/rdf/v3/Core/RelationshipType/hasAssessmentFor"
    hasAssociatedVulnerability = "https://spdx.org/rdf/v3/Core/RelationshipType/hasAssociatedVulnerability"
    hasConcludedLicense = "https://spdx.org/rdf/v3/Core/RelationshipType/hasConcludedLicense"
    hasDataFile = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDataFile"
    hasDeclaredLicense = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDeclaredLicense"
    hasDeletedFile = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDeletedFile"
    hasDependencyManifest = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDependencyManifest"
    hasDistributionArtifact = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDistributionArtifact"
    hasDocumentation = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDocumentation"
    hasDynamicLink = "https://spdx.org/rdf/v3/Core/RelationshipType/hasDynamicLink"
    hasEvidence = "https://spdx.org/rdf/v3/Core/RelationshipType/hasEvidence"
    hasExample = "https://spdx.org/rdf/v3/Core/RelationshipType/hasExample"
    hasHost = "https://spdx.org/rdf/v3/Core/RelationshipType/hasHost"
    hasInputs = "https://spdx.org/rdf/v3/Core/RelationshipType/hasInputs"
    hasMetadata = "https://spdx.org/rdf/v3/Core/RelationshipType/hasMetadata"
    hasOptionalComponent = "https://spdx.org/rdf/v3/Core/RelationshipType/hasOptionalComponent"
    hasOptionalDependency = "https://spdx.org/rdf/v3/Core/RelationshipType/hasOptionalDependency"
    hasOutputs = "https://spdx.org/rdf/v3/Core/RelationshipType/hasOutputs"
    hasPrerequsite = "https://spdx.org/rdf/v3/Core/RelationshipType/hasPrerequsite"
    hasProvidedDependency = "https://spdx.org/rdf/v3/Core/RelationshipType/hasProvidedDependency"
    hasRequirement = "https://spdx.org/rdf/v3/Core/RelationshipType/hasRequirement"
    hasSpecification = "https://spdx.org/rdf/v3/Core/RelationshipType/hasSpecification"
    hasStaticLink = "https://spdx.org/rdf/v3/Core/RelationshipType/hasStaticLink"
    hasTest = "https://spdx.org/rdf/v3/Core/RelationshipType/hasTest"
    hasTestCase = "https://spdx.org/rdf/v3/Core/RelationshipType/hasTestCase"
    hasVariant = "https://spdx.org/rdf/v3/Core/RelationshipType/hasVariant"
    invokedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/invokedBy"
    modifiedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/modifiedBy"
    other = "https://spdx.org/rdf/v3/Core/RelationshipType/other"
    packagedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/packagedBy"
    patchedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/patchedBy"
    publishedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/publishedBy"
    reportedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/reportedBy"
    republishedBy = "https://spdx.org/rdf/v3/Core/RelationshipType/republishedBy"
    serializedInArtifact = "https://spdx.org/rdf/v3/Core/RelationshipType/serializedInArtifact"
    testedOn = "https://spdx.org/rdf/v3/Core/RelationshipType/testedOn"
    trainedOn = "https://spdx.org/rdf/v3/Core/RelationshipType/trainedOn"
    underInvestigationFor = "https://spdx.org/rdf/v3/Core/RelationshipType/underInvestigationFor"
    usesTool = "https://spdx.org/rdf/v3/Core/RelationshipType/usesTool"


# Describes the different confidentiality levels as given by the [Traffic Light Protocol](https://en.wikipedia.org/wiki/Traffic_Light_Protocol).
class dataset_ConfidentialityLevelType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType"
    valid_values = [
        ("amber", "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/amber"),
        ("clear", "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/clear"),
        ("green", "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/green"),
        ("red", "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/red"),
    ]
    amber = "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/amber"
    clear = "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/clear"
    green = "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/green"
    red = "https://spdx.org/rdf/v3/Dataset/ConfidentialityLevelType/red"


# Describes the possible types of availability of a dataset, indicating whether the dataset can be directly downloaded, can be assembled using a script for scraping the data, is only available after a clickthrough or a registration form.
class dataset_DatasetAvailabilityType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType"
    valid_values = [
        ("clickthrough", "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/clickthrough"),
        ("directDownload", "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/directDownload"),
        ("query", "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/query"),
        ("registration", "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/registration"),
        ("scrapingScript", "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/scrapingScript"),
    ]
    clickthrough = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/clickthrough"
    directDownload = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/directDownload"
    query = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/query"
    registration = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/registration"
    scrapingScript = "https://spdx.org/rdf/v3/Dataset/DatasetAvailabilityType/scrapingScript"


# Describes the different structures of data within a given dataset. A dataset can have multiple types of data, or even a single type of data but still match multiple types, for example sensor data could also be timeseries or labeled image data could also be considered categorical.
class dataset_DatasetType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Dataset/DatasetType"
    valid_values = [
        ("audio", "https://spdx.org/rdf/v3/Dataset/DatasetType/audio"),
        ("categorical", "https://spdx.org/rdf/v3/Dataset/DatasetType/categorical"),
        ("graph", "https://spdx.org/rdf/v3/Dataset/DatasetType/graph"),
        ("image", "https://spdx.org/rdf/v3/Dataset/DatasetType/image"),
        ("noAssertion", "https://spdx.org/rdf/v3/Dataset/DatasetType/noAssertion"),
        ("numeric", "https://spdx.org/rdf/v3/Dataset/DatasetType/numeric"),
        ("other", "https://spdx.org/rdf/v3/Dataset/DatasetType/other"),
        ("sensor", "https://spdx.org/rdf/v3/Dataset/DatasetType/sensor"),
        ("structured", "https://spdx.org/rdf/v3/Dataset/DatasetType/structured"),
        ("syntactic", "https://spdx.org/rdf/v3/Dataset/DatasetType/syntactic"),
        ("text", "https://spdx.org/rdf/v3/Dataset/DatasetType/text"),
        ("timeseries", "https://spdx.org/rdf/v3/Dataset/DatasetType/timeseries"),
        ("timestamp", "https://spdx.org/rdf/v3/Dataset/DatasetType/timestamp"),
        ("video", "https://spdx.org/rdf/v3/Dataset/DatasetType/video"),
    ]
    audio = "https://spdx.org/rdf/v3/Dataset/DatasetType/audio"
    categorical = "https://spdx.org/rdf/v3/Dataset/DatasetType/categorical"
    graph = "https://spdx.org/rdf/v3/Dataset/DatasetType/graph"
    image = "https://spdx.org/rdf/v3/Dataset/DatasetType/image"
    noAssertion = "https://spdx.org/rdf/v3/Dataset/DatasetType/noAssertion"
    numeric = "https://spdx.org/rdf/v3/Dataset/DatasetType/numeric"
    other = "https://spdx.org/rdf/v3/Dataset/DatasetType/other"
    sensor = "https://spdx.org/rdf/v3/Dataset/DatasetType/sensor"
    structured = "https://spdx.org/rdf/v3/Dataset/DatasetType/structured"
    syntactic = "https://spdx.org/rdf/v3/Dataset/DatasetType/syntactic"
    text = "https://spdx.org/rdf/v3/Dataset/DatasetType/text"
    timeseries = "https://spdx.org/rdf/v3/Dataset/DatasetType/timeseries"
    timestamp = "https://spdx.org/rdf/v3/Dataset/DatasetType/timestamp"
    video = "https://spdx.org/rdf/v3/Dataset/DatasetType/video"


# CvssSeverityType specifies the CVSS severity type, defined in the CVSS specifications as the textual representation of the numeric CVSS score. The severity type entries are inclusive of and applicable to enumerations found in CVSS versions [3](https://www.first.org/cvss/v3.0/specification-document#Qualitative-Severity-Rating-Scale) and [4](https://www.first.org/cvss/v4.0/specification-document#Qualitative-Severity-Rating-Scale). CvssSeverityType is a mandatory field because baseSeverity is required in the CVSS version [3.0](https://www.first.org/cvss/cvss-v3.0.json), [3.1](https://www.first.org/cvss/cvss-v3.1.json), and [4.0](https://www.first.org/cvss/cvss-v4.0.json) schemas. The field can be used to document the base, temporal, threat, or environmental severity.
class security_CvssSeverityType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Security/CvssSeverityType"
    valid_values = [
        ("critical", "https://spdx.org/rdf/v3/Security/CvssSeverityType/critical"),
        ("high", "https://spdx.org/rdf/v3/Security/CvssSeverityType/high"),
        ("low", "https://spdx.org/rdf/v3/Security/CvssSeverityType/low"),
        ("medium", "https://spdx.org/rdf/v3/Security/CvssSeverityType/medium"),
        ("none", "https://spdx.org/rdf/v3/Security/CvssSeverityType/none"),
    ]
    critical = "https://spdx.org/rdf/v3/Security/CvssSeverityType/critical"
    high = "https://spdx.org/rdf/v3/Security/CvssSeverityType/high"
    low = "https://spdx.org/rdf/v3/Security/CvssSeverityType/low"
    medium = "https://spdx.org/rdf/v3/Security/CvssSeverityType/medium"
    none = "https://spdx.org/rdf/v3/Security/CvssSeverityType/none"


# ExploitCatalogType specifies the type of exploit catalog that a vulnerability is listed in.
class security_ExploitCatalogType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Security/ExploitCatalogType"
    valid_values = [
        ("kev", "https://spdx.org/rdf/v3/Security/ExploitCatalogType/kev"),
        ("other", "https://spdx.org/rdf/v3/Security/ExploitCatalogType/other"),
    ]
    kev = "https://spdx.org/rdf/v3/Security/ExploitCatalogType/kev"
    other = "https://spdx.org/rdf/v3/Security/ExploitCatalogType/other"


# SsvcDecisionType specifies the type of decision that's been made according to the Stakeholder-Specific Vulnerability Categorization (SSVC)  system [https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc](https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc)
class security_SsvcDecisionType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Security/SsvcDecisionType"
    valid_values = [
        ("act", "https://spdx.org/rdf/v3/Security/SsvcDecisionType/act"),
        ("attend", "https://spdx.org/rdf/v3/Security/SsvcDecisionType/attend"),
        ("track", "https://spdx.org/rdf/v3/Security/SsvcDecisionType/track"),
        ("trackStar", "https://spdx.org/rdf/v3/Security/SsvcDecisionType/trackStar"),
    ]
    act = "https://spdx.org/rdf/v3/Security/SsvcDecisionType/act"
    attend = "https://spdx.org/rdf/v3/Security/SsvcDecisionType/attend"
    track = "https://spdx.org/rdf/v3/Security/SsvcDecisionType/track"
    trackStar = "https://spdx.org/rdf/v3/Security/SsvcDecisionType/trackStar"


# VexJustificationType specifies the type of Vulnerability Exploitability eXchange (VEX) justification.
class security_VexJustificationType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Security/VexJustificationType"
    valid_values = [
        ("componentNotPresent", "https://spdx.org/rdf/v3/Security/VexJustificationType/componentNotPresent"),
        ("inlineMitigationsAlreadyExist", "https://spdx.org/rdf/v3/Security/VexJustificationType/inlineMitigationsAlreadyExist"),
        ("vulnerableCodeCannotBeControlledByAdversary", "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeCannotBeControlledByAdversary"),
        ("vulnerableCodeNotInExecutePath", "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeNotInExecutePath"),
        ("vulnerableCodeNotPresent", "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeNotPresent"),
    ]
    componentNotPresent = "https://spdx.org/rdf/v3/Security/VexJustificationType/componentNotPresent"
    inlineMitigationsAlreadyExist = "https://spdx.org/rdf/v3/Security/VexJustificationType/inlineMitigationsAlreadyExist"
    vulnerableCodeCannotBeControlledByAdversary = "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeCannotBeControlledByAdversary"
    vulnerableCodeNotInExecutePath = "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeNotInExecutePath"
    vulnerableCodeNotPresent = "https://spdx.org/rdf/v3/Security/VexJustificationType/vulnerableCodeNotPresent"


# The set of SBOM types with definitions as defined in [Types of Software Bill of Material (SBOM) Documents](https://www.cisa.gov/sites/default/files/2023-04/sbom-types-document-508c.pdf), published on April 21, 2023.
# An SBOM type describes the most likely type of an SBOM from the producer perspective, so that consumers can draw conclusions about the data inside an SBOM.  A single SBOM can have multiple SBOM document types associated with it.
class software_SbomType(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Software/SbomType"
    valid_values = [
        ("analyzed", "https://spdx.org/rdf/v3/Software/SbomType/analyzed"),
        ("build", "https://spdx.org/rdf/v3/Software/SbomType/build"),
        ("deployed", "https://spdx.org/rdf/v3/Software/SbomType/deployed"),
        ("design", "https://spdx.org/rdf/v3/Software/SbomType/design"),
        ("runtime", "https://spdx.org/rdf/v3/Software/SbomType/runtime"),
        ("source", "https://spdx.org/rdf/v3/Software/SbomType/source"),
    ]
    analyzed = "https://spdx.org/rdf/v3/Software/SbomType/analyzed"
    build = "https://spdx.org/rdf/v3/Software/SbomType/build"
    deployed = "https://spdx.org/rdf/v3/Software/SbomType/deployed"
    design = "https://spdx.org/rdf/v3/Software/SbomType/design"
    runtime = "https://spdx.org/rdf/v3/Software/SbomType/runtime"
    source = "https://spdx.org/rdf/v3/Software/SbomType/source"


# This field provides information about the primary purpose of an Element.
# Software Purpose is intrinsic to how the Element is being used rather than the content of the Element.
# This field is a reasonable estimate of the most likely usage of the Element
# from the producer and consumer perspective from which both parties can draw conclusions
# about the context in which the Element exists.
class software_SoftwarePurpose(EnumProp):
    TYPE = "https://spdx.org/rdf/v3/Software/SoftwarePurpose"
    valid_values = [
        ("application", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/application"),
        ("archive", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/archive"),
        ("bom", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/bom"),
        ("configuration", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/configuration"),
        ("container", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/container"),
        ("data", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/data"),
        ("device", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/device"),
        ("deviceDriver", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/deviceDriver"),
        ("diskImage", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/diskImage"),
        ("documentation", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/documentation"),
        ("evidence", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/evidence"),
        ("executable", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/executable"),
        ("file", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/file"),
        ("filesystemImage", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/filesystemImage"),
        ("firmware", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/firmware"),
        ("framework", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/framework"),
        ("install", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/install"),
        ("library", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/library"),
        ("manifest", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/manifest"),
        ("model", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/model"),
        ("module", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/module"),
        ("operatingSystem", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/operatingSystem"),
        ("other", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/other"),
        ("patch", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/patch"),
        ("platform", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/platform"),
        ("requirement", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/requirement"),
        ("source", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/source"),
        ("specification", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/specification"),
        ("test", "https://spdx.org/rdf/v3/Software/SoftwarePurpose/test"),
    ]
    application = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/application"
    archive = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/archive"
    bom = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/bom"
    configuration = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/configuration"
    container = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/container"
    data = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/data"
    device = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/device"
    deviceDriver = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/deviceDriver"
    diskImage = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/diskImage"
    documentation = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/documentation"
    evidence = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/evidence"
    executable = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/executable"
    file = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/file"
    filesystemImage = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/filesystemImage"
    firmware = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/firmware"
    framework = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/framework"
    install = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/install"
    library = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/library"
    manifest = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/manifest"
    model = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/model"
    module = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/module"
    operatingSystem = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/operatingSystem"
    other = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/other"
    patch = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/patch"
    platform = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/platform"
    requirement = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/requirement"
    source = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/source"
    specification = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/specification"
    test = "https://spdx.org/rdf/v3/Software/SoftwarePurpose/test"



# CLASSES
# The CreationInfo provides information about who created the Element, and when and how it was created.
#
# The dateTime created is often the date of last change (e.g., a git commit date), not the date when the SPDX data was created, as doing so supports reproducible builds.
class core_CreationInfo(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/CreationInfo"

    def __init__(self, **kwargs):
        super().__init__()
        # The specVersion provides a reference number that can be used to understand how to parse and interpret an Element.
        # It will enable both future changes to the specification and to support backward compatibility.
        # The major version number shall be incremented when incompatible changes between versions are made
        # (one or more sections are created, modified or deleted).
        # The minor version number shall be incremented when backwards compatible changes are made.
        #
        # Here, parties exchanging information in accordance with the SPDX specification need to provide
        # 100% transparency as to which SPDX specification version such information is conforming to.
        self._add_property(
            "specVersion",
            SemVerProp(),
            json_name="https://spdx.org/rdf/v3/Core/specVersion",
            min_count=1,
        )
        # A comment is an optional field for creators of the Element to provide comments
        # to the readers/reviewers of the document.
        self._add_property(
            "comment",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/comment",
        )
        # Created is a date that identifies when the Element was originally created.
        # The time stamp can serve as an indication as to whether the analysis needs to be updated. This is often the date of last change (e.g., a git commit date), not the date when the SPDX data was created, as doing so supports reproducible builds.
        self._add_property(
            "created",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/created",
            min_count=1,
        )
        # CreatedBy identifies who or what created the Element.
        # The generation method will assist the recipient of the Element in assessing
        # the general reliability/accuracy of the analysis information.
        self._add_property(
            "createdBy",
            ListProp(ObjectProp(core_Agent, False)),
            json_name="https://spdx.org/rdf/v3/Core/createdBy",
            min_count=1,
        )
        # CreatedUsing identifies the tooling that was used during the creation of the Element.
        # The generation method will assist the recipient of the Element in assessing
        # the general reliability/accuracy of the analysis information.
        self._add_property(
            "createdUsing",
            ListProp(ObjectProp(core_Tool, False)),
            json_name="https://spdx.org/rdf/v3/Core/createdUsing",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/CreationInfo"] = core_CreationInfo


# The class used for implementing a generic string mapping (also known as associative array, dictionary, or hash map) in SPDX.  Each DictionaryEntry contains a key-value pair which maps the key to its associated value.  To implement a dictionary, this class is to be used in a collection with unique keys.
class core_DictionaryEntry(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/DictionaryEntry"

    def __init__(self, **kwargs):
        super().__init__()
        # A key used in generic a key-value pair.
        # A key-value pair can be used to implement a dictionary which associates a key with a value.
        self._add_property(
            "key",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/key",
            min_count=1,
        )
        # A value used in a generic key-value pair.
        # A key-value pair can be used to implement a dictionary which associates a key with a value.
        self._add_property(
            "value",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/value",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/DictionaryEntry"] = core_DictionaryEntry


# An Element is a representation of a fundamental concept either directly inherent
# to the Bill of Materials (BOM) domain or indirectly related to the BOM domain
# and necessary for contextually characterizing BOM concepts and relationships.
# Within SPDX-3.0 structure this is the base class acting as a consistent,
# unifying, and interoperable foundation for all explicit
# and inter-relatable content objects.
class core_Element(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/Element"

    def __init__(self, **kwargs):
        super().__init__()
        # This field identifies the name of an Element as designated by the creator.
        # The name of an Element is an important convention and easier to refer to than the URI.
        self._add_property(
            "name",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/name",
        )
        # A summary is a short description of an Element. Here, the intent is to allow the Element creator to
        # provide concise information about the function or use of the Element.
        self._add_property(
            "summary",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/summary",
        )
        # This field is a detailed description of the Element. It may also be extracted from the Element itself.
        # The intent is to provide recipients of the SPDX file with a detailed technical explanation
        # of the functionality, anticipated use, and anticipated implementation of the Element.
        # This field may also include a description of improvements over prior versions of the Element.
        self._add_property(
            "description",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/description",
        )
        # A comment is an optional field for creators of the Element to provide comments
        # to the readers/reviewers of the document.
        self._add_property(
            "comment",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/comment",
        )
        # CreationInfo provides information about the creation of the Element.
        self._add_property(
            "creationInfo",
            ObjectProp(core_CreationInfo, True),
            json_name="https://spdx.org/rdf/v3/Core/creationInfo",
            min_count=1,
        )
        # VerifiedUsing provides an IntegrityMethod with which the integrity of an Element can be asserted.
        self._add_property(
            "verifiedUsing",
            ListProp(ObjectProp(core_IntegrityMethod, False)),
            json_name="https://spdx.org/rdf/v3/Core/verifiedUsing",
        )
        # This field points to a resource outside the scope of the SPDX-3.0 content
        # that provides additional characteristics of an Element.
        self._add_property(
            "externalRef",
            ListProp(ObjectProp(core_ExternalRef, False)),
            json_name="https://spdx.org/rdf/v3/Core/externalRef",
        )
        # ExternalIdentifier points to a resource outside the scope of SPDX-3.0 content
        # that uniquely identifies an Element.
        self._add_property(
            "externalIdentifier",
            ListProp(ObjectProp(core_ExternalIdentifier, False)),
            json_name="https://spdx.org/rdf/v3/Core/externalIdentifier",
        )
        # TODO
        self._add_property(
            "extension",
            ListProp(ExtensionProp()),
            json_name="https://spdx.org/rdf/v3/Core/extension",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Element"] = core_Element


# An ElementCollection is a collection of Elements, not necessarily with unifying context.
#
# Note that all ElementCollections must conform to the core profile even if the core profile is no specified in the profileConformance property.
# If the profileConformance property is not provided, core is to be assumed as the default.
#
# **Constraints**
# If the ElementCollection has at least 1 element, it must also have at least 1 rootElement.
#
# The element must not be of type SpdxDocument.
#
# The rootElement must not be of type SpdxDocument.
class core_ElementCollection(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/ElementCollection"

    def __init__(self, **kwargs):
        super().__init__()
        # This field refers to one or more Elements that are part of an ElementCollection.
        self._add_property(
            "element",
            ListProp(ObjectProp(core_Element, False)),
            json_name="https://spdx.org/rdf/v3/Core/element",
        )
        # This property is used to denote the root Element(s) of a tree of elements contained in an SBOM.
        # The tree consists of other elements directly and indirectly related through properties or Relationships from the root.
        self._add_property(
            "rootElement",
            ListProp(ObjectProp(core_Element, False)),
            json_name="https://spdx.org/rdf/v3/Core/rootElement",
        )
        # Describes a profile to which the creator of this ElementCollection intends to conform.
        # The profileConformance will apply to all Elements contained within the collection as well as the collection itself.
        # Conformance to a profile is defined by the additional restrictions documented in the profile specific documentation and schema files.
        # Use of this property allows the creator of an ElementCollection to communicate to consumers their intent to adhere to the profile additional restrictions.
        # The profileConformance has a default value of core if no other profileConformance is specified since all ElementCollections and Element must adhere to the core profile.
        self._add_property(
            "profileConformance",
            ListProp(core_ProfileIdentifierType()),
            json_name="https://spdx.org/rdf/v3/Core/profileConformance",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/ElementCollection"] = core_ElementCollection


# An ExternalIdentifier is a reference to a resource outside the scope of SPDX-3.0 content
# that uniquely identifies an Element.
class core_ExternalIdentifier(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/ExternalIdentifier"

    def __init__(self, **kwargs):
        super().__init__()
        # An externalIdentifierType specifies the type of the external identifier.
        self._add_property(
            "externalIdentifierType",
            core_ExternalIdentifierType(),
            json_name="https://spdx.org/rdf/v3/Core/externalIdentifierType",
            min_count=1,
        )
        # An identifier uniquely identifies an external element.
        self._add_property(
            "identifier",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/identifier",
            min_count=1,
        )
        # A comment is an optional field for creators of the Element to provide comments
        # to the readers/reviewers of the document.
        self._add_property(
            "comment",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/comment",
        )
        # A identifierLocator is TODO
        self._add_property(
            "identifierLocator",
            ListProp(AnyURIProp()),
            json_name="https://spdx.org/rdf/v3/Core/identifierLocator",
        )
        # An issuingAuthority is an entity that is authorized to issue identification credentials.
        #
        # The entity may be a government, non-profit, educational institution, or commercial enterprise.  The URI provides a unique identifier for the issuing authority.
        self._add_property(
            "issuingAuthority",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Core/issuingAuthority",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/ExternalIdentifier"] = core_ExternalIdentifier


# An External Map is a map of Element identifiers that are used within a Document
# but defined external to that Document.
# The external map provides details about the externally-defined Element
# such as its provenance, where to retrieve it, and how to verify its integrity.
class core_ExternalMap(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/ExternalMap"

    def __init__(self, **kwargs):
        super().__init__()
        # ExternalSpdxId identifies an external Element used within a Document but defined external to that Document.
        self._add_property(
            "externalSpdxId",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Core/externalSpdxId",
            min_count=1,
        )
        # VerifiedUsing provides an IntegrityMethod with which the integrity of an Element can be asserted.
        self._add_property(
            "verifiedUsing",
            ListProp(ObjectProp(core_IntegrityMethod, False)),
            json_name="https://spdx.org/rdf/v3/Core/verifiedUsing",
        )
        # A locationHint provides an indication of where to retrieve an external Element.
        self._add_property(
            "locationHint",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Core/locationHint",
        )
        # A definingArtifact property is used to link the Element identifier for an Element defined external to a given SpdxDocument to an Artifact Element representing the SPDX serialization instance which contains the definition for the Element.
        self._add_property(
            "definingArtifact",
            ObjectProp(core_Artifact, False),
            json_name="https://spdx.org/rdf/v3/Core/definingArtifact",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/ExternalMap"] = core_ExternalMap


# An External Reference points to a resource outside the scope of the SPDX-3.0 content
# that provides additional characteristics of an Element.
class core_ExternalRef(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/ExternalRef"

    def __init__(self, **kwargs):
        super().__init__()
        # An externalRefType specifies the type of the external reference.
        self._add_property(
            "externalRefType",
            core_ExternalRefType(),
            json_name="https://spdx.org/rdf/v3/Core/externalRefType",
        )
        # A locator provides the location of an external reference.
        self._add_property(
            "locator",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Core/locator",
        )
        # ContentType specifies the media type of an Element or Property.
        self._add_property(
            "contentType",
            MediaTypeProp(),
            json_name="https://spdx.org/rdf/v3/Core/contentType",
        )
        # A comment is an optional field for creators of the Element to provide comments
        # to the readers/reviewers of the document.
        self._add_property(
            "comment",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/comment",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/ExternalRef"] = core_ExternalRef


# An IntegrityMethod provides an independently reproducible mechanism that permits verification
# of a specific Element that correlates to the data in this SPDX document. This identifier enables
# a recipient to determine if anything in the original Element has been changed and eliminates
# confusion over which version or modification of a specific Element is referenced.
class core_IntegrityMethod(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/IntegrityMethod"

    def __init__(self, **kwargs):
        super().__init__()
        # A comment is an optional field for creators of the Element to provide comments
        # to the readers/reviewers of the document.
        self._add_property(
            "comment",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/comment",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/IntegrityMethod"] = core_IntegrityMethod


# A namespace map allows the creator of a collection of Elements that could be serialized to suggest
# a set of shorter identifiers ("prefixes") for particular namespace portions
# of ElementIDs to be used in SPDX content serialization in order to provide a more
# human-readable and smaller serialized representation of the Elements.
#
# For details of how NamespaceMap content is to be serialized please refer to general SPDX serialization guidance at https://spdx.github.io/spdx-3-model/serialization/readme.md and the various serialization format specific .md filed under https://spdx.github.io/spdx-3-model/serialization/ (TODO: update the URLs as soon as the context is publicly available)
#
# Namespace maps support a variety of relevant use cases such as:
#
# <<<<<<< HEAD
# 1) An SPDX content producer wishing to provide clarity of their serialization of an SPDX 2.X simple style collection where all content is newly minted and a single prefix-namespace is used.  The consumer of SPDX content wishes to preserve the name space mapping provided by such a producer.  In this case, the consumer would record the namespace map prefixes in the NamespaceMap such that subsequent serializations could reproduce the prefixes / namespaces in the native serialization format.
# 2) An SPDX content producer wishing to maintain consistent prefix use and understanding across multiple different serialization formats of the produced content.
#    For example, an SBOM producer wishes to share/publish the SBOM as JSON-LD and XML. The producer can specify the preferred prefix mappings in the native serialization format using information from a single Namespacemap accessible local to the producer.
# 3) An SPDX content consumer/producer wishing to maintain consistent prefix use while round tripping from SPDX content received, deserialized, modified/extended in some way, and then reserialized in the same serialization form.
#    In this case the prefix-namespace mappings utilized in the content are transformed from the original native namespace/prefix into the in memory NamespaceMap then transformed from the NamespaceMap back into the resultant serialization native namespace / prefix format.
class core_NamespaceMap(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/NamespaceMap"

    def __init__(self, **kwargs):
        super().__init__()
        # A prefix is a substitute for a URI.
        self._add_property(
            "prefix",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/prefix",
            min_count=1,
        )
        # A namespace provides an unambiguous mechanism for conveying a URI fragment portion of an ElementID.
        self._add_property(
            "namespace",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Core/namespace",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/NamespaceMap"] = core_NamespaceMap


# PositiveIntegerRange is a tuple of two positive integers that define a range.
# "begin" must be less than or equal to "end".
class core_PositiveIntegerRange(SHACLObject):
    TYPE = "https://spdx.org/rdf/v3/Core/PositiveIntegerRange"

    def __init__(self, **kwargs):
        super().__init__()
        # begin is a positive integer that defines the beginning of a range.
        self._add_property(
            "begin",
            PositiveIntegerProp(),
            json_name="https://spdx.org/rdf/v3/Core/begin",
            min_count=1,
        )
        # end is a positive integer that defines the end of a range.
        self._add_property(
            "end",
            PositiveIntegerProp(),
            json_name="https://spdx.org/rdf/v3/Core/end",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/PositiveIntegerRange"] = core_PositiveIntegerRange


# A Relationship is a grouping of characteristics unique to an assertion
# that one Element is related to one or more other Elements in some way.
class core_Relationship(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/Relationship"

    def __init__(self, **kwargs):
        super().__init__()
        # This field references the Element on the left-hand side of a relationship.
        self._add_property(
            "from_",
            ObjectProp(core_Element, True),
            json_name="https://spdx.org/rdf/v3/Core/from",
            min_count=1,
        )
        # This field references an Element on the right-hand side of a relationship.
        self._add_property(
            "to",
            ListProp(ObjectProp(core_Element, False)),
            json_name="https://spdx.org/rdf/v3/Core/to",
        )
        # This field provides information about the relationship between two Elements.
        # For example, you can represent a relationship between two different Files,
        # between a Package and a File, between two Packages, or between one SPDXDocument and another SPDXDocument.
        self._add_property(
            "relationshipType",
            core_RelationshipType(),
            json_name="https://spdx.org/rdf/v3/Core/relationshipType",
            min_count=1,
        )
        # Completeness gives information about whether the provided relationships are
        # complete, known to be incomplete or if no assertion is made either way.
        self._add_property(
            "completeness",
            core_RelationshipCompleteness(),
            json_name="https://spdx.org/rdf/v3/Core/completeness",
        )
        # A startTime specifies the time from which element is applicable / valid.
        self._add_property(
            "startTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/startTime",
        )
        # A endTime specifies the time from which element is no applicable / valid.
        self._add_property(
            "endTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/endTime",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Relationship"] = core_Relationship


# The SpdxDocument provides a convenient way to express information about collections of SPDX Elements that could potentially be serialized as complete
# units (e.g., all in-scope SPDX data within a single JSON-LD file). SpdxDocument is independent of any particular serialization format or instance.
# Information we wish to preserve about a specific instance of serialization of this SPDX content is NOT expressed using the SpdxDocument but rather using an associated Artifact representing a particular instance of SPDX data physical serialization.
#
# Any instance of serialization of SPDX data MUST NOT contain more than one SpdxDocument element definition.
class core_SpdxDocument(core_ElementCollection):
    TYPE = "https://spdx.org/rdf/v3/Core/SpdxDocument"

    def __init__(self, **kwargs):
        super().__init__()
        # Imports provides an ExternalMap of Element identifiers that are used within a document
        # but defined external to that document.
        self._add_property(
            "imports",
            ListProp(ObjectProp(core_ExternalMap, False)),
            json_name="https://spdx.org/rdf/v3/Core/imports",
        )
        # This field provides a NamespaceMap of prefixes and associated namespace partial URIs applicable to an SpdxDocument and independent of any specific serialization format or instance.
        self._add_property(
            "namespaceMap",
            ListProp(ObjectProp(core_NamespaceMap, False)),
            json_name="https://spdx.org/rdf/v3/Core/namespaceMap",
        )
        # The data license provides the license under which the SPDX documentation of the Element can be used.
        # This is to alleviate any concern that content (the data or database) in an SPDX file
        # is subject to any form of intellectual property right that could restrict the re-use
        # of the information or the creation of another SPDX file for the same project(s).
        # This approach avoids intellectual property and related restrictions over the SPDX file,
        # however individuals can still contract with each other to restrict release
        # of specific collections of SPDX files (which map to software bill of materials)
        # and the identification of the supplier of SPDX files.
        # Compliance with this document includes populating the SPDX fields therein
        # with data related to such fields ("SPDX-Metadata").
        # This document contains numerous fields where an SPDX file creator may provide
        # relevant explanatory text in SPDX-Metadata. Without opining on the lawfulness
        # of "database rights" (in jurisdictions where applicable),
        # such explanatory text is copyrightable subject matter in most Berne Convention countries.
        # By using the SPDX specification, or any portion hereof,
        # you hereby agree that any copyright rights (as determined by your jurisdiction)
        # in any SPDX-Metadata, including without limitation explanatory text,
        # shall be subject to the terms of the Creative Commons CC0 1.0 Universal license.
        # For SPDX-Metadata not containing any copyright rights,
        # you hereby agree and acknowledge that the SPDX-Metadata is provided to you "as-is"
        # and without any representations or warranties of any kind concerning the SPDX-Metadata,
        # express, implied, statutory or otherwise, including without limitation warranties
        # of title, merchantability, fitness for a particular purpose, non-infringement,
        # or the absence of latent or other defects, accuracy, or the presence or absence of errors,
        # whether or not discoverable, all to the greatest extent permissible under applicable law.
        self._add_property(
            "dataLicense",
            ObjectProp(simplelicensing_AnyLicenseInfo, False),
            json_name="https://spdx.org/rdf/v3/Core/dataLicense",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/SpdxDocument"] = core_SpdxDocument


# A Tool is an element of hardware and/or software utilized to carry out a particular function.
class core_Tool(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/Tool"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Tool"] = core_Tool


# A LicenseAddition represents text which is intended to be added to a License
# as additional text, but which is not itself intended to be a standalone
# License.
#
# It may be an exception which is listed on the SPDX Exceptions List
# (ListedLicenseException), or may be any other additional text (as an exception
# or otherwise) which is defined by an SPDX data creator (CustomLicenseAddition).
class expandedlicensing_LicenseAddition(core_Element):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/LicenseAddition"

    def __init__(self, **kwargs):
        super().__init__()
        # An additionText contains the plain text of the LicenseAddition, without
        # templating or other similar markup.
        #
        # Users of the additionText for a License can apply the SPDX Matching Guidelines
        # when comparing it to another text for matching purposes.
        self._add_property(
            "additionText",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/additionText",
            min_count=1,
        )
        # A standardAdditionTemplate contains a license addition template which describes
        # sections of the LicenseAddition text which can be varied. See the Legacy Text
        # Template format section of the SPDX specification for format information.
        self._add_property(
            "standardAdditionTemplate",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/standardAdditionTemplate",
        )
        # The isDeprecatedAdditionId property specifies whether an identifier for a
        # LicenseAddition has been marked as deprecated. If the property is not defined,
        # then it is presumed to be false (i.e., not deprecated).
        #
        # If the LicenseAddition is included on the SPDX Exceptions List, then
        # the `deprecatedVersion` property indicates on which version release of the
        # Exceptions List it was first marked as deprecated.
        #
        # "Deprecated" in this context refers to deprecating the use of the
        # _identifier_, not the underlying license addition. In other words, even if a
        # LicenseAddition's author or steward has stated that a particular
        # LicenseAddition generally should not be used, that would _not_ mean that the
        # LicenseAddition's identifier is "deprecated." Rather, a LicenseAddition
        # operator is typically marked as "deprecated" when it is determined that use of
        # another identifier is preferable.
        self._add_property(
            "isDeprecatedAdditionId",
            BooleanProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/isDeprecatedAdditionId",
        )
        # An obsoletedBy value for a deprecated License or LicenseAddition specifies
        # the licenseId of the replacement License or LicenseAddition that is preferred
        # to be used in its place. It should use the same format as specified for a
        # licenseId.
        #
        # The License's or LicenseAddition's comment value may include more information
        # about the reason why the licenseId specified in the obsoletedBy value is
        # preferred.
        self._add_property(
            "obsoletedBy",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/obsoletedBy",
        )
        # The license XML format is defined and used by the SPDX legal team.
        # See the XML fields defined at https://github.com/spdx/license-list-XML/blob/main/DOCS/xml-fields.md for a text description.
        # There is also an XML schema available at https://github.com/spdx/license-list-XML/blob/main/schema/ListedLicense.xsd.
        self._add_property(
            "licenseXml",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/licenseXml",
        )
        # A seeAlso defines a cross-reference with a URL where the License or
        # LicenseAddition can be found in use by one or a few projects.
        #
        # If applicable, it should include a URL where the license text is posted by
        # the license steward, particularly if the license steward has made available a
        # "canonical" primary URL for the license text.
        #
        # If the license is OSI approved, a seeAlso should be included with the URL for
        # the license's listing on the OSI website.
        #
        # The seeAlso URL may refer to a previously-available URL for the License or
        # LicenseAddition which is no longer active.
        #
        # Where applicable, the seeAlso URL should include the license text in its
        # native language. seeAlso URLs to English or other translations may be included
        # where multiple, equivalent official translations exist.
        self._add_property(
            "seeAlso",
            ListProp(AnyURIProp()),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/seeAlso",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/LicenseAddition"] = expandedlicensing_LicenseAddition


# A ListedLicenseException represents an exception to a License (in other words,
# an exception to a license condition or an additional permission beyond those
# granted in a License) which is listed on the SPDX Exceptions List at
# https://spdx.org/licenses/exceptions-index.html.
class expandedlicensing_ListedLicenseException(expandedlicensing_LicenseAddition):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/ListedLicenseException"

    def __init__(self, **kwargs):
        super().__init__()
        # A listVersionAdded for a ListedLicense or ListedLicenseException on the SPDX
        # License List specifies which version release of the License List was the first
        # one in which it was included.
        self._add_property(
            "listVersionAdded",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/listVersionAdded",
        )
        # A deprecatedVersion for a ListedLicense or ListedLicenseException on the SPDX
        # License List specifies which version release of the License List was the first
        # one in which it was marked as deprecated.
        self._add_property(
            "deprecatedVersion",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/deprecatedVersion",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/ListedLicenseException"] = expandedlicensing_ListedLicenseException


# VulnAssessmentRelationship is the ancestor class common to all vulnerability
# assessment relationships. It factors out the common properties shared by them.
# External property restriction on /Core/Relationship/to: minCount: 1
class security_VulnAssessmentRelationship(core_Relationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies subpackages, files or snippets referenced by a security assessment
        # to specify the precise location where a vulnerability was found.
        self._add_property(
            "assessedElement",
            ObjectProp(core_Element, False),
            json_name="https://spdx.org/rdf/v3/Security/assessedElement",
        )
        # Specifies the time when a vulnerability was first published.
        self._add_property(
            "publishedTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/publishedTime",
        )
        # Identify the actual distribution source for the artifact (e.g., snippet, file, package, vulnerability) or VulnAssessmentRelationship being referenced.
        # This might or might not be different from the originating distribution source for the artifact (e.g., snippet, file, package, vulnerability) or VulnAssessmentRelationship..
        self._add_property(
            "CoresuppliedBy",
            ObjectProp(core_Agent, False),
            json_name="https://spdx.org/rdf/v3/Core/suppliedBy",
        )
        # Specifies a time when a vulnerability assessment was last modified.
        self._add_property(
            "modifiedTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/modifiedTime",
        )
        # Specified the time and date when a vulnerability was withdrawn.
        self._add_property(
            "withdrawnTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/withdrawnTime",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VulnAssessmentRelationship"] = security_VulnAssessmentRelationship


# An AnyLicenseInfo is used by licensing properties of software artifacts.
# It can be a NoneLicense, a NoAssertionLicense,
# single license (either on the SPDX License List or a custom-defined license);
# a single license with an "or later" operator applied; the foregoing with
# additional text applied; or a set of licenses combined by applying "AND" and
# "OR" operators recursively.
class simplelicensing_AnyLicenseInfo(core_Element):
    TYPE = "https://spdx.org/rdf/v3/SimpleLicensing/AnyLicenseInfo"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/SimpleLicensing/AnyLicenseInfo"] = simplelicensing_AnyLicenseInfo


# Often a single license can be used to represent the licensing terms of a source code or binary file, but there are situations where a single license identifier is not sufficient. A common example is when software is offered under a choice of one or more licenses (e.g., GPL-2.0-only OR BSD-3-Clause). Another example is when a set of licenses is needed to represent a binary program constructed by compiling and linking two (or more) different source files each governed by different licenses (e.g., LGPL-2.1-only AND BSD-3-Clause).
#
# SPDX License Expressions provide a way for one to construct expressions that more accurately represent the licensing terms typically found in open source software source code. A license expression could be a single license identifier found on the SPDX License List; a user defined license reference denoted by the LicenseRef-idString; a license identifier combined with an SPDX exception; or some combination of license identifiers, license references and exceptions constructed using a small set of defined operators (e.g., AND, OR, WITH and +). We provide the definition of what constitutes a valid an SPDX License Expression in this section.
class simplelicensing_LicenseExpression(simplelicensing_AnyLicenseInfo):
    TYPE = "https://spdx.org/rdf/v3/SimpleLicensing/LicenseExpression"

    def __init__(self, **kwargs):
        super().__init__()
        # Often a single license can be used to represent the licensing terms of a source code or binary file, but there are situations where a single license identifier is not sufficient. A common example is when software is offered under a choice of one or more licenses (e.g., GPL-2.0-only OR BSD-3-Clause). Another example is when a set of licenses is needed to represent a binary program constructed by compiling and linking two (or more) different source files each governed by different licenses (e.g., LGPL-2.1-only AND BSD-3-Clause).
        #
        # SPDX License Expressions provide a way for one to construct expressions that more accurately represent the licensing terms typically found in open source software source code. A license expression could be a single license identifier found on the SPDX License List; a user defined license reference denoted by the LicenseRef-idString; a license identifier combined with an SPDX exception; or some combination of license identifiers, license references and exceptions constructed using a small set of defined operators (e.g., AND, OR, WITH and +). We provide the definition of what constitutes a valid an SPDX License Expression in this section.
        self._add_property(
            "licenseExpression",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/SimpleLicensing/licenseExpression",
            min_count=1,
        )
        # Recognizing that licenses are added to the SPDX License List with each subsequent version, the intent is to provide consumers with the version of the SPDX License List used.
        # This anticipates that in the future, license expression might have used a version of the SPDX License List that is older than the then current one.
        # The specified version of the SPDX License List must include all listed licenses and exceptions referenced in the expression.
        self._add_property(
            "licenseListVersion",
            SemVerProp(),
            json_name="https://spdx.org/rdf/v3/SimpleLicensing/licenseListVersion",
        )
        # Within a License Expression, references can be made to a Custom License or a Custom License Addition.
        # The License Expression syntax dictates any refence starting with a "LicenseRef-" or "AdditionRef-" refers to license or addition text not found in the SPDX list of licenses.
        # These custom licenses must be a CustomLicense, a CustomLicenseAddtion, or a SimpleLicensingText which are identified with a unique URI identifier.
        # The key for the DictionaryEntry is the string used in the license expression and the value is the URI for the corrosponding CustomLicense, CustomLicenseAddition, or SimpleLicensingText.
        self._add_property(
            "customIdToUri",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/SimpleLicensing/customIdToUri",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/SimpleLicensing/LicenseExpression"] = simplelicensing_LicenseExpression


# A SimpleLicensingText represents a License or Addition that is not listed on the SPDX License
# List at https://spdx.org/licenses, and is therefore defined by an SPDX data
# creator.
class simplelicensing_SimpleLicensingText(core_Element):
    TYPE = "https://spdx.org/rdf/v3/SimpleLicensing/SimpleLicensingText"

    def __init__(self, **kwargs):
        super().__init__()
        # A licenseText contains the plain text of the License or Addition,
        # without templating or other similar markup.
        #
        # Users of the licenseText for a License can apply the SPDX Matching Guidelines
        # when comparing it to another text for matching purposes.
        self._add_property(
            "licenseText",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/SimpleLicensing/licenseText",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/SimpleLicensing/SimpleLicensingText"] = simplelicensing_SimpleLicensingText


# A build is a representation of the process in which a piece of software or artifact is built. It encapsulates information related to a build process and
# provides an element from which relationships can be created to describe the build's inputs, outputs, and related entities (e.g. builders, identities, etc.).
#
# Definitions of "buildType", "configSourceEntrypoint", "configSourceUri", "parameters" and "environment" follow those defined in [SLSA provenance](https://slsa.dev/provenance/v0.2).
#
# ExternalIdentifier of type "urlScheme" may be used to identify build logs. In this case, the comment of the ExternalIdentifier should be "LogReference".
#
# Note that buildStartTime and buildEndTime are optional, and may be omitted to simplify creating reproducible builds.
class build_Build(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Build/Build"

    def __init__(self, **kwargs):
        super().__init__()
        # A buildType is a URI expressing the toolchain, platform, or infrastructure that the build was invoked on. For example, if the build was invoked on GitHub's CI platform using github actions, the buildType can be expressed as `https://github.com/actions`. In contrast, if the build was invoked on a local machine, the buildType can be expressed as `file://username@host/path/to/build`.
        self._add_property(
            "buildType",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Build/buildType",
            min_count=1,
        )
        # A buildId is a locally unique identifier to identify a unique instance of a build. This identifier differs based on build toolchain, platform, or naming convention used by an organization or standard.
        self._add_property(
            "buildId",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Build/buildId",
        )
        # A build entrypoint is the invoked executable of a build which always runs when the build is triggered. For example, when a build is triggered by running a shell script, the entrypoint is `script.sh`. In terms of a declared build, the entrypoint is the position in a configuration file or a build declaration which is always run when the build is triggered. For example, in the following configuration file, the entrypoint of the build is `publish`.
        #
        # ```
        # name: Publish packages to PyPI
        #
        # on:
        # create:
        # tags: "*"
        #
        # jobs:
        # publish:
        # runs-on: ubuntu-latest
        # if: startsWith(github.ref, 'refs/tags/')
        # steps:
        #
        # ...
        # ```
        self._add_property(
            "configSourceEntrypoint",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Build/configSourceEntrypoint",
        )
        # If a build configuration exists for the toolchain or platform performing the build, the configSourceUri of a build is the URI of that build configuration. For example, a build triggered by a GitHub action is defined by a build configuration YAML file. In this case, the configSourceUri is the URL of that YAML file.
        # m
        self._add_property(
            "configSourceUri",
            ListProp(AnyURIProp()),
            json_name="https://spdx.org/rdf/v3/Build/configSourceUri",
        )
        # configSourceDigest is the checksum of the build configuration file used by a builder to execute a build. This Property uses the Core model's [Hash](../../Core/Classes/Hash.md) class.
        self._add_property(
            "configSourceDigest",
            ListProp(ObjectProp(core_Hash, False)),
            json_name="https://spdx.org/rdf/v3/Build/configSourceDigest",
        )
        # parameters is a key-value map of all build parameters and their values that were provided to the builder for a build instance. This is different from the [environment](environment.md) property in that the keys and values are provided as command line arguments or a configuration file to the builder.
        self._add_property(
            "parameters",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/Build/parameters",
        )
        # buildStartTime is the time at which a build is triggered. The builder typically records this value.
        self._add_property(
            "buildStartTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Build/buildStartTime",
        )
        # buildEndTime describes the time at which a build stops or finishes. This value is typically recorded by the builder.
        self._add_property(
            "buildEndTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Build/buildEndTime",
        )
        # environment is a map of environment variables and values that are set during a build session. This is different from the [parameters](parameters.md) property in that it describes the environment variables set before a build is invoked rather than the variables provided to the builder.
        self._add_property(
            "environment",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/Build/environment",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Build/Build"] = build_Build


# The Agent class represents anything that has the potential to act on a system. This could be a person, organization, software agent, etc. This is not to be confused with tools that are used to perform tasks.
class core_Agent(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/Agent"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Agent"] = core_Agent


# An Annotation is an assertion made in relation to one or more elements. The `contentType` property describes the format of the `statement` property.
class core_Annotation(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/Annotation"

    def __init__(self, **kwargs):
        super().__init__()
        # An annotationType describes the type of an annotation.
        self._add_property(
            "annotationType",
            core_AnnotationType(),
            json_name="https://spdx.org/rdf/v3/Core/annotationType",
            min_count=1,
        )
        # ContentType specifies the media type of an Element or Property.
        self._add_property(
            "contentType",
            MediaTypeProp(),
            json_name="https://spdx.org/rdf/v3/Core/contentType",
        )
        # A statement is a commentary on an assertion that an annotator has made.
        self._add_property(
            "statement",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/statement",
        )
        # A subject is an Element an annotator has made an assertion about.
        self._add_property(
            "subject",
            ObjectProp(core_Element, True),
            json_name="https://spdx.org/rdf/v3/Core/subject",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Annotation"] = core_Annotation


# An artifact is a distinct article or unit within the digital domain,
# such as an electronic file, a software package, a device or an element of data.
class core_Artifact(core_Element):
    TYPE = "https://spdx.org/rdf/v3/Core/Artifact"

    def __init__(self, **kwargs):
        super().__init__()
        # OriginatedBy identifies from where or whom the Element originally came.
        self._add_property(
            "originatedBy",
            ListProp(ObjectProp(core_Agent, False)),
            json_name="https://spdx.org/rdf/v3/Core/originatedBy",
        )
        # Identify the actual distribution source for the artifact (e.g., snippet, file, package, vulnerability) or VulnAssessmentRelationship being referenced.
        # This might or might not be different from the originating distribution source for the artifact (e.g., snippet, file, package, vulnerability) or VulnAssessmentRelationship..
        self._add_property(
            "suppliedBy",
            ObjectProp(core_Agent, False),
            json_name="https://spdx.org/rdf/v3/Core/suppliedBy",
        )
        # A builtTime specifies the time an artifact was built.
        self._add_property(
            "builtTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/builtTime",
        )
        # A releaseTime specifies the time an artifact was released.
        self._add_property(
            "releaseTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/releaseTime",
        )
        # A validUntilTime specifies until when the artifact can be used before its usage needs to be reassessed.
        self._add_property(
            "validUntilTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Core/validUntilTime",
        )
        # Various standards may be relevant to useful to capture for specific artifacts.
        self._add_property(
            "standard",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Core/standard",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Artifact"] = core_Artifact


# A bundle is a collection of Elements that have a shared context.
class core_Bundle(core_ElementCollection):
    TYPE = "https://spdx.org/rdf/v3/Core/Bundle"

    def __init__(self, **kwargs):
        super().__init__()
        # A context gives information about the circumstances or unifying properties
        # that Elements of the bundle have been assembled under.
        self._add_property(
            "context",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/context",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Bundle"] = core_Bundle


# A hash is a grouping of characteristics unique to the result
# of applying a mathematical algorithm
# that maps data of arbitrary size to a bit string (the hash)
# and is a one-way function, that is,
# a function which is practically infeasible to invert.
# This is commonly used for integrity checking of data.
class core_Hash(core_IntegrityMethod):
    TYPE = "https://spdx.org/rdf/v3/Core/Hash"

    def __init__(self, **kwargs):
        super().__init__()
        # An algorithm specifies the algorithm that was used for calculating the hash value.
        self._add_property(
            "algorithm",
            core_HashAlgorithm(),
            json_name="https://spdx.org/rdf/v3/Core/algorithm",
            min_count=1,
        )
        # HashValue is the result of applying a hash algorithm to an Element.
        self._add_property(
            "hashValue",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Core/hashValue",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Hash"] = core_Hash


# TODO
class core_LifecycleScopedRelationship(core_Relationship):
    TYPE = "https://spdx.org/rdf/v3/Core/LifecycleScopedRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # A scope is TODO
        self._add_property(
            "scope",
            core_LifecycleScopeType(),
            json_name="https://spdx.org/rdf/v3/Core/scope",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/LifecycleScopedRelationship"] = core_LifecycleScopedRelationship


# An Organization is a group of people who work together in an organized way for a shared purpose.
class core_Organization(core_Agent):
    TYPE = "https://spdx.org/rdf/v3/Core/Organization"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Organization"] = core_Organization


# A Person is an individual human being.
class core_Person(core_Agent):
    TYPE = "https://spdx.org/rdf/v3/Core/Person"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Person"] = core_Person


# A SoftwareAgent is a software program that is given the authority (similar to a user's authority) to act on a system.
class core_SoftwareAgent(core_Agent):
    TYPE = "https://spdx.org/rdf/v3/Core/SoftwareAgent"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/SoftwareAgent"] = core_SoftwareAgent


# A ConjunctiveLicenseSet indicates that _each_ of its subsidiary
# AnyLicenseInfos apply. In other words, a ConjunctiveLicenseSet of two or
# more licenses represents a licensing situation where _all_ of the specified
# licenses are to be complied with. It is represented in the SPDX License
# Expression Syntax by the `AND` operator.
#
# It is syntactically correct to specify a ConjunctiveLicenseSet where the
# subsidiary AnyLicenseInfos may be "incompatible" according to a particular
# interpretation of the corresponding Licenses. The SPDX License Expression
# Syntax does not take into account interpretation of license texts, which is
# left to the consumer of SPDX data to determine for themselves.
class expandedlicensing_ConjunctiveLicenseSet(simplelicensing_AnyLicenseInfo):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/ConjunctiveLicenseSet"

    def __init__(self, **kwargs):
        super().__init__()
        # A member is a license expression participating in a conjunctive (of type
        # ConjunctiveLicenseSet) or a disjunctive (of type DisjunctiveLicenseSet)
        # license set.
        self._add_property(
            "member",
            ListProp(ObjectProp(simplelicensing_AnyLicenseInfo, False)),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/member",
            min_count=2,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/ConjunctiveLicenseSet"] = expandedlicensing_ConjunctiveLicenseSet


# A CustomLicenseAddition represents an addition to a License that is not listed
# on the SPDX Exceptions List at https://spdx.org/licenses/exceptions-index.html,
# and is therefore defined by an SPDX data creator.
#
# It is intended to represent additional language which is meant to be added to
# a License, but which is not itself a standalone License.
class expandedlicensing_CustomLicenseAddition(expandedlicensing_LicenseAddition):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/CustomLicenseAddition"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/CustomLicenseAddition"] = expandedlicensing_CustomLicenseAddition


# A DisjunctiveLicenseSet indicates that _only one_ of its subsidiary
# AnyLicenseInfos is required to apply. In other words, a
# DisjunctiveLicenseSet of two or more licenses represents a licensing
# situation where _only one_ of the specified licenses are to be complied with.
# A consumer of SPDX data would typically understand this to permit the recipient
# of the licensed content to choose which of the corresponding license they
# would prefer to use. It is represented in the SPDX License Expression Syntax
# by the `OR` operator.
class expandedlicensing_DisjunctiveLicenseSet(simplelicensing_AnyLicenseInfo):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/DisjunctiveLicenseSet"

    def __init__(self, **kwargs):
        super().__init__()
        # A member is a license expression participating in a conjunctive (of type
        # ConjunctiveLicenseSet) or a disjunctive (of type DisjunctiveLicenseSet)
        # license set.
        self._add_property(
            "member",
            ListProp(ObjectProp(simplelicensing_AnyLicenseInfo, False)),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/member",
            min_count=2,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/DisjunctiveLicenseSet"] = expandedlicensing_DisjunctiveLicenseSet


# The WithAdditionOperator can have a License or an OrLaterOperator as the license property value.  This class is used for the value.
class expandedlicensing_ExtendableLicense(simplelicensing_AnyLicenseInfo):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/ExtendableLicense"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/ExtendableLicense"] = expandedlicensing_ExtendableLicense


# A License represents a license text, whether listed on the SPDX License List
# (ListedLicense) or defined by an SPDX data creator (CustomLicense).
class expandedlicensing_License(expandedlicensing_ExtendableLicense):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/License"

    def __init__(self, **kwargs):
        super().__init__()
        # A licenseText contains the plain text of the License or Addition,
        # without templating or other similar markup.
        #
        # Users of the licenseText for a License can apply the SPDX Matching Guidelines
        # when comparing it to another text for matching purposes.
        self._add_property(
            "SimpleLicensinglicenseText",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/SimpleLicensing/licenseText",
            min_count=1,
        )
        # isOsiApproved specifies whether the [Open Source Initiative (OSI)](https://opensource.org)
        # has listed this License as "approved" in their list of OSI Approved Licenses,
        # located at the time of this writing at https://opensource.org/licenses/.
        #
        # A value of "true" indicates that the license is in the list of licenses that OSI publishes as approved.
        #
        # A value of "false" indicates that the license is explicitly not in the corresponding list of OSI licenses (e.g., OSI has stated publicly that a license is not approved).
        #
        # If the isOsiApproved field is not specified, the SPDX data creator makes no
        # assertions about whether the License is approved by the OSI.
        self._add_property(
            "isOsiApproved",
            BooleanProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/isOsiApproved",
        )
        # isFsfLibre specifies whether the [Free Software Foundation FSF](https://fsf.org)
        # has listed this License as "free" in their commentary on licenses, located at
        # the time of this writing at https://www.gnu.org/licenses/license-list.en.html.
        #
        # A value of "true" indicates that the license is in the list of licenses that FSF publishes as libre.
        #
        # A value of "false" indicates that the license is explicitly not in the corresponding list of FSF libre licenses (e.g., FSF has the license on a non-free list).
        #
        # If the isFsfLibre field is not specified, the SPDX data creator makes no
        # assertions about whether the License is listed in the FSF's commentary.
        self._add_property(
            "isFsfLibre",
            BooleanProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/isFsfLibre",
        )
        # A standardLicenseHeader contains the plain text of the License author's
        # preferred wording to be used, typically in a source code file's header
        # comments or similar location, to indicate that the file is subject to
        # the specified License.
        self._add_property(
            "standardLicenseHeader",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/standardLicenseHeader",
        )
        # A standardLicenseTemplate contains a license template which describes
        # sections of the License text which can be varied. See the Legacy Text Template
        # format section of the SPDX specification for format information.
        self._add_property(
            "standardLicenseTemplate",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/standardLicenseTemplate",
        )
        # The isDeprecatedLicenseId property specifies whether an identifier for a
        # License or LicenseAddition has been marked as deprecated. If the property
        # is not defined, then it is presumed to be false (i.e., not deprecated).
        #
        # If the License or LicenseAddition is included on the SPDX License List, then
        # the `deprecatedVersion` property indicates on which version release of the
        # License List it was first marked as deprecated.
        #
        # "Deprecated" in this context refers to deprecating the use of the
        # _identifier_, not the underlying license. In other words, even if a License's
        # author or steward has stated that a particular License generally should not be
        # used, that would _not_ mean that the License's identifier is "deprecated."
        # Rather, a License or LicenseAddition operator is typically marked as
        # "deprecated" when it is determined that use of another identifier is
        # preferable.
        self._add_property(
            "isDeprecatedLicenseId",
            BooleanProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/isDeprecatedLicenseId",
        )
        # An obsoletedBy value for a deprecated License or LicenseAddition specifies
        # the licenseId of the replacement License or LicenseAddition that is preferred
        # to be used in its place. It should use the same format as specified for a
        # licenseId.
        #
        # The License's or LicenseAddition's comment value may include more information
        # about the reason why the licenseId specified in the obsoletedBy value is
        # preferred.
        self._add_property(
            "obsoletedBy",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/obsoletedBy",
        )
        # The license XML format is defined and used by the SPDX legal team.
        # See the XML fields defined at https://github.com/spdx/license-list-XML/blob/main/DOCS/xml-fields.md for a text description.
        # There is also an XML schema available at https://github.com/spdx/license-list-XML/blob/main/schema/ListedLicense.xsd.
        self._add_property(
            "licenseXml",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/licenseXml",
        )
        # A seeAlso defines a cross-reference with a URL where the License or
        # LicenseAddition can be found in use by one or a few projects.
        #
        # If applicable, it should include a URL where the license text is posted by
        # the license steward, particularly if the license steward has made available a
        # "canonical" primary URL for the license text.
        #
        # If the license is OSI approved, a seeAlso should be included with the URL for
        # the license's listing on the OSI website.
        #
        # The seeAlso URL may refer to a previously-available URL for the License or
        # LicenseAddition which is no longer active.
        #
        # Where applicable, the seeAlso URL should include the license text in its
        # native language. seeAlso URLs to English or other translations may be included
        # where multiple, equivalent official translations exist.
        self._add_property(
            "seeAlso",
            ListProp(AnyURIProp()),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/seeAlso",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/License"] = expandedlicensing_License


# A ListedLicense represents a License that is listed on the SPDX License List
# at https://spdx.org/licenses.
class expandedlicensing_ListedLicense(expandedlicensing_License):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/ListedLicense"

    def __init__(self, **kwargs):
        super().__init__()
        # A listVersionAdded for a ListedLicense or ListedLicenseException on the SPDX
        # License List specifies which version release of the License List was the first
        # one in which it was included.
        self._add_property(
            "listVersionAdded",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/listVersionAdded",
        )
        # A deprecatedVersion for a ListedLicense or ListedLicenseException on the SPDX
        # License List specifies which version release of the License List was the first
        # one in which it was marked as deprecated.
        self._add_property(
            "deprecatedVersion",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/deprecatedVersion",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/ListedLicense"] = expandedlicensing_ListedLicense


# An OrLaterOperator indicates that this portion of the AnyLicenseInfo
# represents either (1) the specified version of the corresponding License, or
# (2) any later version of that License. It is represented in the SPDX License
# Expression Syntax by the `+` operator.
#
# It is context-dependent, and unspecified by SPDX, as to what constitutes a
# "later version" of any particular License. Some Licenses may not be versioned,
# or may not have clearly-defined ordering for versions. The consumer of SPDX
# data will need to determine for themselves what meaning to attribute to a
# "later version" operator for a particular License.
class expandedlicensing_OrLaterOperator(expandedlicensing_ExtendableLicense):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/OrLaterOperator"

    def __init__(self, **kwargs):
        super().__init__()
        # A subjectLicense is a License which is subject to either an 'or later' effect
        # (OrLaterOperator) or a 'with additional text' effect (WithAdditionOperator).
        self._add_property(
            "subjectLicense",
            ObjectProp(expandedlicensing_License, True),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/subjectLicense",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/OrLaterOperator"] = expandedlicensing_OrLaterOperator


# A WithAdditionOperator indicates that the designated License is subject to the
# designated LicenseAddition, which might be a license exception on the SPDX
# Exceptions List (ListedLicenseException) or may be other additional text
# (CustomLicenseAddition). It is represented in the SPDX License Expression
# Syntax by the `WITH` operator.
class expandedlicensing_WithAdditionOperator(simplelicensing_AnyLicenseInfo):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/WithAdditionOperator"

    def __init__(self, **kwargs):
        super().__init__()
        # A subjectLicense is a License which is subject to either an 'or later' effect
        # (OrLaterOperator) or a 'with additional text' effect (WithAdditionOperator).
        self._add_property(
            "subjectLicense",
            ObjectProp(expandedlicensing_ExtendableLicense, True),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/subjectLicense",
            min_count=1,
        )
        # A subjectAddition is a LicenseAddition which is subject to a 'with additional
        # text' effect (WithAdditionOperator).
        self._add_property(
            "subjectAddition",
            ObjectProp(expandedlicensing_LicenseAddition, True),
            json_name="https://spdx.org/rdf/v3/ExpandedLicensing/subjectAddition",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/WithAdditionOperator"] = expandedlicensing_WithAdditionOperator


# A CvssV2VulnAssessmentRelationship relationship describes the determined score and vector of a vulnerability using version 2.0 of the Common Vulnerability Scoring System (CVSS) as defined at [https://www.first.org/cvss/v2/guide](https://www.first.org/cvss/v2/guide). It is intended to communicate the results of using a CVSS calculator.
#
# **Constraints**
#
# - The relationship type must be set to `hasAssessmentFor`.
#
# **Syntax**
#
# ```json
# {
#   "@type": "CvssV2VulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:cvssv2-cve-2020-28498",
#   "relationshipType": "hasAssessmentFor",
#   "score": 4.3,
#   "vectorString": "(AV:N/AC:M/Au:N/C:P/I:N/A:N)",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "externalRefs": [
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://nvd.nist.gov/vuln/detail/CVE-2020-28498"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityFix",
#       "locator": "https://github.com/indutny/elliptic/commit/441b742"
#     }
#   ],
#   "suppliedBy": ["urn:spdx.dev:agent-my-security-vendor"],
#   "publishedTime": "2023-05-06T10:06:13Z"
# },
# {
#   "@type": "Relationship",
#   "@id": "urn:spdx.dev:vulnAgentRel-1",
#   "relationshipType": "publishedBy",
#   "from": "urn:spdx.dev:cvssv2-cve-2020-28498",
#   "to": ["urn:spdx.dev:agent-snyk"],
#   "startTime": "2021-03-08T16:06:50Z"
# }
# ```
class security_CvssV2VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/CvssV2VulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # The score provides information on the severity of a vulnerability per the
        # Common Vulnerability Scoring System as defined on [https://www.first.org/cvss](https://www.first.org/cvss/).
        self._add_property(
            "score",
            FloatProp(),
            json_name="https://spdx.org/rdf/v3/Security/score",
            min_count=1,
        )
        # Specifies any combination of the CVSS Base, Temporal, Threat, Environmental, and/or Supplemental vector string values for a vulnerability. Supports vectorStrings specified in all CVSS versions.
        #
        # **Constraints**
        #
        # String values for the vectorString range must only include the abbreviated form of metric names specified in CVSS specifications, e.g. [https://www.first.org/cvss/v4.0/specification-document#Vector-String](https://www.first.org/cvss/v4.0/specification-document#Vector-String)
        self._add_property(
            "vectorString",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/CvssV2VulnAssessmentRelationship"] = security_CvssV2VulnAssessmentRelationship


# A CvssV3VulnAssessmentRelationship relationship describes the determined score,
# severity, and vector of a vulnerability using version [3.0](https://www.first.org/cvss/v3.0/specification-document) or [3.1](https://www.first.org/cvss/v3.1/specification-document) of the Common
# Vulnerability Scoring System (CVSS). It is intended to communicate the results of using a CVSS calculator.
#
# **Constraints**
#
# - The value of severity must be one of 'NONE', 'LOW', 'MEDIUM', 'HIGH' or 'CRITICAL'.
# - The relationship type must be set to `hasAssessmentFor`.
#
# **Syntax**
#
# ```json
# {
#   "@type": "CvssV3VulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:cvssv3-cve-2020-28498",
#   "relationshipType": "hasAssessmentFor",
#   "score": 6.8,
#   "severity": "MEDIUM",
#   "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:N/A:N",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "externalRefs": [
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://nvd.nist.gov/vuln/detail/CVE-2020-28498"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityFix",
#       "locator": "https://github.com/indutny/elliptic/commit/441b742"
#     }
#   ],
#   "suppliedBy": ["urn:spdx.dev:agent-my-security-vendor"],
#   "publishedTime": "2023-05-06T10:06:13Z"
# },
# {
#   "@type": "Relationship",
#   "@id": "urn:spdx.dev:vulnAgentRel-1",
#   "relationshipType": "publishedBy",
#   "from": "urn:spdx.dev:cvssv3-cve-2020-28498",
#   "to": "urn:spdx.dev:agent-snyk",
#   "startTime": "2021-03-08T16:06:50Z"
# }
# ```
class security_CvssV3VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/CvssV3VulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # The score provides information on the severity of a vulnerability per the
        # Common Vulnerability Scoring System as defined on [https://www.first.org/cvss](https://www.first.org/cvss/).
        self._add_property(
            "score",
            FloatProp(),
            json_name="https://spdx.org/rdf/v3/Security/score",
            min_count=1,
        )
        # The severity field provides a human readable string of the resulting numerical CVSS score.
        self._add_property(
            "severity",
            security_CvssSeverityType(),
            json_name="https://spdx.org/rdf/v3/Security/severity",
            min_count=1,
        )
        # Specifies any combination of the CVSS Base, Temporal, Threat, Environmental, and/or Supplemental vector string values for a vulnerability. Supports vectorStrings specified in all CVSS versions.
        #
        # **Constraints**
        #
        # String values for the vectorString range must only include the abbreviated form of metric names specified in CVSS specifications, e.g. [https://www.first.org/cvss/v4.0/specification-document#Vector-String](https://www.first.org/cvss/v4.0/specification-document#Vector-String)
        self._add_property(
            "vectorString",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/CvssV3VulnAssessmentRelationship"] = security_CvssV3VulnAssessmentRelationship


# A CvssV4VulnAssessmentRelationship relationship describes the determined score, severity, and vector of a vulnerability using version 4 of the Common Vulnerability Scoring System (CVSS) as defined on [https://www.first.org/cvss/v4.0/specification-document](https://www.first.org/cvss/v4.0/specification-document). It is intented to communicate the results of using a CVSS calculator.
#
# **Constraints**
#
# - The value of severity must be one of 'NONE', 'LOW', 'MEDIUM', 'HIGH' or 'CRITICAL'.
# - The relationship type must be set to hasAssessmentFor.
#
# **Syntax**
#
# ```json
# {
#   "@type": "CvssV4VulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:cvssv4-cve-2021-44228",
#   "relationshipType": "hasAssessmentFor",
#   "severity": "MEDIUM",
#   "score": 10.0,
#   "vectorString": "CVSS:4.0/AV:N/AC:L/AT:N/AR:N/UI:N/VCH/VI:H/VA:H/SC:H/SI:H/SA:H/E:A",
#   "from": "urn:spdx.dev:vuln-cve-2021-44228",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:apache-log4j-2.14.1",
#   "externalRefs": [
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://nvd.nist.gov/vuln/detail/CVE-2021-44228"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://logging.apache.org/log4j/2.x/security.html"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityOther",
#       "locator": "    https://www.first.org/cvss/v4.0/examples#Apache-log4j-JNDI-Command-Execution-log4shell-Vulnerability-CVE-2021-44228"
#     },
#   ],
#   "suppliedBy": ["urn:spdx.dev:agent-my-security-vendor"],
#   "publishedTime": "2023-10-05T23:09:13Z"
# },
# {
#   "@type": "Relationship",
#   "@id": "urn:spdx.dev:vulnAgentRel-1",
#   "relationshipType": "publishedBy",
#   "from": "urn:spdx.dev:cvssv4-cve-2021-44228",
#   "to": "urn:spdx.dev:agent-apache.org",
#   "startTime": "2021-12-11T18:39:00Z"
# }
# ```
class security_CvssV4VulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/CvssV4VulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # The score provides information on the severity of a vulnerability per the
        # Common Vulnerability Scoring System as defined on [https://www.first.org/cvss](https://www.first.org/cvss/).
        self._add_property(
            "score",
            FloatProp(),
            json_name="https://spdx.org/rdf/v3/Security/score",
            min_count=1,
        )
        # The severity field provides a human readable string of the resulting numerical CVSS score.
        self._add_property(
            "severity",
            security_CvssSeverityType(),
            json_name="https://spdx.org/rdf/v3/Security/severity",
            min_count=1,
        )
        # Specifies any combination of the CVSS Base, Temporal, Threat, Environmental, and/or Supplemental vector string values for a vulnerability. Supports vectorStrings specified in all CVSS versions.
        #
        # **Constraints**
        #
        # String values for the vectorString range must only include the abbreviated form of metric names specified in CVSS specifications, e.g. [https://www.first.org/cvss/v4.0/specification-document#Vector-String](https://www.first.org/cvss/v4.0/specification-document#Vector-String)
        self._add_property(
            "vectorString",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/vectorString",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/CvssV4VulnAssessmentRelationship"] = security_CvssV4VulnAssessmentRelationship


# An EpssVulnAssessmentRelationship relationship describes the likelihood or probability that a vulnerability will be exploited in the wild using the Exploit Prediction Scoring System (EPSS) as defined at [https://www.first.org/epss/model](https://www.first.org/epss/model).
#
# **Constraints**
#
# - The relationship type must be set to hasAssessmentFor.
# - The probability must be between 0 and 1.
# - The percentile must be between 0 and 1.
#
# **Syntax**
#
# ```json
# {
#   "@type": "EpssVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:epss-CVE-2020-28498",
#   "relationshipType": "hasAssessmentFor",
#   "probability": 0.00105,
#   "percentile": 0.42356,
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2023-10-05T00:00:30Z"
# }
# ```
class security_EpssVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/EpssVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # The probability score between 0 and 1 (0 and 100%) estimating the likelihood of exploitation in the wild in the next 30 days (following score publication). [https://www.first.org/epss/data_stats](https://www.first.org/epss/data_stats)
        self._add_property(
            "probability",
            FloatProp(),
            json_name="https://spdx.org/rdf/v3/Security/probability",
            min_count=1,
        )
        # The percentile between 0 and 1 (0 and 100%) of the current probability score, the proportion of all scored vulnerabilities with the same or a lower EPSS score. [https://www.first.org/epss/data_stats](https://www.first.org/epss/data_stats)
        self._add_property(
            "percentile",
            FloatProp(),
            json_name="https://spdx.org/rdf/v3/Security/percentile",
            min_count=1,
        )
        # Specifies the time when a vulnerability was first published.
        self._add_property(
            "publishedTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/publishedTime",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/EpssVulnAssessmentRelationship"] = security_EpssVulnAssessmentRelationship


# An ExploitCatalogVulnAssessmentRelationship describes if a vulnerability is
# listed in any exploit catalog such as the CISA Known Exploited Vulnerabilities
# Catalog (KEV)
# [https://www.cisa.gov/known-exploited-vulnerabilities-catalog](https://www.cisa.gov/known-exploited-vulnerabilities-catalog).
#
# **Constraints**
#
# - The relationship type must be set to hasAssessmentFor.
#
# **Syntax**
#
# ```json
# {
#   "@type": "ExploitCatalogVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:exploit-catalog-1",
#   "relationshipType": "hasAssessmentFor",
#   "catalogType": "kev",
#   "locator": "https://www.cisa.gov/known-exploited-vulnerabilities-catalog",
#   "exploited": "true",
#   "from": "urn:spdx.dev:vuln-cve-2023-2136",
#   "to": ["urn:product-google-chrome-112.0.5615.136"],
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_ExploitCatalogVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/ExploitCatalogVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # A catalogType is a mandatory value and must select one of the two entries in the `ExploitCatalogType.md` vocabulary.
        self._add_property(
            "catalogType",
            security_ExploitCatalogType(),
            json_name="https://spdx.org/rdf/v3/Security/catalogType",
            min_count=1,
        )
        # This field is set when a CVE is listed in an exploit catalog.
        self._add_property(
            "exploited",
            BooleanProp(),
            json_name="https://spdx.org/rdf/v3/Security/exploited",
            min_count=1,
        )
        # A locator provides the location of an exploit catalog.
        self._add_property(
            "locator",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Security/locator",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/ExploitCatalogVulnAssessmentRelationship"] = security_ExploitCatalogVulnAssessmentRelationship


# An SsvcVulnAssessmentRelationship describes the decision made using the
# Stakeholder-Specific Vulnerability Categorization (SSVC) decision tree as
# defined on [https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc](https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc).
# It is intended to communicate the results of using the CISA SSVC Calculator.
#
# **Constraints**
#
# - The relationship type must be set to hasAssessmentFor.
#
# **Syntax**
#
# ```json
# {
#   "@type": "SsvcVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:ssvc-1",
#   "relationshipType": "hasAssessmentFor",
#   "decisionType": "act",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_SsvcVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/SsvcVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # A decisionType is a mandatory value and must select one of the four entries in the `SsvcDecisionType.md` vocabulary.
        self._add_property(
            "decisionType",
            security_SsvcDecisionType(),
            json_name="https://spdx.org/rdf/v3/Security/decisionType",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/SsvcVulnAssessmentRelationship"] = security_SsvcVulnAssessmentRelationship


# VexVulnAssessmentRelationship is an abstract subclass that defined the common
# properties shared by all the SPDX-VEX status relationships.
#
# **Constraints**
#
# When linking elements using a VexVulnAssessmentRelationship, the following
# requirements must be observed:
#
# - The from: end must be a /Security/Vulnerability classed element
# - The to: end must point to elements representing the VEX _products_. To
# specify a different element where the vulnerability was detected, the VEX
# relationship can optionally specify _subcomponents_ using the assessedElement
# property.
#
# VEX inherits information from the document level down to its statements. When a
# statement is missing information it can be completed by reading the equivalent
# field from the containing document. For example, if a VEX relationship is
# missing data in its createdBy property, tools must consider the entity
# listed in the CreationInfo section of the document as the VEX author.
# In the same way, when a VEX relationship does not have a created property,
# the document's date must be considered as authoritative.
class security_VexVulnAssessmentRelationship(security_VulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VexVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # TODO
        self._add_property(
            "vexVersion",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/vexVersion",
        )
        # TODO
        self._add_property(
            "statusNotes",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/statusNotes",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VexVulnAssessmentRelationship"] = security_VexVulnAssessmentRelationship


# Specifies a vulnerability and its associated information.
#
# **Syntax**
#
# ```json
# {
#   "@type": "Vulnerability",
#   "@id": "urn:spdx.dev:vuln-1",
#   "summary": "Use of a Broken or Risky Cryptographic Algorithm",
#   "description": "The npm package `elliptic` before version 6.5.4 are vulnerable to Cryptographic Issues via the secp256k1 implementation in elliptic/ec/key.js. There is no check to confirm that the public key point passed into the derive function actually exists on the secp256k1 curve. This results in the potential for the private key used in this implementation to be revealed after a number of ECDH operations are performed.",
#   "modified": "2021-03-08T16:02:43Z",
#   "published": "2021-03-08T16:06:50Z",
#   "externalIdentifiers": [
#     {
#       "@type": "ExternalIdentifier",
#       "externalIdentifierType": "cve",
#       "identifier": "CVE-2020-2849",
#       "identifierLocator": [
#         "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28498",
#         "https://www.cve.org/CVERecord?id=CVE-2020-28498"
#       ],
#       "issuingAuthority": "urn:spdx.dev:agent-cve.org"
#     },
#     {
#       "type": "ExternalIdentifier",
#       "externalIdentifierType": "securityOther",
#       "identifier": "GHSA-r9p9-mrjm-926w",
#       "identifierLocator": "https://github.com/advisories/GHSA-r9p9-mrjm-926w"
#     },
#     {
#       "type": "ExternalIdentifier",
#       "externalIdentifierType": "securityOther",
#       "identifier": "SNYK-JS-ELLIPTIC-1064899",
#       "identifierLocator": "https://security.snyk.io/vuln/SNYK-JS-ELLIPTIC-1064899"
#     }
#   ],
#   "externalRefs": [
#     {
#         "@type": "ExternalRef",
#         "externalRefType": "securityAdvisory",
#         "locator": "https://nvd.nist.gov/vuln/detail/CVE-2020-28498"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityAdvisory",
#       "locator": "https://ubuntu.com/security/CVE-2020-28498"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityOther",
#       "locator": "https://github.com/indutny/elliptic/pull/244/commits"
#     },
#     {
#       "@type": "ExternalRef",
#       "externalRefType": "securityOther",
#       "locator": "https://github.com/christianlundkvist/blog/blob/master/2020_05_26_secp256k1_twist_attacks/secp256k1_twist_attacks.md"
#     }
#   ]
# },
# {
#   "@type": "Relationship",
#   "@id": "urn:spdx.dev:vulnRelationship-1",
#   "relationshipType": "hasAssociatedVulnerability",
#   "from": "urn:npm-elliptic-6.5.2",
#   "to": ["urn:spdx.dev:vuln-1"],
#   "startTime": "2021-03-08T16:06:50Z"
# },
# {
#   "@type": "Relationship",
#   "@id": "urn:spdx.dev:vulnAgentRel-1",
#   "relationshipType": "publishedBy",
#   "from": "urn:spdx.dev:vuln-1",
#   "to": ["urn:spdx.dev:agent-snyk"],
#   "startTime": "2021-03-08T16:06:50Z"
# }
# ```
class security_Vulnerability(core_Artifact):
    TYPE = "https://spdx.org/rdf/v3/Security/Vulnerability"

    def __init__(self, **kwargs):
        super().__init__()
        # Specifies the time when a vulnerability was first published.
        self._add_property(
            "publishedTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/publishedTime",
        )
        # Specifies a time when a vulnerability assessment was last modified.
        self._add_property(
            "modifiedTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/modifiedTime",
        )
        # Specified the time and date when a vulnerability was withdrawn.
        self._add_property(
            "withdrawnTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/withdrawnTime",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/Vulnerability"] = security_Vulnerability


# A software artifact is a distinct article or unit related to software
# such as a package, a file, or a snippet.
class software_SoftwareArtifact(core_Artifact):
    TYPE = "https://spdx.org/rdf/v3/Software/SoftwareArtifact"

    def __init__(self, **kwargs):
        super().__init__()
        # The contentIdentifier provides a canonical, unique, immutable artifact identifier for each software artifact. SPDX 3.0 describes software artifacts as Snippet, File, or Package Elements. The ContentIdentifier can be calculated for any software artifact and can be recorded for any of these SPDX 3.0 Elements using Omnibor, an attempt to standardize how software artifacts are identified independent of which programming language, version control system, build tool, package manager, or software distribution mechanism is in use.
        #
        # The contentIdentifier is defined as the [Git Object Identifier](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects) (gitoid) of type `blob` of the software artifact. The use of a git-based version control system is not necessary to calculate a contentIdentifier for any software artifact.
        #
        # The gitoid is expressed in the ContentIdentifier property by using the IANA [gitoid URI scheme](https://www.iana.org/assignments/uri-schemes/prov/gitoid).
        #
        # ```
        # Scheme syntax: gitoid":"<git object type>":"<hash algorithm>":"<hash value>
        # ```
        #
        # The OmniBOR ID for the OmniBOR Document associated with a software artifact should not be recorded in this field. Rather, OmniBOR IDs should be recorded in the SPDX Element's ExternalIdentifier property. See [https://omnibor.io](https://omnibor.io) for more details.
        self._add_property(
            "contentIdentifier",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Software/contentIdentifier",
        )
        # primaryPurpose provides information about the primary purpose of the software artifact.
        self._add_property(
            "primaryPurpose",
            software_SoftwarePurpose(),
            json_name="https://spdx.org/rdf/v3/Software/primaryPurpose",
        )
        # Additional purpose provides information about the additional purposes of the software artifact in addition to the primaryPurpose.
        self._add_property(
            "additionalPurpose",
            ListProp(software_SoftwarePurpose()),
            json_name="https://spdx.org/rdf/v3/Software/additionalPurpose",
        )
        # A copyrightText consists of the text(s) of the copyright notice(s) found
        # for a software Package, File or Snippet, if any.
        #
        # If a copyrightText contains text, then it may contain any text related to
        # one or more copyright notices (even if not complete) for that software
        # Package, File or Snippet.
        #
        # If a copyrightText has a "NONE" value, this indicates that the software
        # Package, File or Snippet contains no copyright notice whatsoever.
        #
        # If a copyrightText has a "NOASSERTION" value, this indicates that one of the
        # following applies:
        # * the SPDX data creator has attempted to but cannot reach a reasonable
        #   objective determination;
        # * the SPDX data creator has made no attempt to determine this field; or
        # * the SPDX data creator has intentionally provided no information (no
        #   meaning should be implied by doing so).
        self._add_property(
            "copyrightText",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Software/copyrightText",
        )
        # An attributionText for a software Package, File or Snippet provides a consumer
        # of SPDX data with acknowledgement content, to assist redistributors of the
        # Package, File or Snippet with reproducing those acknowledgements.
        #
        # For example, this field may include a statement that is required by a
        # particular license to be reproduced in end-user documentation, advertising
        # materials, or another form.
        #
        # This field may describe where, or in which contexts, the acknowledgements
        # need to be reproduced, but it is not required to do so. The SPDX data creator
        # may also explain elsewhere (such as in a licenseComment field) how they intend
        # for data in this field to be used.
        #
        # An attributionText is is not meant to include the software Package, File or
        # Snippet’s actual complete license text (see concludedLicense to identify the
        # corresponding license).
        self._add_property(
            "attributionText",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Software/attributionText",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Software/SoftwareArtifact"] = software_SoftwareArtifact


# A Bill Of Materials (BOM) is a container for a grouping of SPDX-3.0 content
# characterizing details about a product.
# This could include details of the content and composition of the product,
# provenence details of the product and/or
# its composition, licensing information, known quality or security issues, etc.
class core_Bom(core_Bundle):
    TYPE = "https://spdx.org/rdf/v3/Core/Bom"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Core/Bom"] = core_Bom


# A CustomLicense represents a License that is not listed on the SPDX License
# List at https://spdx.org/licenses, and is therefore defined by an SPDX data
# creator.
class expandedlicensing_CustomLicense(expandedlicensing_License):
    TYPE = "https://spdx.org/rdf/v3/ExpandedLicensing/CustomLicense"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/ExpandedLicensing/CustomLicense"] = expandedlicensing_CustomLicense


# VexAffectedVulnAssessmentRelationship connects a vulnerability and a number
# of elements. The relationship marks these elements as products affected by the
# vulnerability. This relationship corresponds to the VEX affected status.
#
# **Constraints**
#
# When linking elements using a VexAffectedVulnAssessmentRelationship, the
# following requirements must be observed:
#
# - Elements linked with a VulnVexAffectedAssessmentRelationship are constrained
# to the affects relationship type.
#
# **Syntax**
#
# ```json
# {
#   "@type": "VexAffectedVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:vex-affected-1",
#   "relationshipType": "affects",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "actionStatement": "Upgrade to version 1.4 of ACME application.",
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_VexAffectedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VexAffectedVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # When an element is referenced with a VexAffectedVulnAssessmentRelationship,
        # the relationship MUST include one actionStatement that SHOULD describe actions
        # to remediate or mitigate the vulnerability.
        self._add_property(
            "actionStatement",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/actionStatement",
        )
        # When a VEX statement communicates an affected status, the author MUST
        # include an action statement with a recommended action to help mitigate the
        # vulnerability's impact. The actionStatementTime property records the time
        # when the action statement was first communicated.
        self._add_property(
            "actionStatementTime",
            ListProp(DateTimeProp()),
            json_name="https://spdx.org/rdf/v3/Security/actionStatementTime",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VexAffectedVulnAssessmentRelationship"] = security_VexAffectedVulnAssessmentRelationship


# VexFixedVulnAssessmentRelationship links a vulnerability to a number of elements
# representing VEX products where a vulnerability has been fixed and are no longer
# affected. It represents the VEX fixed status.
#
# **Constraints**
#
# When linking elements using a VexFixedVulnAssessmentRelationship, the following
# requirements must be observed:
#
# - Elements linked with a VulnVexFixedAssessmentRelationship are constrained to
# using the fixedIn relationship type.
# - The from: end of the relationship must ve a /Security/Vulnerability classed
# element.
#
# **Syntax**
#
# ```json
# {
#   "@type": "VexFixedVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:vex-fixed-in-1",
#   "relationshipType": "fixedIn",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.4",
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_VexFixedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VexFixedVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VexFixedVulnAssessmentRelationship"] = security_VexFixedVulnAssessmentRelationship


# VexNotAffectedVulnAssessmentRelationship connects a vulnerability and a number
# of elements designating them as products not affected by the vulnerability.
# This relationship corresponds to the VEX not_affected status.
#
# **Constraints**
#
# When linking elements using a VexNotVulnAffectedAssessmentRelationship, the
# following requirements must be observed:
#
# * Relating elements with a VexNotAffectedVulnAssessmentRelationship is restricted
# to the doesNotAffect relationship type.
# * The from: end of the relationship must be a /Security/Vulnerability classed
# element.
# * Both impactStatement and justificationType properties have a cardinality of
# 0..1 making them optional. Nevertheless, to produce a valid VEX not_affected
# statement, one of them MUST be defined. This is specified in the Minimum Elements
# for VEX.
#
# **Syntax**
#
# ```json
# {
#   "@type": "VexNotAffectedVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:vex-not-affected-1",
#   "relationshipType": "doesNotAffect",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "justificationType": "componentNotPresent",
#   "impactStatement": "Not using this vulnerable part of this library.",
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_VexNotAffectedVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VexNotAffectedVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        # When stating that an element is not affected by a vulnerability, the
        # VexNotAffectedVulnAssessmentRelationship must include a justification from the
        # machine-readable labels catalog informing the reason the element is not impacted.
        #
        # impactStatement which is a string with English prose can be used instead or as
        # complementary to the justification label, but one of both MUST be defined.
        self._add_property(
            "justificationType",
            security_VexJustificationType(),
            json_name="https://spdx.org/rdf/v3/Security/justificationType",
        )
        # When a VEX product element is related with a VexNotAffectedVulnAssessmentRelationship
        # and a machine readable justification label is not provided, then an impactStatement
        # that further explains how or why the prouct(s) are not affected by the vulnerability
        # must be provided.
        self._add_property(
            "impactStatement",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Security/impactStatement",
        )
        # TODO
        self._add_property(
            "impactStatementTime",
            DateTimeProp(),
            json_name="https://spdx.org/rdf/v3/Security/impactStatementTime",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VexNotAffectedVulnAssessmentRelationship"] = security_VexNotAffectedVulnAssessmentRelationship


# VexUnderInvestigationVulnAssessmentRelationship links a vulnerability to a
# number of products stating the vulnerability's impact on them is being
# investigated. It represents the VEX under_investigation status.
#
# **Constraints**
#
# When linking elements using a VexUnderInvestigationVulnAssessmentRelationship
# the following requirements must be observed:
#
# - Elements linked with a VexUnderInvestigationVulnAssessmentRelationship are
# constrained to using the underInvestigationFor relationship type.
# - The from: end of the relationship must ve a /Security/Vulnerability classed
# element.
#
# **Syntax**
#
# ```json
# {
#   "@type": "VexUnderInvestigationVulnAssessmentRelationship",
#   "@id": "urn:spdx.dev:vex-underInvestigation-1",
#   "relationshipType": "underInvestigationFor",
#   "from": "urn:spdx.dev:vuln-cve-2020-28498",
#   "to": ["urn:product-acme-application-1.3"],
#   "assessedElement": "urn:npm-elliptic-6.5.2",
#   "suppliedBy": ["urn:spdx.dev:agent-jane-doe"],
#   "publishedTime": "2021-03-09T11:04:53Z"
# }
# ```
class security_VexUnderInvestigationVulnAssessmentRelationship(security_VexVulnAssessmentRelationship):
    TYPE = "https://spdx.org/rdf/v3/Security/VexUnderInvestigationVulnAssessmentRelationship"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Security/VexUnderInvestigationVulnAssessmentRelationship"] = security_VexUnderInvestigationVulnAssessmentRelationship


# Refers to any object that stores content on a computer.
# The type of content can optionally be provided in the contentType property.
# External property restriction on /Core/Element/name: minCount: 1
class software_File(software_SoftwareArtifact):
    TYPE = "https://spdx.org/rdf/v3/Software/File"

    def __init__(self, **kwargs):
        super().__init__()
        # This field is a reasonable estimation of the content type of the Element, from a creator perspective.
        # Content type is intrinsic to the Element, independent of how the Element is being used.
        self._add_property(
            "contentType",
            MediaTypeProp(),
            json_name="https://spdx.org/rdf/v3/Software/contentType",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Software/File"] = software_File


# A package refers to any unit of content that can be associated with a distribution of software.
# Typically, a package is composed of one or more files.
# Any of the following non-limiting examples may be (but are not required to be) represented in SPDX as a package:
#
#  - a tarball, zip file or other archive
#  - a directory or sub-directory
#  - a separately distributed piece of software which another Package or File uses or depends upon (e.g., a Python package, a Go module, ...)
#  - a container image, and/or each image layer within a container image
#  - a collection of one or more sub-packages
#  - a Git repository snapshot from a particular point in time
#
# Note that some of these could be represented in SPDX as a file as well.
# External property restriction on /Core/Element/name: minCount: 1
class software_Package(software_SoftwareArtifact):
    TYPE = "https://spdx.org/rdf/v3/Software/Package"

    def __init__(self, **kwargs):
        super().__init__()
        # A packageVersion is useful for identification purposes and for indicating later changes of the package version.
        self._add_property(
            "packageVersion",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Software/packageVersion",
        )
        # DownloadLocation identifies the download Uniform Resource Identifier
        # for the package at the time that the document was created.
        # Where and how to download the exact package being referenced
        # is critical for verification and tracking data.
        self._add_property(
            "downloadLocation",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Software/downloadLocation",
        )
        # A packageUrl (commonly pronounced and referred to as "purl") is an attempt to standardize package representations in order to reliably identify and locate software packages. A purl is a URL string which represents a package in a mostly universal and uniform way across programming languages, package managers, packaging conventions, tools, APIs and databases.
        #
        # the purl URL string is defined by seven components:
        # ```
        # scheme:type/namespace/name@version?qualifiers#subpath
        # ```
        #
        # The definition for each component can be found in the [purl specification](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst). Components are designed such that they form a hierarchy from the most significant on the left to the least significant components on the right.
        #
        # Parsing a purl string into its components works from left to right. Some extra type-specific normalizations are required. For more information, see [How to parse a purl string in its components](https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#how-to-parse-a-purl-string-in-its-components).
        self._add_property(
            "packageUrl",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Software/packageUrl",
        )
        # HomePage is a place for the SPDX document creator to record a website that serves as the package's home page.
        # This saves the recipient of the SPDX document who is looking for more info from
        # having to search for and verify a match between the package and the associated project home page.
        # This link can also be used to reference further information about the package
        # referenced by the SPDX document creator.
        self._add_property(
            "homePage",
            AnyURIProp(),
            json_name="https://spdx.org/rdf/v3/Software/homePage",
        )
        # SourceInfo records any relevant background information or additional comments
        # about the origin of the package. For example, this field might include comments
        # indicating whether the package was pulled from a source code management system
        # or has been repackaged. The creator can provide additional information to describe
        # any anomalies or discoveries in the determination of the origin of the package.
        self._add_property(
            "sourceInfo",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Software/sourceInfo",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Software/Package"] = software_Package


# A Software Bill of Materials (SBOM) is a collection of SPDX Elements describing a single package.
# This could include details of the content and composition of the product,
# provenance details of the product and/or
# its composition, licensing information, known quality or security issues, etc.
class software_Sbom(core_Bom):
    TYPE = "https://spdx.org/rdf/v3/Software/Sbom"

    def __init__(self, **kwargs):
        super().__init__()
        # This field is a reasonable estimation of the type of SBOM created from a creator perspective.
        # It is intended to be used to give guidance on the elements that may be contained within it.
        # Aligning with the guidance produced in [Types of Software Bill of Material (SBOM) Documents](https://www.cisa.gov/sites/default/files/2023-04/sbom-types-document-508c.pdf).
        self._add_property(
            "sbomType",
            ListProp(software_SbomType()),
            json_name="https://spdx.org/rdf/v3/Software/sbomType",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Software/Sbom"] = software_Sbom


# A Snippet describes a certain part of a file and can be used when the file is known to have some content
# that has been included from another original source. Snippets are useful for denoting when part of a file
# may have been originally created under another license or copied from a place with a known vulnerability.
class software_Snippet(software_SoftwareArtifact):
    TYPE = "https://spdx.org/rdf/v3/Software/Snippet"

    def __init__(self, **kwargs):
        super().__init__()
        # This field defines the byte range in the original host file that the snippet information applies to.
        # A range of bytes is independent of various formatting concerns, and the most accurate way
        # of referring to the differences. The choice was made to start the numbering of
        # the byte range at 1 to be consistent with the W3C pointer method vocabulary.
        self._add_property(
            "byteRange",
            ObjectProp(core_PositiveIntegerRange, False),
            json_name="https://spdx.org/rdf/v3/Software/byteRange",
        )
        # This field defines the line range in the original host file that the snippet information applies to.
        # If there is a disagreement between the byte range and line range, the byte range values will take precedence.
        # A range of lines is a convenient reference for those files where there is a known line delimiter.
        # The choice was made to start the numbering of the lines at 1 to be consistent with the W3C pointer method vocabulary.
        self._add_property(
            "lineRange",
            ObjectProp(core_PositiveIntegerRange, False),
            json_name="https://spdx.org/rdf/v3/Software/lineRange",
        )
        # The field identifies the file which contains the snippet.
        self._add_property(
            "snippetFromFile",
            ObjectProp(software_File, True),
            json_name="https://spdx.org/rdf/v3/Software/snippetFromFile",
            min_count=1,
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Software/Snippet"] = software_Snippet


# Metadata information that can be added to a package to describe an AI application or trained AI model.
# External property restriction on /Core/Artifact/suppliedBy: minCount: 1
# External property restriction on /Software/Package/downloadLocation: minCount: 1
# External property restriction on /Software/Package/packageVersion: minCount: 1
# External property restriction on /Software/SoftwareArtifact/primaryPurpose: minCount: 1
# External property restriction on /Core/Artifact/releaseTime: minCount: 1
class ai_AIPackage(software_Package):
    TYPE = "https://spdx.org/rdf/v3/AI/AIPackage"

    def __init__(self, **kwargs):
        super().__init__()
        # EnergyConsumption captures the amount of energy needed to train and operate the AI model.
        # This value is also known as training energy consumption or inference energy consumption.
        self._add_property(
            "energyConsumption",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/AI/energyConsumption",
        )
        # StandardCompliance captures a standard that the AI software complies with.
        # This includes both published and unpublished standards, for example ISO, IEEE, ETSI etc.
        # The standard could (but not necessarily have to) be used to satisfy a legal or regulatory requirement.
        self._add_property(
            "standardCompliance",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/AI/standardCompliance",
        )
        # Limitation captures a limitation of the AI Package (or of the AI models present in the AI package),
        # expressed as free form text. Note that this is not guaranteed to be exhaustive.
        # For instance, a limitation might be that the AI package cannot be used on datasets from a certain demography.
        self._add_property(
            "limitation",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/AI/limitation",
        )
        # TypeOfModel records the type of the AI model(s) used in the software.
        # For instance, if it is a supervised model, unsupervised model, reinforcement learning model or a combination of those.
        self._add_property(
            "typeOfModel",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/AI/typeOfModel",
        )
        # InformationAboutTraining describes the specific steps involved in the training of the AI model.
        # For example, it can be specified whether supervised fine-tuning
        # or active learning is used as part of training the model.
        self._add_property(
            "informationAboutTraining",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/AI/informationAboutTraining",
        )
        # InformationAboutApplication describes any relevant information in free form text about
        # how the AI model is used inside the software, as well as any relevant pre-processing steps, third party APIs etc.
        self._add_property(
            "informationAboutApplication",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/AI/informationAboutApplication",
        )
        # This field records a hyperparameter value.
        # Hyperparameters are parameters of the machine learning model that are used to control the learning process,
        # for example the optimization and learning rate used during the training of the model.
        self._add_property(
            "hyperparameter",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/AI/hyperparameter",
        )
        # ModelDataPreprocessing is a free form text that describes the preprocessing steps
        # applied to the training data before training of the model(s) contained in the AI software.
        self._add_property(
            "modelDataPreprocessing",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/AI/modelDataPreprocessing",
        )
        # ModelExplainability is a free form text that lists the different explainability mechanisms
        # (such as SHAP, or other model specific explainability mechanisms) that can be used to explain the model.
        self._add_property(
            "modelExplainability",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/AI/modelExplainability",
        )
        # SensitivePersonalInformation notes if sensitive personal information
        # is used in the training or inference of the AI models.
        # This might include biometric data, addresses or other data that can be used to infer a person's identity.
        self._add_property(
            "sensitivePersonalInformation",
            core_PresenceType(),
            json_name="https://spdx.org/rdf/v3/AI/sensitivePersonalInformation",
        )
        # Each metric might be computed based on a decision threshold.
        # For instance, precision or recall is typically computed by checking
        # if the probability of the outcome is larger than 0.5.
        # Each decision threshold should match with a metric field defined in the AI Package.
        self._add_property(
            "metricDecisionThreshold",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/AI/metricDecisionThreshold",
        )
        # Metric records the measurement with which the AI model was evaluated.
        # This makes statements about the prediction quality including uncertainty,
        # accuracy, characteristics of the tested population, quality, fairness, explainability, robustness etc.
        self._add_property(
            "metric",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/AI/metric",
        )
        # Domain describes the domain in which the AI model contained in the AI software
        # can be expected to operate successfully. Examples include computer vision, natural language etc.
        self._add_property(
            "domain",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/AI/domain",
        )
        # AutonomyType indicates if a human is involved in any of the decisions of the AI software
        # or if that software is fully automatic.
        self._add_property(
            "autonomyType",
            core_PresenceType(),
            json_name="https://spdx.org/rdf/v3/AI/autonomyType",
        )
        # SafetyRiskAssessment categorizes the safety risk impact of the AI software
        # in accordance with Article 20 of [EC Regulation No 765/2008](https://ec.europa.eu/docsroom/documents/17107/attachments/1/translations/en/renditions/pdf).
        self._add_property(
            "safetyRiskAssessment",
            ai_SafetyRiskAssessmentType(),
            json_name="https://spdx.org/rdf/v3/AI/safetyRiskAssessment",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/AI/AIPackage"] = ai_AIPackage


# Metadata information that can be added to a dataset that may be used in a software or to train/test an AI package.
# External property restriction on /Core/Artifact/originatedBy: minCount: 1
# External property restriction on /Software/Package/downloadLocation: minCount: 1
# External property restriction on /Software/SoftwareArtifact/primaryPurpose: minCount: 1
# External property restriction on /Core/Artifact/releaseTime: minCount: 1
# External property restriction on /Core/Artifact/builtTime: minCount: 1
class dataset_Dataset(software_Package):
    TYPE = "https://spdx.org/rdf/v3/Dataset/Dataset"

    def __init__(self, **kwargs):
        super().__init__()
        # Type describes the datatype contained in the dataset. For example a dataset can be an image dataset for computer vision applications, a text dataset such as the contents of a book or Wikipedia article, or sometimes a multimodal dataset that contains multiple types of data.
        self._add_property(
            "datasetType",
            ListProp(dataset_DatasetType()),
            json_name="https://spdx.org/rdf/v3/Dataset/datasetType",
            min_count=1,
        )
        # DataCollectionProcess describes how a dataset was collected.
        # Examples include the sources from which a dataset was scrapped or
        # the interview protocol that was used for data collection.
        self._add_property(
            "dataCollectionProcess",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Dataset/dataCollectionProcess",
        )
        # IntendedUse describes what the given dataset should be used for.
        # Some datasets are collected to be used only for particular purposes.
        # For example, medical data collected from a specific demography might only be applicable
        # for training machine learning models to make predictions for that demography.
        # In such a case, the intendedUse field would capture this information.
        # Similarly, if a dataset is collected for building a facial recognition model,
        # the intendedUse field would specify that.
        self._add_property(
            "intendedUse",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Dataset/intendedUse",
        )
        # DatasetSize Captures how large a dataset is.
        # The size is to be measured in bytes.
        self._add_property(
            "datasetSize",
            NonNegativeIntegerProp(),
            json_name="https://spdx.org/rdf/v3/Dataset/datasetSize",
        )
        # DatasetNoise describes what kinds of noises a dataset might encompass.
        # The field uses free form text to specify the fields or the samples that might be noisy.
        # Alternatively, it can also be used to describe various noises that could impact the whole dataset.
        self._add_property(
            "datasetNoise",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Dataset/datasetNoise",
        )
        # DataPreprocessing describes the various preprocessing steps
        # that were applied to the raw data to create the dataset.
        self._add_property(
            "dataPreprocessing",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Dataset/dataPreprocessing",
        )
        # Sensor describes a sensor that was used for collecting the data
        # and its calibration value as a key-value pair.
        self._add_property(
            "sensor",
            ListProp(ObjectProp(core_DictionaryEntry, False)),
            json_name="https://spdx.org/rdf/v3/Dataset/sensor",
        )
        # KnownBias is a free form text field that describes the different biases that the dataset encompasses.
        self._add_property(
            "knownBias",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Dataset/knownBias",
        )
        # SensitivePersonalInformation indicates the presence of sensitive personal data
        # or information that allows drawing conclusions about a person's identity.
        self._add_property(
            "sensitivePersonalInformation",
            core_PresenceType(),
            json_name="https://spdx.org/rdf/v3/Dataset/sensitivePersonalInformation",
        )
        # AnonymizationMethodUsed describes the methods used to anonymize the dataset (of fields in the dataset).
        self._add_property(
            "anonymizationMethodUsed",
            ListProp(StringProp()),
            json_name="https://spdx.org/rdf/v3/Dataset/anonymizationMethodUsed",
        )
        # ConfidentialityLevel describes the levels of confidentiality of the data points contained in the dataset.
        self._add_property(
            "confidentialityLevel",
            dataset_ConfidentialityLevelType(),
            json_name="https://spdx.org/rdf/v3/Dataset/confidentialityLevel",
        )
        # DatasetUpdateMechanism describes a mechanism to update the dataset.
        self._add_property(
            "datasetUpdateMechanism",
            StringProp(),
            json_name="https://spdx.org/rdf/v3/Dataset/datasetUpdateMechanism",
        )
        # Some datasets are publicly available and can be downloaded directly. Others are only accessible behind a clickthrough, or after filling a registration form. This field will describe the dataset availability from that perspective.
        self._add_property(
            "datasetAvailability",
            dataset_DatasetAvailabilityType(),
            json_name="https://spdx.org/rdf/v3/Dataset/datasetAvailability",
        )
        self._set_init_props(**kwargs)

SHACLObject.DESERIALIZERS["https://spdx.org/rdf/v3/Dataset/Dataset"] = dataset_Dataset


"""Format Guard"""
# fmt: on


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    with args.infile.open("r") as f:
        objects, _ = read_jsonld(f)

    if args.print:
        print_tree(objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            write_jsonld(objects, f)

    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
