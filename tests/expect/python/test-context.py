#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# This file was automatically generated by shacl2code. DO NOT MANUALLY MODIFY IT
#
# SPDX-License-Identifier: MIT

import functools
import hashlib
import json
import re
import time
from datetime import datetime, timezone


def check_type(obj, types):
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj)}"
            )
        raise TypeError(f"Value must be of type {types.__name__}. Got {type(obj)}")


class Property(object):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    TYPE = None

    def __init__(self, *, pattern=None):
        self.pattern = pattern

    def init(self):
        return None

    def validate(self, value):
        check_type(value, self.VALID_TYPES)
        if self.pattern is not None and not re.search(self.pattern, self.set(value)):
            raise ValueError(f"Value is not correctly formatted. Got '{value}'")

    def set(self, value):
        return value

    def get(self, value):
        return value

    def check_min_count(self, value, min_count):
        return min_count == 1

    def check_max_count(self, value, max_count):
        return max_count == 1

    def elide(self, value):
        return value is None

    def walk(self, value, callback, path):
        callback(value, path)

    def serializer(self, value, context):
        return value

    def deserialize(self, data, context, *, object_ids=None):
        if isinstance(data, dict) and "@value" in data:
            if self.TYPE:
                for t in ("@type", context.compact("@type")):
                    if t in data and data[t] != self.TYPE:
                        raise TypeError(
                            f"Value must be of type {self.TYPE}, but got {data[t]}"
                        )

            return data["@value"]

        return data

    def link_prop(self, value, link_cache, missing, visited):
        return value


class StringProp(Property):
    """
    A scalar string property for an SHACL object
    """

    TYPE = None
    VALID_TYPES = str

    def set(self, value):
        return str(value)


class AnyURIProp(StringProp):
    TYPE = "http://www.w3.org/2001/XMLSchema#anyURI"

    def validate(self, value):
        super().validate(value)


class DateTimeProp(Property):
    """
    A Date/Time Object
    """

    TYPE = "https://spdx.org/rdf/v3/Core/DateTime"
    VALID_TYPES = datetime
    FORMAT_STR = "%Y-%m-%dT%H:%M:%SZ"

    def set(self, value):
        return value.astimezone(timezone.utc).strftime(self.FORMAT_STR)

    def get(self, value):
        return datetime(
            *(time.strptime(value, self.FORMAT_STR)[0:6]),
            tzinfo=timezone.utc,
        )


class IntegerProp(Property):
    VALID_TYPES = int

    def set(self, value):
        return int(value)


class PositiveIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property):
    VALID_TYPES = bool

    def set(self, value):
        return bool(value)


class FloatProp(Property):
    VALID_TYPES = (float, int)

    def set(self, value):
        return float(value)


class ObjectProp(Property):
    """
    A scalar SHACL object property of a SHACL object
    """

    def __init__(self, cls, required):
        super().__init__()
        self.cls = cls
        self.required = required

    def init(self):
        if self.required:
            return self.cls()
        return None

    def validate(self, value):
        check_type(value, (self.cls, str))

    def walk(self, value, callback, path):
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def serializer(self, value, context):
        if value is None:
            return None

        if isinstance(value, str):
            return value

        return value.serializer(context)

    def deserialize(self, data, context, *, object_ids=None):
        if data is None:
            return data

        if isinstance(data, str):
            if data in object_ids:
                return object_ids[data]

            return data

        if isinstance(data, dict) and not any(
            t in data for t in ("@type", context.compact("@type"))
        ):
            for n in ("@id", context.compact("@id")):
                if n in data:
                    return data[n]

        return SHACLObject.deserialize(data, context, object_ids=object_ids)

    def link_prop(self, value, link_cache, missing, visited):
        if value is None:
            return value

        if isinstance(value, str):
            if value in link_cache:
                return link_cache[value]

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id and value._id is not link_cache[value._id]:
            value = link_cache[value._id]

        value.link_helper(link_cache, missing, visited)
        return value


class ListProxy(object):
    def __init__(self, prop, data=None):
        if data is None:
            self.__data = []
        else:
            self.__data = data
        self.__prop = prop

    def get_raw(self, key):
        return self.__data[key]

    def raw_items(self):
        return iter(self.__data)

    def append(self, value):
        self.__prop.validate(value)
        self.__data.append(self.__prop.set(value))

    def insert(self, idx, value):
        self.__prop.validate(value)
        self.__data.insert(idx, self.__prop.set(value))

    def extend(self, items):
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs):
        self.__data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self.__prop.get(self.get_raw(key))

    def __setitem__(self, key, value):
        if isinstance(key, slice):
            for v in value:
                self.__prop.validate(v)
            self.__data[key] = [self.__prop.set(v) for v in value]
        else:
            self.__prop.validate(value)
            self.__data[key] = self.__prop.set(value)

    def __delitem__(self, key):
        del self.__data[key]

    def __contains__(self, item):
        return item in [self.__prop.get(d) for d in self.__data]

    def __iter__(self):
        for v in self.__data:
            yield self.__prop.get(v)

    def __len__(self):
        return len(self.__data)

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)

    def __eq__(self, other):
        if isinstance(other, ListProxy):
            return self.__data == other.__data

        return [self.__prop.get(d) for d in self.__data] == other


class ListProp(Property):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    def __init__(self, prop):
        super().__init__()
        self.prop = prop

    def init(self):
        return ListProxy(self.prop)

    def validate(self, value):
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(self, value):
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, [self.prop.set(d) for d in value])

    def check_min_count(self, value, min_count):
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value, max_count):
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value):
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(self, value, callback, path):
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def deserialize(self, data, *args, **kwargs):
        if isinstance(data, (list, tuple, set)):
            data = [self.prop.deserialize(d, *args, **kwargs) for d in data]
        else:
            data = [self.prop.deserialize(data, *args, **kwargs)]

        return ListProxy(self.prop, data=data)

    def link_prop(self, value, link_cache, missing, visited):
        if isinstance(value, ListProxy):
            data = [
                self.prop.link_prop(v, link_cache, missing, visited)
                for v in value.raw_items()
            ]
        else:
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]

        return ListProxy(self.prop, data=data)

    def serializer(self, value, context):
        check_type(value, ListProxy)
        """"""
        """"""
        return [self.prop.serializer(v, context) for v in value.raw_items()]


class EnumProp(Property):
    VALID_TYPES = str

    def validate(self, value):
        super().validate(value)

        if value not in (v for _, v in self.valid_values):
            raise ValueError(
                f"'{value}' is not a valid value for '{self.__class__.__name__}'"
            )

    def deserialize(self, data, context, **kwargs):
        value = super().deserialize(data, context, **kwargs)
        return context.expand(value)

    def serializer(self, value, context):
        return context.compact(value)


@functools.total_ordering
class SHACLObject(object):
    DESERIALIZERS = {}

    def __init__(self):
        self._obj_data = {}
        self._obj_properties = {}
        self._obj_iris = {}
        self._obj_written = False
        self._obj_metadata = {}

        self._add_property("_id", StringProp(), iri="@id")

    def _set_init_props(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def _add_property(
        self,
        pyname,
        prop,
        iri,
        min_count=None,
        max_count=None,
    ):
        if pyname in self._obj_iris:
            raise KeyError(
                f"'{pyname}' is already defined for '{self.__class__.__name__}'"
            )
        if iri in self._obj_properties:
            raise KeyError(
                f"'{iri}' is already defined for '{self.__class__.__name__}'"
            )

        self._obj_iris[pyname] = iri
        self._obj_properties[iri] = (prop, min_count, max_count, pyname)
        self._obj_data[iri] = prop.init()

    def __setattr__(self, name, value):
        if name.startswith("_obj_"):
            return super().__setattr__(name, value)

        try:
            iri = self._obj_iris[name]
            self[iri] = value
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __getattr__(self, name):
        if name.startswith("_obj_"):
            return self.__dict__[name]

        if name == "_metadata":
            return self._obj_metadata

        if name == "_IRI":
            return self._obj_iris

        try:
            iri = self._obj_iris[name]
            return self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __delattr__(self, name):
        try:
            iri = self._obj_iris[name]
            del self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __get_prop(self, iri):
        if iri not in self._obj_properties:
            raise KeyError(
                f"'{iri}' is not a valid property of {self.__class__.__name__}"
            )

        return self._obj_properties[iri]

    def __iter_props(self):
        for iri, v in self._obj_properties.items():
            prop, min_count, max_count, pyname = v
            yield iri, prop, min_count, max_count, pyname

    def __getitem__(self, iri):
        prop, _, _, _ = self.__get_prop(iri)
        return prop.get(self._obj_data[iri])

    def __setitem__(self, iri, value):
        prop, _, _, _ = self.__get_prop(iri)
        prop.validate(value)
        self._obj_data[iri] = prop.set(value)

    def __delitem__(self, iri):
        prop, _, _, _ = self.__get_prop(iri)
        self._obj_data[iri] = prop.init()

    def walk(self, callback, path=None):
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(object, path):
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for iri, prop, _, _, _ in self.__iter_props():
                prop.walk(self._obj_data[iri], callback, path + [f".{iri}"])

    def child_objects(self):
        """
        Iterate over each object that is a child of this one
        """
        seen = set()

        def _walk_callback(value, path):
            nonlocal seen

            if not isinstance(value, SHACLObject):
                return False

            if value in seen:
                return False

            seen.add(value)
            return True

        self.walk(_walk_callback)

        for obj in seen:
            yield obj

    def serializer(self, context):
        if self._id and self._obj_written:
            return self._id

        self._obj_written = True

        d = {
            context.compact("@type"): context.compact(self.TYPE),
        }

        for iri, prop, min_count, max_count, pyname in self.__iter_props():
            value = self._obj_data[iri]
            if prop.elide(value):
                if min_count:
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) is required (currently {value!r})"
                    )
                continue

            if min_count is not None:
                if not prop.check_min_count(value, min_count):
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a minimum of {min_count} elements"
                    )

            if max_count is not None:
                if not prop.check_max_count(value, max_count):
                    raise ValueError(
                        f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a maximum of {max_count} elements"
                    )

            with context.vocab_push(iri):
                d[context.compact(iri)] = prop.serializer(value, context)
        return d

    def to_jsonld(self, f, *args, **kwargs):
        """
        Serialize this object to a JSON LD file
        """
        return write_jsonld([self], f, *args, **kwargs)

    @classmethod
    def deserialize(cls, data, context, *, object_ids=None):
        for t in ("@type", context.compact("@type")):
            if t not in data:
                continue

            typ = data[t]

            if typ in cls.DESERIALIZERS:
                break

            typ = context.expand(typ)
            if typ in cls.DESERIALIZERS:
                break

            raise Exception(f"Unknown type {data[t]}")
        else:
            raise Exception("Unable to determine type for object")

        obj = cls.DESERIALIZERS[typ]()

        _id = data.get("@id", None) or data.get(context.compact("@id"), None)
        if _id and _id in object_ids:
            return object_ids[_id]

        for iri, prop, _, _, _ in obj.__iter_props():
            for n in (iri, context.compact(iri)):
                if n in data:
                    with context.vocab_push(iri):
                        obj._obj_data[iri] = prop.deserialize(
                            data[n],
                            context,
                            object_ids=object_ids,
                        )
                    break

        if obj._id:
            object_ids[obj._id] = obj

        return obj

    def link_helper(self, link_cache, missing, visited):
        if self in visited:
            return

        visited.add(self)

        for iri, prop, _, _, _ in self.__iter_props():
            self._obj_data[iri] = prop.link_prop(
                self._obj_data[iri],
                link_cache,
                missing,
                visited,
            )

    def link(self, link_cache=None):
        if not link_cache:
            link_cache = {obj._id: obj for obj in self.child_objects() if obj._id}

        missing = set()
        visited = set()

        self.link_helper(link_cache, missing, visited)

        return missing

    def __str__(self):
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self):
        return super().__hash__()

    def __eq__(self, other):
        return super().__eq__(other)

    def __lt__(self, other):
        def sort_key(obj):
            if isinstance(obj, str):
                return (obj, "", "", "")
            return (
                obj._id or "",
                obj.TYPE,
                getattr(obj, "name", None) or "",
                id(obj),
            )

        return sort_key(self) < sort_key(other)


def make_context():
    global CONTEXTS
    return Context(CONTEXTS)


def write_jsonld(objects, f, force_graph=False, **kwargs):
    """
    Write a list of objects to a JSON LD file

    If force_graph is True, a @graph node will always be written
    """
    ref_counts = {}
    id_objects = set()
    context = make_context()

    def walk_callback(value, path):
        nonlocal ref_counts

        if not isinstance(value, SHACLObject):
            return True

        value._obj_written = False

        # Remove blank node ID for re-assignment
        if value._id and value._id.startswith("_:"):
            del value._id

        if value._id:
            id_objects.add(value)

        ref_counts.setdefault(value, 0)
        ref_counts[value] += 1
        if ref_counts[value] > 1:
            id_objects.add(value)
            return False

        return True

    for o in objects:
        o.walk(walk_callback)

    for idx, o in enumerate(id_objects):
        if not o._id:
            o._id = f"_:{o.__class__.__name__}{idx}"

    use_graph = force_graph or len(objects) > 1

    objects = set(objects)

    if use_graph:
        # If we are making a graph, put all ID objects in the root
        objects |= id_objects

    objects = list(objects)
    objects.sort()

    if use_graph:
        graph_data = []
        # Ensure top level objects are only written in the top level graph
        # node, and referenced by ID everywhere else. This is done by setting
        # the flag that indicates this object has been written for all the top
        # level objects, then clearing it right before serializing the object.
        #
        # In this way, if an object is referenced before it is supposed to be
        # serialized into the @graph, it will serialize as a string instead of
        # the actual object
        for o in objects:
            o._obj_written = True

        for o in objects:
            # Allow this specific object to be written now
            o._obj_written = False
            graph_data.append(o.serializer(context))

        data = {"@graph": graph_data}
    else:
        data = objects[0].serializer(context)

    if len(CONTEXT_URLS) == 1:
        data["@context"] = CONTEXT_URLS[0]
    elif CONTEXT_URLS:
        data["@context"] = CONTEXT_URLS

    sha1 = hashlib.sha1()
    for chunk in json.JSONEncoder(**kwargs).iterencode(data):
        chunk = chunk.encode("utf-8")
        f.write(chunk)
        sha1.update(chunk)

    return sha1.hexdigest()


def read_jsonld(f):
    """
    Read objects from a JSON LD file

    Returns the list of top level objects in the file, and a set of all
    object_ids that are present in the file

    The returned objects are fully linked
    """
    context = make_context()
    data = json.load(f)
    object_ids = {}
    if "@graph" not in data:
        objects = [SHACLObject.deserialize(data, context, object_ids=object_ids)]
    else:
        objects = [
            SHACLObject.deserialize(o, context, object_ids=object_ids)
            for o in data["@graph"]
        ]

    for o in objects:
        o.link(object_ids)

    # Remove blank node IDs
    for o in objects:
        for c in o.child_objects():
            if c._id and c._id.startswith("_:"):
                del c._id

    object_ids = {k: v for k, v in object_ids.items() if not k.startswith("_:")}

    return objects, object_ids


def print_tree(objects, all_fields=False):
    """
    Print object tree
    """
    seen = set()

    def callback(value, path):
        nonlocal seen

        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard"""

CONTEXTS = [
    {
        "@vocab": "http://example.org/",
    },
]

CONTEXT_URLS = [
    "https://spdx.github.io/spdx-3-model/context.json",
]


# ENUMERATIONS
# An enumerated type
class enumType(EnumProp):
    TYPE = "http://example.org/enumType"
    valid_values = [
        ("bar", "http://example.org/enumType/bar"),
        ("foo", "http://example.org/enumType/foo"),
        ("nolabel", "http://example.org/enumType/nolabel"),
    ]
    # The bar value of enumType
    bar = "http://example.org/enumType/bar"
    # The foo value of enumType
    foo = "http://example.org/enumType/foo"
    # This value has no label
    nolabel = "http://example.org/enumType/nolabel"


# CLASSES
# A class to test links
class linkclass(SHACLObject):
    TYPE = "http://example.org/link-class"

    def __init__(self, **kwargs):
        super().__init__()
        # A link-class property
        self._add_property(
            "linkclassprop",
            ObjectProp(linkclass, False),
            iri="http://example.org/link-class-prop",
        )
        # A link-class property with no sh:class
        self._add_property(
            "linkclasspropnoclass",
            ObjectProp(linkclass, False),
            iri="http://example.org/link-class-prop-no-class",
        )
        # A link-class list property
        self._add_property(
            "linkclasslistprop",
            ListProp(ObjectProp(linkclass, False)),
            iri="http://example.org/link-class-list-prop",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/link-class"] = linkclass


class linkderivedclass(linkclass):
    TYPE = "http://example.org/link-derived-class"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/link-derived-class"] = linkderivedclass


# The parent class
class parentclass(SHACLObject):
    TYPE = "http://example.org/parent-class"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/parent-class"] = parentclass


# Another class
class testanotherclass(SHACLObject):
    TYPE = "http://example.org/test-another-class"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-another-class"] = testanotherclass


# The test class
class testclass(parentclass):
    TYPE = "http://example.org/test-class"

    def __init__(self, **kwargs):
        super().__init__()
        # A string list property
        self._add_property(
            "testclassstringlistprop",
            ListProp(StringProp()),
            iri="http://example.org/test-class/string-list-prop",
        )
        # A string list property with no sh:datatype
        self._add_property(
            "testclassstringlistnodatatype",
            ListProp(StringProp()),
            iri="http://example.org/test-class/string-list-no-datatype",
        )
        # A scalar string propery
        self._add_property(
            "testclassstringscalarprop",
            StringProp(),
            iri="http://example.org/test-class/string-scalar-prop",
        )
        # A named property
        self._add_property(
            "named_property",
            StringProp(),
            iri="http://example.org/test-class/named-property",
        )
        # A scalar datetime property
        self._add_property(
            "testclassdatetimescalarprop",
            DateTimeProp(),
            iri="http://example.org/test-class/datetime-scalar-prop",
        )
        # A datetime list property
        self._add_property(
            "testclassdatetimelistprop",
            ListProp(DateTimeProp()),
            iri="http://example.org/test-class/datetime-list-prop",
        )
        # A positive integer
        self._add_property(
            "testclasspositiveintegerprop",
            PositiveIntegerProp(),
            iri="http://example.org/test-class/positive-integer-prop",
        )
        # a non-negative integer
        self._add_property(
            "testclassnonnegativeintegerprop",
            NonNegativeIntegerProp(),
            iri="http://example.org/test-class/nonnegative-integer-prop",
        )
        self._add_property(
            "testclassintegerprop",
            IntegerProp(),
            iri="http://example.org/test-class/integer-prop",
        )
        # a URI
        self._add_property(
            "testclassanyuriprop",
            AnyURIProp(),
            iri="http://example.org/test-class/anyuri-prop",
        )
        # a boolean property
        self._add_property(
            "testclassbooleanprop",
            BooleanProp(),
            iri="http://example.org/test-class/boolean-prop",
        )
        # a float property
        self._add_property(
            "testclassfloatprop",
            FloatProp(),
            iri="http://example.org/test-class/float-prop",
        )
        # A test-class property
        self._add_property(
            "testclassclassprop",
            ObjectProp(testclass, False),
            iri="http://example.org/test-class/class-prop",
        )
        # A test-class property with no sh:class
        self._add_property(
            "testclassclasspropnoclass",
            ObjectProp(testclass, False),
            iri="http://example.org/test-class/class-prop-no-class",
        )
        # A test-class list property
        self._add_property(
            "testclassclasslistprop",
            ListProp(ObjectProp(testclass, False)),
            iri="http://example.org/test-class/class-list-prop",
        )
        # A enum property
        self._add_property(
            "testclassenumprop",
            enumType(),
            iri="http://example.org/test-class/enum-prop",
        )
        # A enum list property
        self._add_property(
            "testclassenumlistprop",
            ListProp(enumType()),
            iri="http://example.org/test-class/enum-list-prop",
        )
        # A enum property with no sh:class
        self._add_property(
            "testclassenumpropnoclass",
            enumType(),
            iri="http://example.org/test-class/enum-prop-no-class",
        )
        # A regex validated string
        self._add_property(
            "testclassregex",
            StringProp(pattern=r"^foo\d",),
            iri="http://example.org/test-class/regex",
        )
        # A regex validated string list
        self._add_property(
            "testclassregexlist",
            ListProp(StringProp(pattern=r"^foo\d",)),
            iri="http://example.org/test-class/regex-list",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-class"] = testclass


class testclassrequired(testclass):
    TYPE = "http://example.org/test-class-required"

    def __init__(self, **kwargs):
        super().__init__()
        # A required scalar string property
        self._add_property(
            "testclassrequiredstringscalarprop",
            StringProp(),
            iri="http://example.org/test-class/required-string-scalar-prop",
            min_count=1,
        )
        # A required string list property
        self._add_property(
            "testclassrequiredstringlistprop",
            ListProp(StringProp()),
            iri="http://example.org/test-class/required-string-list-prop",
            max_count=2,
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-class-required"] = testclassrequired


class testderivedclass(testclass):
    TYPE = "http://example.org/test-derived-class"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-derived-class"] = testderivedclass


# Copyright (c) 2024 Joshua Watt
#
# SPDX-License-Identifier: MIT


class Context(object):
    from contextlib import contextmanager

    def __init__(self, contexts=[]):
        self.contexts = [c for c in contexts if c]
        self.__vocabs = []
        self.__expanded = {}
        self.__compacted = {}

    @contextmanager
    def vocab_push(self, vocab):
        if not vocab:
            yield self
            return

        self.__vocabs.append(vocab)
        try:
            yield self
        finally:
            self.__vocabs.pop()

    def __get_vocab_contexts(self):
        contexts = []

        for v in self.__vocabs:
            for ctx in self.contexts:
                # Check for vocabulary contexts
                for name, value in ctx.items():
                    if (
                        isinstance(value, dict)
                        and value["@type"] == "@vocab"
                        and v == self.__expand(value["@id"], self.contexts)
                    ):
                        contexts.insert(0, value["@context"])

        return contexts

    def compact(self, _id, vocab=None):
        with self.vocab_push(vocab):
            if not self.__vocabs:
                v = ""
            else:
                v = self.__vocabs[-1]

            if v not in self.__compacted or _id not in self.__compacted[v]:
                self.__compacted.setdefault(v, {})[_id] = self.__compact(
                    _id,
                    self.__get_vocab_contexts() + self.contexts,
                )
            return self.__compacted[v][_id]

    def __compact(self, _id, contexts):
        def collect_possible(_id):
            possible = set()
            for ctx in contexts:
                for name, value in ctx.items():
                    if name == "@vocab":
                        if _id.startswith(value):
                            tmp_id = _id[len(value) :]
                            possible.add(tmp_id)
                            possible |= collect_possible(tmp_id)
                    else:
                        if isinstance(value, dict):
                            value = value["@id"]

                        if _id == value:
                            possible.add(name)
                            possible |= collect_possible(name)
                        elif _id.startswith(value):
                            tmp_id = name + ":" + _id[len(value) :].lstrip("/")
                            possible.add(tmp_id)
                            possible |= collect_possible(tmp_id)

            return possible

        possible = collect_possible(_id)
        if not possible:
            return _id

        # To select from the possible identifiers, choose the one that has the
        # least context (fewest ":"), then the shortest, and finally
        # alphabetically
        possible = list(possible)
        possible.sort(key=lambda p: (p.count(":"), len(p), p))

        return possible[0]

    def expand(self, _id, vocab=""):
        with self.vocab_push(vocab):
            if not self.__vocabs:
                v = ""
            else:
                v = self.__vocabs[-1]

            if v not in self.__expanded or _id not in self.__expanded[v]:
                contexts = self.__get_vocab_contexts() + self.contexts

                # Apply contexts
                for ctx in contexts:
                    for name, value in ctx.items():
                        if name == "@vocab":
                            _id = value + _id

                self.__expanded.setdefault(v, {})[_id] = self.__expand(_id, contexts)

            return self.__expanded[v][_id]

    def __expand(self, _id, contexts):
        for ctx in contexts:
            if ":" not in _id:
                if _id in ctx:
                    if isinstance(ctx[_id], dict):
                        return self.__expand(ctx[_id]["@id"], contexts)
                    return self.__expand(ctx[_id], contexts)
                continue

            prefix, suffix = _id.split(":", 1)
            if prefix not in ctx:
                continue

            return self.__expand(prefix, contexts) + suffix

        return _id


"""Format Guard"""
# fmt: on


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    with args.infile.open("r") as f:
        objects, _ = read_jsonld(f)

    if args.print:
        print_tree(objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            write_jsonld(objects, f)

    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
