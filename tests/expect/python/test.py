#! /usr/bin/env python3
#
# Generated Python bindings from a SHACL model
#
# This file was automatically generated by shacl2code. DO NOT MANUALLY MODIFY IT
#
# SPDX-License-Identifier: MIT

import functools
import hashlib
import json
import re
import time
from contextlib import contextmanager
from datetime import datetime, timezone, timedelta
from enum import Enum
from abc import ABC, abstractmethod


def check_type(obj, types):
    if not isinstance(obj, types):
        if isinstance(types, (list, tuple)):
            raise TypeError(
                f"Value must be one of type: {', '.join(t.__name__ for t in types)}. Got {type(obj)}"
            )
        raise TypeError(f"Value must be of type {types.__name__}. Got {type(obj)}")


class Property(ABC):
    """
    A generic SHACL object property. The different types will derive from this
    class
    """

    def __init__(self, *, pattern=None):
        self.pattern = pattern

    def init(self):
        return None

    def validate(self, value):
        check_type(value, self.VALID_TYPES)
        if self.pattern is not None and not re.search(
            self.pattern, self.to_string(value)
        ):
            raise ValueError(
                f"Value is not correctly formatted. Got '{self.to_string(value)}'"
            )

    def set(self, value):
        return value

    def check_min_count(self, value, min_count):
        return min_count == 1

    def check_max_count(self, value, max_count):
        return max_count == 1

    def elide(self, value):
        return value is None

    def walk(self, value, callback, path):
        callback(value, path)

    def link_prop(self, value, link_cache, missing, visited):
        return value

    def to_string(self, value):
        return str(value)

    @abstractmethod
    def encode(self, encoder, value, state):
        pass

    @abstractmethod
    def decode(self, decoder, *, object_ids=None):
        pass


class StringProp(Property):
    """
    A scalar string property for an SHACL object
    """

    VALID_TYPES = str

    def set(self, value):
        return str(value)

    def encode(self, encoder, value, state):
        encoder.write_string(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_string()


class AnyURIProp(StringProp):
    def encode(self, encoder, value, state):
        encoder.write_iri(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_iri()


class DateTimeProp(Property):
    """
    A Date/Time Object with optional timezone
    """

    VALID_TYPES = datetime
    UTC_FORMAT_STR = "%Y-%m-%dT%H:%M:%SZ"
    REGEX = r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})?$"

    def set(self, value):
        return self._normalize(value)

    def encode(self, encoder, value, state):
        encoder.write_datetime(self.to_string(value))

    def decode(self, decoder, *, object_ids=None):
        s = decoder.read_datetime()
        if s is None:
            return None
        v = self.from_string(s)
        return self._normalize(v)

    def _normalize(self, value):
        if value.utcoffset() is None:
            value = value.astimezone()
        offset = value.utcoffset()
        if offset % timedelta(minutes=1):
            offset = offset - (offset % timedelta(minutes=1))
            value = value.replace(tzinfo=timezone(offset))
        value = value.replace(microsecond=0)
        return value

    def to_string(self, value):
        value = self._normalize(value)
        if value.tzinfo == timezone.utc:
            return value.strftime(self.UTC_FORMAT_STR)
        return value.isoformat()

    def from_string(self, value):
        if not re.match(self.REGEX, value):
            raise ValueError(f"'{value}' is not a correctly formatted datetime")
        if "Z" in value:
            d = datetime(
                *(time.strptime(value, self.UTC_FORMAT_STR)[0:6]),
                tzinfo=timezone.utc,
            )
        else:
            d = datetime.fromisoformat(value)

        return self._normalize(d)


class DateTimeStampProp(DateTimeProp):
    """
    A Date/Time Object with required timestamp
    """

    REGEX = r"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})$"


class IntegerProp(Property):
    VALID_TYPES = int

    def set(self, value):
        return int(value)

    def encode(self, encoder, value, state):
        encoder.write_integer(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_integer()


class PositiveIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 1:
            raise ValueError(f"Value must be >=1. Got {value}")


class NonNegativeIntegerProp(IntegerProp):
    def validate(self, value):
        super().validate(value)
        if value < 0:
            raise ValueError(f"Value must be >= 0. Got {value}")


class BooleanProp(Property):
    VALID_TYPES = bool

    def set(self, value):
        return bool(value)

    def encode(self, encoder, value, state):
        encoder.write_bool(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_bool()


class FloatProp(Property):
    VALID_TYPES = (float, int)

    def set(self, value):
        return float(value)

    def encode(self, encoder, value, state):
        encoder.write_float(value)

    def decode(self, decoder, *, object_ids=None):
        return decoder.read_float()


class ObjectProp(Property):
    """
    A scalar SHACL object property of a SHACL object
    """

    def __init__(self, cls, required):
        super().__init__()
        self.cls = cls
        self.required = required

    def init(self):
        if self.required:
            return self.cls()
        return None

    def validate(self, value):
        check_type(value, (self.cls, str))

    def walk(self, value, callback, path):
        if value is None:
            return

        if not isinstance(value, str):
            value.walk(callback, path)
        else:
            callback(value, path)

    def encode(self, encoder, value, state):
        if value is None:
            raise ValueError("Object cannot be None")

        if isinstance(value, str):
            encoder.write_iri(value)
            return

        return value.encode(encoder, state)

    def decode(self, decoder, *, object_ids=None):
        iri = decoder.read_iri()
        if iri is not None:
            if object_ids and iri in object_ids:
                return object_ids[iri]
            return iri

        return SHACLObject.decode(decoder, object_ids=object_ids)

    def link_prop(self, value, link_cache, missing, visited):
        if value is None:
            return value

        if isinstance(value, str):
            if value in link_cache:
                return link_cache[value]

            if missing is not None:
                missing.add(value)

            return value

        # De-duplicate IDs
        if value._id and value._id is not link_cache[value._id]:
            value = link_cache[value._id]

        value.link_helper(link_cache, missing, visited)
        return value


class ListProxy(object):
    def __init__(self, prop, data=None):
        if data is None:
            self.__data = []
        else:
            self.__data = data
        self.__prop = prop

    def append(self, value):
        self.__prop.validate(value)
        self.__data.append(self.__prop.set(value))

    def insert(self, idx, value):
        self.__prop.validate(value)
        self.__data.insert(idx, self.__prop.set(value))

    def extend(self, items):
        for i in items:
            self.append(i)

    def sort(self, *args, **kwargs):
        self.__data.sort(*args, **kwargs)

    def __getitem__(self, key):
        return self.__data[key]

    def __setitem__(self, key, value):
        if isinstance(key, slice):
            for v in value:
                self.__prop.validate(v)
            self.__data[key] = [self.__prop.set(v) for v in value]
        else:
            self.__prop.validate(value)
            self.__data[key] = self.__prop.set(value)

    def __delitem__(self, key):
        del self.__data[key]

    def __contains__(self, item):
        return item in self.__data

    def __iter__(self):
        return iter(self.__data)

    def __len__(self):
        return len(self.__data)

    def __str__(self):
        return str(self.__data)

    def __repr__(self):
        return repr(self.__data)

    def __eq__(self, other):
        if isinstance(other, ListProxy):
            return self.__data == other.__data

        return self.__data == other


class ListProp(Property):
    """
    A list of SHACL properties
    """

    VALID_TYPES = (list, ListProxy)

    def __init__(self, prop):
        super().__init__()
        self.prop = prop

    def init(self):
        return ListProxy(self.prop)

    def validate(self, value):
        super().validate(value)

        for i in value:
            self.prop.validate(i)

    def set(self, value):
        if isinstance(value, ListProxy):
            return value

        return ListProxy(self.prop, [self.prop.set(d) for d in value])

    def check_min_count(self, value, min_count):
        check_type(value, ListProxy)
        return len(value) >= min_count

    def check_max_count(self, value, max_count):
        check_type(value, ListProxy)
        return len(value) <= max_count

    def elide(self, value):
        check_type(value, ListProxy)
        return len(value) == 0

    def walk(self, value, callback, path):
        callback(value, path)
        for idx, v in enumerate(value):
            self.prop.walk(v, callback, path + [f"[{idx}]"])

    def link_prop(self, value, link_cache, missing, visited):
        if isinstance(value, ListProxy):
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]
        else:
            data = [self.prop.link_prop(v, link_cache, missing, visited) for v in value]

        return ListProxy(self.prop, data=data)

    def encode(self, encoder, value, state):
        check_type(value, ListProxy)

        with encoder.write_list() as list_s:
            for v in value:
                with list_s.write_list_item() as item_s:
                    self.prop.encode(item_s, v, state)

    def decode(self, decoder, *, object_ids=None):
        data = []
        for val_d in decoder.read_list():
            v = self.prop.decode(val_d, object_ids=object_ids)
            self.prop.validate(v)
            data.append(v)

        return ListProxy(self.prop, data=data)


class EnumProp(Property):
    VALID_TYPES = str

    def __init__(self, *, pattern=None, context=[]):
        super().__init__(pattern=pattern)
        self.context = context

    def validate(self, value):
        super().validate(value)

        if value not in (v for _, v in self.valid_values):
            raise ValueError(
                f"'{value}' is not a valid value for '{self.__class__.__name__}'"
            )

    def encode(self, encoder, value, state):
        for iri, compact in self.context:
            if iri == value:
                encoder.write_enum(value, self, compact)
                return

        encoder.write_enum(value, self)

    def decode(self, decoder, *, object_ids=None):
        v = decoder.read_enum(self)
        for iri, compact in self.context:
            if v == compact:
                return iri
        return v


class NodeKind(Enum):
    BlankNode = 1
    IRI = 2
    BlankNodeOrIRI = 3


@functools.total_ordering
class SHACLObject(object):
    DESERIALIZERS = {}
    NODE_KIND = NodeKind.BlankNodeOrIRI
    ID_ALIAS = None
    COMPACT_TYPE = None

    def __init__(self):
        self._obj_data = {}
        self._obj_properties = {}
        self._obj_iris = {}
        self._obj_metadata = {}

        self._add_property("_id", StringProp(), iri="@id")

    def _set_init_props(self, **kwargs):
        for k, v in kwargs.items():
            setattr(self, k, v)

    def _add_property(
        self,
        pyname,
        prop,
        iri,
        min_count=None,
        max_count=None,
        compact=None,
    ):
        if pyname in self._obj_iris:
            raise KeyError(
                f"'{pyname}' is already defined for '{self.__class__.__name__}'"
            )
        if iri in self._obj_properties:
            raise KeyError(
                f"'{iri}' is already defined for '{self.__class__.__name__}'"
            )

        while hasattr(self, pyname):
            pyname = pyname + "_"

        self._obj_iris[pyname] = iri
        self._obj_properties[iri] = (prop, min_count, max_count, pyname, compact)
        self._obj_data[iri] = prop.init()

    def __setattr__(self, name, value):
        if name.startswith("_obj_"):
            return super().__setattr__(name, value)

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            self[iri] = value
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __getattr__(self, name):
        if name.startswith("_obj_"):
            return self.__dict__[name]

        if name == "_metadata":
            return self._obj_metadata

        if name == "_IRI":
            return self._obj_iris

        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            return self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __delattr__(self, name):
        if name == self.ID_ALIAS:
            name = "_id"

        try:
            iri = self._obj_iris[name]
            del self[iri]
        except KeyError:
            raise AttributeError(
                f"'{name}' is not a valid property of {self.__class__.__name__}"
            )

    def __get_prop(self, iri):
        if iri not in self._obj_properties:
            raise KeyError(
                f"'{iri}' is not a valid property of {self.__class__.__name__}"
            )

        return self._obj_properties[iri]

    def __iter_props(self):
        for iri, v in self._obj_properties.items():
            yield iri, *v

    def __getitem__(self, iri):
        return self._obj_data[iri]

    def __setitem__(self, iri, value):
        if iri == "@id":
            if self.NODE_KIND == NodeKind.BlankNode:
                if not value.startswith("_:"):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can only have local reference. Property '{iri}' cannot be set to '{value}' and must start with '_:'"
                    )
            elif self.NODE_KIND == NodeKind.IRI:
                if value.startswith("_:"):
                    raise ValueError(
                        f"{self.__class__.__name__} ({id(self)}) can only have an IRI value. Property '{iri}' cannot be set to '{value}'"
                    )

        prop, _, _, _, _ = self.__get_prop(iri)
        prop.validate(value)
        self._obj_data[iri] = prop.set(value)

    def __delitem__(self, iri):
        prop, _, _, _, _ = self.__get_prop(iri)
        self._obj_data[iri] = prop.init()

    def __iter__(self):
        return self._obj_properties.keys()

    def walk(self, callback, path=None):
        """
        Walk object tree, invoking the callback for each item

        Callback has the form:

        def callback(object, path):
        """
        if path is None:
            path = ["."]

        if callback(self, path):
            for iri, prop, _, _, _, _ in self.__iter_props():
                prop.walk(self._obj_data[iri], callback, path + [f".{iri}"])

    def child_objects(self):
        """
        Iterate over each object that is a child of this one
        """
        seen = set()

        def _walk_callback(value, path):
            nonlocal seen

            if not isinstance(value, SHACLObject):
                return False

            if value in seen:
                return False

            seen.add(value)
            return True

        self.walk(_walk_callback)

        for obj in seen:
            yield obj

    def encode(self, encoder, state):
        idname = self.ID_ALIAS or self._obj_iris["_id"]
        if not self._id and self.NODE_KIND == NodeKind.IRI:
            raise ValueError(
                f"{self.__class__.__name__} ({id(self)}) must have a IRI for property '{idname}'"
            )

        if state.is_written(self):
            encoder.write_iri(state.get_object_id(self))
            return

        state.add_written(self)

        with encoder.write_object(
            self,
            state.get_object_id(self),
            bool(self._id) or state.is_refed(self),
        ) as obj_s:
            for iri, prop, min_count, max_count, pyname, compact in self.__iter_props():
                value = self._obj_data[iri]
                if prop.elide(value):
                    if min_count:
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) is required (currently {value!r})"
                        )
                    continue

                if min_count is not None:
                    if not prop.check_min_count(value, min_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a minimum of {min_count} elements"
                        )

                if max_count is not None:
                    if not prop.check_max_count(value, max_count):
                        raise ValueError(
                            f"Property '{pyname}' in {self.__class__.__name__} ({id(self)}) requires a maximum of {max_count} elements"
                        )

                if iri == self._obj_iris["_id"]:
                    continue

                with obj_s.write_property(iri, compact) as prop_s:
                    prop.encode(prop_s, value, state)

    @classmethod
    def decode(cls, decoder, *, object_ids=None):
        typ, obj_d = decoder.read_object()
        if typ is None:
            raise TypeError("Unable to determine type for object")

        if typ not in cls.DESERIALIZERS:
            raise TypeError(f"Unknown type {typ}")

        obj = cls.DESERIALIZERS[typ]()
        _id = obj_d.read_object_id(obj.ID_ALIAS)
        if _id is not None:
            if object_ids is not None:
                if _id in object_ids:
                    return object_ids[_id]
                object_ids[_id] = obj
            obj._id = _id

        for iri, prop, _, _, _, compact in obj.__iter_props():
            if iri == obj._obj_iris["_id"]:
                continue

            with obj_d.read_property(iri, compact) as prop_d:
                if prop_d is None:
                    continue

                v = prop.decode(prop_d, object_ids=object_ids)
                prop.validate(v)
                obj._obj_data[iri] = v

        return obj

    def link_helper(self, link_cache, missing, visited):
        if self in visited:
            return

        visited.add(self)

        for iri, prop, _, _, _, _ in self.__iter_props():
            self._obj_data[iri] = prop.link_prop(
                self._obj_data[iri],
                link_cache,
                missing,
                visited,
            )

    def link(self, link_cache=None):
        if not link_cache:
            link_cache = {obj._id: obj for obj in self.child_objects() if obj._id}

        missing = set()
        visited = set()

        self.link_helper(link_cache, missing, visited)

        return missing

    def __str__(self):
        parts = [
            f"{self.__class__.__name__}(",
        ]
        if self._id:
            parts.append(f"@id='{self._id}'")
        parts.append(")")
        return "".join(parts)

    def __hash__(self):
        return super().__hash__()

    def __eq__(self, other):
        return super().__eq__(other)

    def __lt__(self, other):
        def sort_key(obj):
            if isinstance(obj, str):
                return (obj, "", "", "")
            return (
                obj._id or "",
                obj.TYPE,
                getattr(obj, "name", None) or "",
                id(obj),
            )

        return sort_key(self) < sort_key(other)


class EncodeState(object):
    def __init__(self):
        self.ref_objects = set()
        self.written_objects = set()
        self.blank_objects = {}

    def get_object_id(self, o):
        if o._id:
            return o._id

        if o not in self.blank_objects:
            _id = f"_:{o.__class__.__name__}{len(self.blank_objects)}"
            self.blank_objects[o] = _id

        return self.blank_objects[o]

    def is_refed(self, o):
        return o in self.ref_objects

    def add_refed(self, o):
        self.ref_objects.add(o)

    def is_written(self, o):
        return o in self.written_objects

    def add_written(self, o):
        self.written_objects.add(o)


def encode_objects(encoder, objects, force_list=False):
    """
    Serialize a list of objects to a serialization encoder

    If force_list is true, a list will always be written using the encoder.
    """
    ref_counts = {}
    state = EncodeState()

    def walk_callback(value, path):
        nonlocal state
        nonlocal ref_counts

        if not isinstance(value, SHACLObject):
            return True

        # Remove blank node ID for re-assignment
        if value._id and value._id.startswith("_:"):
            del value._id

        if value._id:
            state.add_refed(value)

        # If the object is referenced more than once, add it to the set of
        # referenced objects
        ref_counts.setdefault(value, 0)
        ref_counts[value] += 1
        if ref_counts[value] > 1:
            state.add_refed(value)
            return False

        return True

    for o in objects:
        if o._id:
            state.add_refed(o)
        o.walk(walk_callback)

    use_list = force_list or len(objects) > 1

    objects = set(objects)

    if use_list:
        # If we are making a list add all the objects referred to by reference
        # to the list
        objects |= state.ref_objects

    objects = list(objects)
    objects.sort()

    if use_list:
        # Ensure top level objects are only written in the top level graph
        # node, and referenced by ID everywhere else. This is done by setting
        # the flag that indicates this object has been written for all the top
        # level objects, then clearing it right before serializing the object.
        #
        # In this way, if an object is referenced before it is supposed to be
        # serialized into the @graph, it will serialize as a string instead of
        # the actual object
        for o in objects:
            state.written_objects.add(o)

        with encoder.write_list() as list_s:
            for o in objects:
                # Allow this specific object to be written now
                state.written_objects.remove(o)
                with list_s.write_list_item() as item_s:
                    o.encode(item_s, state)

    else:
        objects[0].encode(encoder, state)


def decode_objects(decoder):
    object_ids = {}
    objects = [
        SHACLObject.decode(obj_d, object_ids=object_ids)
        for obj_d in decoder.read_list()
    ]

    for o in objects:
        o.link(object_ids)

    # Remove blank node IDs
    for o in objects:
        for c in o.child_objects():
            if c._id and c._id.startswith("_:"):
                del c._id

    object_ids = {k: v for k, v in object_ids.items() if not k.startswith("_:")}

    return objects, object_ids


class Decoder(ABC):
    @abstractmethod
    def read_string(self):
        """
        Consume the next item as a string.

        Returns the string value of the next item, or `None` if the next item
        is not a string
        """
        pass

    @abstractmethod
    def read_datetime(self):
        """
        Consumes the next item as a date & time string

        Returns the string value of the next item, if it is a ISO datetime, or
        `None` if the next item is not a ISO datetime string.

        Note that validation of the string is done by the caller, so a minimal
        implementation can just check if the next item is a string without
        worrying about the format
        """
        pass

    @abstractmethod
    def read_integer(self):
        """
        Consumes the next item as an integer

        Returns the integer value of the next item, or `None` if the next item
        is not an integer
        """
        pass

    @abstractmethod
    def read_iri(self):
        """
        Consumes the next item as an IRI string

        Returns the string value of the next item an IRI, or `None` if the next
        item is not an IRI.

        The returned string should be either a fully-qualified IRI, or a blank
        node ID
        """
        pass

    @abstractmethod
    def read_enum(self, e):
        """
        Consumes the next item as an Enum value string

        Returns the fully qualified IRI of the next enum item, or `None` if the
        next item is not an enum value.

        The callee is responsible for validating that the returned IRI is
        actually a member of the specified Enum, so the `Decoder` does not need
        to check that, but can if it wishes
        """
        pass

    @abstractmethod
    def read_bool(self):
        """
        Consume the next item as a boolean value

        Returns the boolean value of the next item, or `None` if the next item
        is not a boolean
        """
        pass

    @abstractmethod
    def read_float(self):
        """
        Consume the next item as a float value

        Returns the float value of the next item, or `None` if the next item is
        not a float
        """
        pass

    @abstractmethod
    def read_list(self):
        """
        Consume the next item as a list generator

        This should generate a `Decoder` object for each item in the list. The
        generated `Decoder` can be used to read the corresponding item from the
        list
        """
        pass

    @abstractmethod
    def read_object(self):
        """
        Consume next item as an object

        A context manager that "enters" the next item as a object and yields a
        `Decoder` that can read properties from it. If the next item is not an
        object, yields `None`

        Properties will be read out of the object using `read_property` and
        `read_object_id`
        """
        pass

    @abstractmethod
    @contextmanager
    def read_property(self, iri, compact=None):
        """
        Read property from object

        A context manager that yields a `Decoder` that can be used to read the
        value of the property with the given IRI in the current object, or
        `None` if the property does not exist in the current object.

        Note that the provided IRI will be fully qualified. If `compact` is
        provided and the serialization supports compacted IRIs, it should be
        preferred to the full IRI.
        """
        pass

    @abstractmethod
    def read_object_id(self, alias=None):
        """
        Read current object ID property

        Returns the ID of the current object if one is defined, or `None` if
        the current object has no ID.

        The ID must be a fully qualified IRI or a blank node

        If `alias` is provided, is is a hint as to another name by which the ID
        might be found, if the `Decoder` supports aliases for an ID
        """
        pass


class JSONLDDecoder(Decoder):
    def __init__(self, data):
        self.data = data

    def read_string(self):
        if isinstance(self.data, str):
            return self.data
        return None

    def read_datetime(self):
        return self.read_string()

    def read_integer(self):
        if isinstance(self.data, int):
            return self.data
        return None

    def read_bool(self):
        if isinstance(self.data, bool):
            return self.data
        return None

    def read_float(self):
        if isinstance(self.data, (int, float, str)):
            return float(self.data)
        return None

    def read_iri(self):
        if isinstance(self.data, str):
            return self.data
        return None

    def read_enum(self, e):
        if isinstance(self.data, str):
            return self.data
        return None

    def read_list(self):
        if isinstance(self.data, (list, tuple, set)):
            for v in self.data:
                yield self.__class__(v)
        else:
            yield self

    def __get_value(self, *keys):
        for k in keys:
            if k and k in self.data:
                return self.data[k]
        return None

    @contextmanager
    def read_property(self, iri, compact=None):
        v = self.__get_value(compact, iri)
        if v is not None:
            yield self.__class__(v)
        else:
            yield None

    def read_object(self):
        typ = self.__get_value("@type", "@type")
        if typ is not None:
            return typ, self

        return None, self

    def read_object_id(self, alias=None):
        return self.__get_value(alias, "@id")


class JSONLDDeserializer(object):
    def read(self, f):
        data = json.load(f)
        if "@graph" in data:
            h = JSONLDDecoder(data["@graph"])
        else:
            h = JSONLDDecoder(data)

        return decode_objects(h)


class Encoder(ABC):
    @abstractmethod
    def write_string(self, v):
        """
        Write a string value

        Encodes the value as a string in the output
        """
        pass

    @abstractmethod
    def write_datetime(self, v):
        """
        Write a date & time string

        Encodes the value as an ISO datetime string

        Note: The provided string is already correctly encoded as an ISO datetime
        """
        pass

    @abstractmethod
    def write_integer(self, v):
        """
        Write an integer value

        Encodes the value as an integer in the output
        """
        pass

    @abstractmethod
    def write_iri(self, v, compact=None):
        """
        Write IRI

        Encodes the string as an IRI. Note that the string will be either a
        fully qualified IRI or a blank node ID. If `compact` is provided and
        the serialization supports compacted IRIs, it should be preferred to
        the full IRI
        """
        pass

    @abstractmethod
    def write_enum(self, v, e, compact=None):
        """
        Write enum value IRI

        Encodes the string enum value IRI. Note that the string will be a fully
        qualified IRI. If `compact` is provided and the serialization supports
        compacted IRIs, it should be preferred to the full IRI.
        """
        pass

    @abstractmethod
    def write_bool(self, v):
        """
        Write boolean

        Encodes the value as a boolean in the output
        """
        pass

    @abstractmethod
    def write_float(self, v):
        """
        Write float

        Encodes the value as a floating point number in the output
        """
        pass

    @abstractmethod
    @contextmanager
    def write_object(self, o, _id, needs_id):
        """
        Write object

        A context manager that yields an `Encoder` that can be used to encode
        the given object properties.

        The provided ID will always be a valid ID (even if o._id is `None`), in
        case the `Encoder` _must_ have an ID. `needs_id` is a hint to indicate
        to the `Encoder` if an ID must be written or not (if that is even an
        option). If it is `True`, the `Encoder` must encode an ID for the
        object. If `False`, the encoder is not required to encode an ID and may
        omit it.

        The ID will be either a fully qualified IRI, or a blank node IRI.

        Properties will be written the object using `write_property`
        """
        pass

    @abstractmethod
    @contextmanager
    def write_property(self, iri, compact=None):
        """
        Write object property

        A context manager that yields an `Encoder` that can be used to encode
        the value for the property with the given IRI in the current object

        Note that the IRI will be fully qualified. If `compact` is provided and
        the serialization supports compacted IRIs, it should be preferred to
        the full IRI.
        """
        pass

    @abstractmethod
    @contextmanager
    def write_list(self):
        """
        Write list

        A context manager that yields an `Encoder` that can be used to encode a
        list.

        Each item of the list will be added using `write_list_item`
        """
        pass

    @abstractmethod
    @contextmanager
    def write_list_item(self):
        """
        Write list item

        A context manager that yields an `Encoder` that can be used to encode
        the value for a list item
        """
        pass


class JSONLDEncoder(Encoder):
    def __init__(self, data=None):
        self.data = data

    def write_string(self, v):
        self.data = v

    def write_datetime(self, v):
        self.data = v

    def write_integer(self, v):
        self.data = v

    def write_iri(self, v, compact=None):
        self.write_string(compact or v)

    def write_enum(self, v, e, compact=None):
        self.write_string(compact or v)

    def write_bool(self, v):
        self.data = v

    def write_float(self, v):
        self.data = str(v)

    @contextmanager
    def write_property(self, iri, compact=None):
        s = self.__class__(None)
        yield s
        if s.data is not None:
            self.data[compact or iri] = s.data

    @contextmanager
    def write_object(self, o, _id, needs_id):
        self.data = {
            "@type": o.COMPACT_TYPE or o.TYPE,
        }
        if needs_id:
            self.data[o.ID_ALIAS or "@id"] = _id
        yield self

    @contextmanager
    def write_list(self):
        self.data = []
        yield self
        if not self.data:
            self.data = None

    @contextmanager
    def write_list_item(self):
        s = self.__class__(None)
        yield s
        if s.data is not None:
            self.data.append(s.data)


class JSONLDSerializer(object):
    def serialize_data(self, objects, force_graph=False):
        h = JSONLDEncoder()
        encode_objects(h, objects, force_graph)
        if isinstance(h.data, list):
            data = {
                "@graph": h.data,
            }
        else:
            data = h.data

        if len(CONTEXT_URLS) == 1:
            data["@context"] = CONTEXT_URLS[0]
        elif CONTEXT_URLS:
            data["@context"] = CONTEXT_URLS

        return data

    def write(self, objects, f, force_graph=False, **kwargs):
        """
        Write a list of objects to a JSON LD file

        If force_graph is True, a @graph node will always be written
        """
        data = self.serialize_data(objects, force_graph)

        sha1 = hashlib.sha1()
        for chunk in json.JSONEncoder(**kwargs).iterencode(data):
            chunk = chunk.encode("utf-8")
            f.write(chunk)
            sha1.update(chunk)

        return sha1.hexdigest()


class JSONLDInlineEncoder(Encoder):
    def __init__(self, f, sha1):
        self.f = f
        self.comma = False
        self.sha1 = sha1

    def write(self, s):
        s = s.encode("utf-8")
        self.f.write(s)
        self.sha1.update(s)

    def _write_comma(self):
        if self.comma:
            self.write(",")
            self.comma = False

    def _need_comma(self):
        self.comma = True

    def write_string(self, v):
        self.write(f'"{v}"')

    def write_datetime(self, v):
        self.write_string(v)

    def write_integer(self, v):
        self.write(f"{v}")

    def write_iri(self, v, compact=None):
        self.write_string(compact or v)

    def write_enum(self, v, e, compact=None):
        self.write_iri(v, compact)

    def write_bool(self, v):
        if v:
            self.write("true")
        else:
            self.write("false")

    def write_float(self, v):
        self.write(f'"{v}"')

    @contextmanager
    def write_property(self, iri, compact=None):
        self._write_comma()
        self.write(f'"{compact or iri}":')
        yield self
        self.comma = True

    @contextmanager
    def write_object(self, o, _id, needs_id):
        self._write_comma()

        self.write("{")
        if needs_id:
            idname = o.ID_ALIAS or "@id"
            idval = _id
            self.write(f'"{idname}": "{idval}",')

        typname = "@type"
        typval = o.COMPACT_TYPE or o.TYPE
        self.write(f'"{typname}":"{typval}"')

        self.comma = True
        yield self

        self.write("}")
        self.comma = True

    @contextmanager
    def write_list(self):
        self._write_comma()
        self.write("[")
        yield self.__class__(self.f, self.sha1)
        self.write("]")
        self.comma = True

    @contextmanager
    def write_list_item(self):
        self._write_comma()
        yield self.__class__(self.f, self.sha1)
        self.comma = True


class JSONLDInlineSerializer(object):
    def write(self, objects, f):
        """
        Write a list of objects to a JSON LD file
        """
        sha1 = hashlib.sha1()
        h = JSONLDInlineEncoder(f, sha1)
        h.write('{"@context":')
        if len(CONTEXT_URLS) == 1:
            h.write(f'"{CONTEXT_URLS[0]}"')
        elif CONTEXT_URLS:
            h.write('["')
            h.write('","'.join(CONTEXT_URLS))
            h.write('"]')
        h.write(",")

        h.write('"@graph":')

        encode_objects(h, objects, True)
        h.write("}")
        return sha1.hexdigest()


def print_tree(objects, all_fields=False):
    """
    Print object tree
    """
    seen = set()

    def callback(value, path):
        nonlocal seen

        s = ("  " * (len(path) - 1)) + f"{path[-1]}"
        if isinstance(value, SHACLObject):
            s += f" {value} ({id(value)})"
            is_empty = False
        elif isinstance(value, ListProxy):
            is_empty = len(value) == 0
            if is_empty:
                s += " []"
        else:
            s += f" {value!r}"
            is_empty = value is None

        if all_fields or not is_empty:
            print(s)

        if isinstance(value, SHACLObject):
            if value in seen:
                return False
            seen.add(value)
            return True

        return True

    for o in objects:
        o.walk(callback)


# fmt: off
"""Format Guard"""


CONTEXT_URLS = [
]


# ENUMERATIONS
# An enumerated type
class http_example_org_enumType(EnumProp):
    TYPE = "http://example.org/enumType"
    valid_values = [
        ("bar", "http://example.org/enumType/bar"),
        ("foo", "http://example.org/enumType/foo"),
        ("nolabel", "http://example.org/enumType/nolabel"),
    ]
    # The bar value of enumType
    bar = "http://example.org/enumType/bar"
    # The foo value of enumType
    foo = "http://example.org/enumType/foo"
    # This value has no label
    nolabel = "http://example.org/enumType/nolabel"


# CLASSES
# A class with an ID alias
class http_example_org_id_prop_class(SHACLObject):
    TYPE = "http://example.org/id-prop-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI
    ID_ALIAS = "testid"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/id-prop-class"] = http_example_org_id_prop_class


# A class that inherits its idPropertyName from the parent
class http_example_org_inherited_id_prop_class(http_example_org_id_prop_class):
    TYPE = "http://example.org/inherited-id-prop-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI
    ID_ALIAS = "testid"

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/inherited-id-prop-class"] = http_example_org_inherited_id_prop_class


# A class to test links
class http_example_org_link_class(SHACLObject):
    TYPE = "http://example.org/link-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        # A link-class list property
        self._add_property(
            "link_list_prop",
            ListProp(ObjectProp(http_example_org_link_class, False)),
            iri="http://example.org/link-class-link-list-prop",
        )
        # A link-class property
        self._add_property(
            "link_prop",
            ObjectProp(http_example_org_link_class, False),
            iri="http://example.org/link-class-link-prop",
        )
        # A link-class property with no sh:class
        self._add_property(
            "link_prop_no_class",
            ObjectProp(http_example_org_link_class, False),
            iri="http://example.org/link-class-link-prop-no-class",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/link-class"] = http_example_org_link_class


# A class derived from link-class
class http_example_org_link_derived_class(http_example_org_link_class):
    TYPE = "http://example.org/link-derived-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/link-derived-class"] = http_example_org_link_derived_class


# A class that must be a blank node
class http_example_org_node_kind_blank(http_example_org_link_class):
    TYPE = "http://example.org/node-kind-blank"
    NODE_KIND = NodeKind.BlankNode

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/node-kind-blank"] = http_example_org_node_kind_blank


# A class that must be an IRI
class http_example_org_node_kind_iri(http_example_org_link_class):
    TYPE = "http://example.org/node-kind-iri"
    NODE_KIND = NodeKind.IRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/node-kind-iri"] = http_example_org_node_kind_iri


# A class that can be either a blank node or an IRI
class http_example_org_node_kind_iri_or_blank(http_example_org_link_class):
    TYPE = "http://example.org/node-kind-iri-or-blank"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/node-kind-iri-or-blank"] = http_example_org_node_kind_iri_or_blank


# The parent class
class http_example_org_parent_class(SHACLObject):
    TYPE = "http://example.org/parent-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/parent-class"] = http_example_org_parent_class


# Another class
class http_example_org_test_another_class(SHACLObject):
    TYPE = "http://example.org/test-another-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-another-class"] = http_example_org_test_another_class


# The test class
class http_example_org_test_class(http_example_org_parent_class):
    TYPE = "http://example.org/test-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        # A property that conflicts with an existing SHACLObject property
        self._add_property(
            "encode",
            StringProp(),
            iri="http://example.org/encode",
        )
        # A property that is a keyword
        self._add_property(
            "import_",
            StringProp(),
            iri="http://example.org/import",
        )
        # a URI
        self._add_property(
            "anyuri_prop",
            AnyURIProp(),
            iri="http://example.org/test-class/anyuri-prop",
        )
        # a boolean property
        self._add_property(
            "boolean_prop",
            BooleanProp(),
            iri="http://example.org/test-class/boolean-prop",
        )
        # A test-class list property
        self._add_property(
            "class_list_prop",
            ListProp(ObjectProp(http_example_org_test_class, False)),
            iri="http://example.org/test-class/class-list-prop",
        )
        # A test-class property
        self._add_property(
            "class_prop",
            ObjectProp(http_example_org_test_class, False),
            iri="http://example.org/test-class/class-prop",
        )
        # A test-class property with no sh:class
        self._add_property(
            "class_prop_no_class",
            ObjectProp(http_example_org_test_class, False),
            iri="http://example.org/test-class/class-prop-no-class",
        )
        # A datetime list property
        self._add_property(
            "datetime_list_prop",
            ListProp(DateTimeProp()),
            iri="http://example.org/test-class/datetime-list-prop",
        )
        # A scalar datetime property
        self._add_property(
            "datetime_scalar_prop",
            DateTimeProp(),
            iri="http://example.org/test-class/datetime-scalar-prop",
        )
        # A scalar dateTimeStamp property
        self._add_property(
            "datetimestamp_scalar_prop",
            DateTimeStampProp(),
            iri="http://example.org/test-class/datetimestamp-scalar-prop",
        )
        # A enum list property
        self._add_property(
            "enum_list_prop",
            ListProp(http_example_org_enumType(context=[
            ])),
            iri="http://example.org/test-class/enum-list-prop",
        )
        # A enum property
        self._add_property(
            "enum_prop",
            http_example_org_enumType(context=[
            ]),
            iri="http://example.org/test-class/enum-prop",
        )
        # A enum property with no sh:class
        self._add_property(
            "enum_prop_no_class",
            http_example_org_enumType(context=[
            ]),
            iri="http://example.org/test-class/enum-prop-no-class",
        )
        # a float property
        self._add_property(
            "float_prop",
            FloatProp(),
            iri="http://example.org/test-class/float-prop",
        )
        # a non-negative integer
        self._add_property(
            "integer_prop",
            IntegerProp(),
            iri="http://example.org/test-class/integer-prop",
        )
        # A named property
        self._add_property(
            "named_property",
            StringProp(),
            iri="http://example.org/test-class/named-property",
        )
        # a non-negative integer
        self._add_property(
            "nonnegative_integer_prop",
            NonNegativeIntegerProp(),
            iri="http://example.org/test-class/nonnegative-integer-prop",
        )
        # A positive integer
        self._add_property(
            "positive_integer_prop",
            PositiveIntegerProp(),
            iri="http://example.org/test-class/positive-integer-prop",
        )
        # A regex validated string
        self._add_property(
            "regex",
            StringProp(pattern=r"^foo\d",),
            iri="http://example.org/test-class/regex",
        )
        # A regex dateTime
        self._add_property(
            "regex_datetime",
            DateTimeProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\d\+01:00$",),
            iri="http://example.org/test-class/regex-datetime",
        )
        # A regex dateTimeStamp
        self._add_property(
            "regex_datetimestamp",
            DateTimeStampProp(pattern=r"^\d\d\d\d-\d\d-\d\dT\d\d:\d\d:\d\dZ$",),
            iri="http://example.org/test-class/regex-datetimestamp",
        )
        # A regex validated string list
        self._add_property(
            "regex_list",
            ListProp(StringProp(pattern=r"^foo\d",)),
            iri="http://example.org/test-class/regex-list",
        )
        # A string list property with no sh:datatype
        self._add_property(
            "string_list_no_datatype",
            ListProp(StringProp()),
            iri="http://example.org/test-class/string-list-no-datatype",
        )
        # A string list property
        self._add_property(
            "string_list_prop",
            ListProp(StringProp()),
            iri="http://example.org/test-class/string-list-prop",
        )
        # A scalar string propery
        self._add_property(
            "string_scalar_prop",
            StringProp(),
            iri="http://example.org/test-class/string-scalar-prop",
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-class"] = http_example_org_test_class


class http_example_org_test_class_required(http_example_org_test_class):
    TYPE = "http://example.org/test-class-required"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        # A required string list property
        self._add_property(
            "required_string_list_prop",
            ListProp(StringProp()),
            iri="http://example.org/test-class/required-string-list-prop",
            max_count=2,
            min_count=1,
        )
        # A required scalar string property
        self._add_property(
            "required_string_scalar_prop",
            StringProp(),
            iri="http://example.org/test-class/required-string-scalar-prop",
            min_count=1,
        )
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-class-required"] = http_example_org_test_class_required


# A class derived from test-class
class http_example_org_test_derived_class(http_example_org_test_class):
    TYPE = "http://example.org/test-derived-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/test-derived-class"] = http_example_org_test_derived_class


# Derived class that sorts before the parent to test ordering
class http_example_org_aaa_derived_class(http_example_org_parent_class):
    TYPE = "http://example.org/aaa-derived-class"
    NODE_KIND = NodeKind.BlankNodeOrIRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/aaa-derived-class"] = http_example_org_aaa_derived_class


# A class that derives its nodeKind from parent
class http_example_org_derived_node_kind_iri(http_example_org_node_kind_iri):
    TYPE = "http://example.org/derived-node-kind-iri"
    NODE_KIND = NodeKind.IRI

    def __init__(self, **kwargs):
        super().__init__()
        self._set_init_props(**kwargs)


SHACLObject.DESERIALIZERS["http://example.org/derived-node-kind-iri"] = http_example_org_derived_node_kind_iri


"""Format Guard"""
# fmt: on


def main():
    import argparse
    from pathlib import Path

    parser = argparse.ArgumentParser(description="Python SHACL model test")
    parser.add_argument("infile", type=Path, help="Input file")
    parser.add_argument("--print", action="store_true", help="Print object tree")
    parser.add_argument("--outfile", type=Path, help="Output file")

    args = parser.parse_args()

    with args.infile.open("r") as f:
        d = JSONLDDeserializer()
        objects, _ = d.read(f)

    if args.print:
        print_tree(objects)

    if args.outfile:
        with args.outfile.open("wb") as f:
            s = JSONLDSerializer()
            s.write(objects, f)

    return 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
